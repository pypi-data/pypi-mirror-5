__version__ = "0.0.2.post1.g9b8d746"
__git_commiter_name__ = "root"
__git_commiter_email__ = "root@guyr-ubuntu.infinidat.com"
__git_branch__ = 'develop'
__git_remote_tracking_branch__ = 'origin/develop'
__git_remote_url__ = 'git@infinigit.infinidat.com:/host/memuse.git'
__git_head_hash__ = '9b8d7461e9f32b5fe7ee6ab8492298e9365f6af7'
__git_head_subject__ = 'empty commit after version v0.0.2'
__git_head_message__ = ''
__git_dirty_diff__ = 'diff --git a/bootstrap.py b/bootstrap.py\nindex 895275e..75e63cd 100644\n--- a/bootstrap.py\n+++ b/bootstrap.py\n@@ -18,69 +18,37 @@ The script accepts buildout command-line options, so you can\n use the -c option to specify an alternate configuration file.\n """\n \n-import os, shutil, sys, tempfile, textwrap, urllib, urllib2, subprocess\n+import os\n+import shutil\n+import sys\n+import tempfile\n+import glob\n+import re\n+\n from optparse import OptionParser\n \n-if sys.platform == \'win32\':\n-    def quote(c):\n-        if \' \' in c:\n-            return \'"%s"\' % c  # work around spawn lamosity on windows\n-        else:\n-            return c\n-else:\n-    quote = str\n-\n-# See zc.buildout.easy_install._has_broken_dash_S for motivation and comments.\n-stdout, stderr = subprocess.Popen(\n-    [sys.executable, \'-Sc\',\n-     \'try:\\n\'\n-     \'    import ConfigParser\\n\'\n-     \'except ImportError:\\n\'\n-     \'    print 1\\n\'\n-     \'else:\\n\'\n-     \'    print 0\\n\'],\n-    stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()\n-has_broken_dash_S = bool(int(stdout.strip()))\n-\n-# In order to be more robust in the face of system Pythons, we want to\n-# run without site-packages loaded.  This is somewhat tricky, in\n-# particular because Python 2.6\'s distutils imports site, so starting\n-# with the -S flag is not sufficient.  However, we\'ll start with that:\n-if not has_broken_dash_S and \'site\' in sys.modules:\n-    # We will restart with python -S.\n-    args = sys.argv[:]\n-    args[0:0] = [sys.executable, \'-S\']\n-    args = map(quote, args)\n-    subprocess.Popen([sys.executable, ] + args,\n-                    stdout=subprocess.PIPE, stderr=subprocess.PIPE).wait()\n-# Now we are running with -S.  We\'ll get the clean sys.path, import site\n-# because distutils will do it later, and then reset the path and clean\n-# out any namespace packages from site-packages that might have been\n-# loaded by .pth files.\n-clean_path = sys.path[:]\n-import site  # imported because of its side effects\n-sys.path[:] = clean_path\n-for k, v in sys.modules.items():\n-    if k in (\'setuptools\', \'pkg_resources\') or (\n-        hasattr(v, \'__path__\') and\n-        len(v.__path__) == 1 and\n-        not os.path.exists(os.path.join(v.__path__[0], \'__init__.py\'))):\n-        # This is a namespace package.  Remove it.\n-        sys.modules.pop(k)\n-\n-is_jython = sys.platform.startswith(\'java\')\n-\n-setuptools_source = \'http://peak.telecommunity.com/dist/ez_setup.py\'\n-distribute_source = \'http://python-distribute.org/distribute_setup.py\'\n-\n-\n-# parsing arguments\n+tmpeggs = tempfile.mkdtemp()\n+\n+usage = \'\'\'\\\n+[DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]\n+\n+Bootstraps a buildout-based project.\n+\n+Simply run this script in a directory containing a buildout.cfg, using the\n+Python that you want bin/buildout to use.\n+\n+Note that by using --find-links to point to local resources, you can keep\n+this script from going over the network.\n+\'\'\'\n+\n def normalize_to_url(option, opt_str, value, parser):\n+    # copied from zc.buildout-1.x bootstrap.py\n+    from urllib import pathname2url\n     if value:\n         if \'://\' not in value:  # It doesn\'t smell like a URL.\n             value = \'file://%s\' % (\n-                urllib.pathname2url(\n-                    os.path.abspath(os.path.expanduser(value))),)\n+                pathname2url(\n+                os.path.abspath(os.path.expanduser(value))),)\n         if opt_str == \'--download-base\' and not value.endswith(\'/\'):\n             # Download base needs a trailing slash to make the world happy.\n             value += \'/\'\n@@ -89,39 +57,13 @@ def normalize_to_url(option, opt_str, value, parser):\n     name = opt_str[2:].replace(\'-\', \'_\')\n     setattr(parser.values, name, value)\n \n-usage = \'\'\'\\\n-[DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]\n-\n-Bootstraps a buildout-based project.\n-\n-Simply run this script in a directory containing a buildout.cfg, using the\n-Python that you want bin/buildout to use.\n-\n-Note that by using --setup-source and --download-base to point to\n-local resources, you can keep this script from going over the network.\n-\'\'\'\n+ezsetup_source = \'https://bitbucket.org/pypa/setuptools/raw/0.8/ez_setup.py\'\n+setuptools_source = "https://pypi.python.org/packages/source/s/setuptools/"\n+pypi_index = "https://pypi.python.org/simple/"\n \n parser = OptionParser(usage=usage)\n-parser.add_option("-v", "--version", dest="version",\n-                          help="use a specific zc.buildout version")\n-parser.add_option("-d", "--distribute",\n-                   action="store_true", dest="use_distribute", default=False,\n-                   help="Use Distribute rather than Setuptools.")\n-parser.add_option("--setup-source", action="callback", dest="setup_source",\n-                  callback=normalize_to_url, nargs=1, type="string",\n-                  help=("Specify a URL or file location for the setup file. "\n-                        "If you use Setuptools, this will default to " +\n-                        setuptools_source + "; if you use Distribute, this "\n-                        "will default to " + distribute_source + "."))\n-parser.add_option("--download-base", action="callback", dest="download_base",\n-                  callback=normalize_to_url, nargs=1, type="string",\n-                  help=("Specify a URL or directory for downloading "\n-                        "zc.buildout and either Setuptools or Distribute. "\n-                        "Defaults to PyPI."))\n-parser.add_option("--eggs",\n-                  help=("Specify a directory for storing eggs.  Defaults to "\n-                        "a temporary directory that is deleted when the "\n-                        "bootstrap script completes."))\n+parser.add_option("-v", "--version", help="use a specific zc.buildout version")\n+\n parser.add_option("-t", "--accept-buildout-test-releases",\n                   dest=\'accept_buildout_test_releases\',\n                   action="store_true", default=False,\n@@ -131,50 +73,93 @@ parser.add_option("-t", "--accept-buildout-test-releases",\n                         "extensions for you.  If you use this flag, "\n                         "bootstrap and buildout will get the newest releases "\n                         "even if they are alphas or betas."))\n-parser.add_option("-c", None, action="store", dest="config_file",\n-                   help=("Specify the path to the buildout configuration "\n-                         "file to be used."))\n+parser.add_option("-c", "--config-file",\n+                  help=("Specify the path to the buildout configuration "\n+                        "file to be used."))\n+parser.add_option("-f", "--find-links",\n+                  help=("Specify a URL to search for buildout releases"))\n+# in closed networks, one needs to provide the location of ez_setup.py\n+parser.add_option("--setup-source", action="callback", dest="setup_source",\n+                  callback=normalize_to_url, nargs=1, type="string",\n+                  help=("Specify a URL or file location for the setuptool\'s ez_setup.py"),\n+                  default=ezsetup_source)\n+# in closed networks, one needs to provide the location of the setuptools and buildout archives\n+parser.add_option("--download-base", action="callback", dest="download_base",\n+                  callback=normalize_to_url, nargs=1, type="string",\n+                  help=("Specify a URL or directory for downloading setuptools and buildout"),\n+                  default=setuptools_source)\n+# in closed networks, one needs to provide an index server to find buildout on\n+parser.add_option("--index-url", action="callback", dest="index_url",\n+                  callback=normalize_to_url, nargs=1, type="string",\n+                  help=("Specify an alternative for PyPI simple index url"),\n+                  default=pypi_index)\n \n-options, orig_args = parser.parse_args()\n+options, args = parser.parse_args()\n \n-args = []\n+######################################################################\n+# load/install setuptools\n \n-# if -c was provided, we push it back into args for buildout\'s main function\n-if options.config_file is not None:\n-    args += [\'-c\', options.config_file]\n+def _cleanup_old_zc_buildout_modules():\n+    # installing setuptools imported the site module, which added all the stuff in site-packages to sys.path,\n+    # even though in the case Python was executed -S.\n+    # we want to remove all traces for this\n+    for item in sys.path:\n+        if \'zc\' in item:\n+            sys.path.remove(item)\n+    for module in sys.modules.keys():\n+        if \'zc\' in module:\n+            del sys.modules[module]\n \n-if options.eggs:\n-    eggs_dir = os.path.abspath(os.path.expanduser(options.eggs))\n-else:\n-    eggs_dir = tempfile.mkdtemp()\n+def _cleanup_setuptools_and_distribute_modules():\n+    # installing setuptools imported the site module, which added all the stuff in site-packages to sys.path,\n+    # even though in the case Python was executed -S.\n+    # we want to remove all traces for this\n+    paths_to_remove = [item for item in sys.path if \'setuptools-\' in item or \'distribute-\' in item]\n+    # the python-setuptools installs setuptools in a different way\n+    paths_to_remove.extend(item for item in sys.path if glob.glob(os.path.join(item, \'setuptools-*\'))\n+                           and \'dist-packages\' in item)\n+    paths_to_remove.extend(item for item in sys.path if glob.glob(os.path.join(item, \'distribute-*\'))\n+                           and \'dist-packages\' in item)\n+    sys.path = list(set(sys.path) - set(paths_to_remove))\n \n-if options.setup_source is None:\n-    if options.use_distribute:\n-        options.setup_source = distribute_source\n-    else:\n-        options.setup_source = setuptools_source\n \n-if options.accept_buildout_test_releases:\n-    args.append(\'buildout:accept-buildout-test-releases=true\')\n+to_reload = False\n+try:\n+    from urlparse import urlparse\n+except ImportError:\n+    from urllib.parse import urlparse\n+\n+try:\n+    from urllib.request import urlopen\n+except ImportError:\n+    from urllib2 import urlopen\n+\n+_cleanup_setuptools_and_distribute_modules()\n+_cleanup_setuptools_and_distribute_modules()  # wtf need to run twice\n \n try:\n     import pkg_resources\n-    import setuptools  # A flag.  Sometimes pkg_resources is installed alone.\n-    if not hasattr(pkg_resources, \'_distribute\'):\n-        raise ImportError\n+    import setuptools\n except ImportError:\n-    ez_code = urllib2.urlopen(\n-        options.setup_source).read().replace(\'\\r\\n\', \'\\n\')\n     ez = {}\n-    exec ez_code in ez\n-    setup_args = dict(to_dir=eggs_dir, download_delay=0)\n+\n+    # XXX use a more permanent ez_setup.py URL when available.\n+    exec(urlopen(options.setup_source).read(), ez)\n+    setup_args = dict(to_dir=tmpeggs, download_delay=0)\n     if options.download_base:\n         setup_args[\'download_base\'] = options.download_base\n-    if options.use_distribute:\n-        setup_args[\'no_fake\'] = True\n+        if options.download_base.startswith("file://"):\n+            download_base = urlparse(options.download_base).path\n+            if os.path.exists(download_base):\n+                files = glob.glob(os.path.join(download_base, "setuptools-*.tar.gz"))\n+                if len(files) == 1:\n+                    setuptools_version = re.match("setuptools-(?P<version>.*).tar.gz",\n+                                                  os.path.basename(files[0])).groupdict()[\'version\']\n+                    setup_args[\'version\'] = setuptools_version\n     ez[\'use_setuptools\'](**setup_args)\n-    if \'pkg_resources\' in sys.modules:\n-        reload(sys.modules[\'pkg_resources\'])\n+\n+    if to_reload:\n+        reload(pkg_resources)\n     import pkg_resources\n     # This does not (always?) update the default working set.  We will\n     # do it.\n@@ -182,31 +167,29 @@ except ImportError:\n         if path not in pkg_resources.working_set.entries:\n             pkg_resources.working_set.add_entry(path)\n \n-cmd = [quote(sys.executable),\n-       \'-c\',\n-       quote(\'from setuptools.command.easy_install import main; main()\'),\n-       \'-mqNxd\',\n-       quote(eggs_dir)]\n+######################################################################\n+# Install buildout\n+\n+ws = pkg_resources.working_set\n \n-if not has_broken_dash_S:\n-    cmd.insert(1, \'-S\')\n+cmd = [sys.executable, \'-c\',\n+       \'from setuptools.command.easy_install import main; main()\',\n+       \'-mZqNxd\', tmpeggs]\n \n-find_links = options.download_base\n-if not find_links:\n-    find_links = os.environ.get(\'bootstrap-testing-find-links\')\n+find_links = os.environ.get(\n+    \'bootstrap-testing-find-links\',\n+    options.find_links or\n+    (\'http://downloads.buildout.org/\'\n+     if options.accept_buildout_test_releases else None)\n+    )\n if find_links:\n-    cmd.extend([\'-f\', quote(find_links)])\n-\n-if options.use_distribute:\n-    setup_requirement = \'distribute\'\n-else:\n-    setup_requirement = \'setuptools\'\n-ws = pkg_resources.working_set\n-setup_requirement_path = ws.find(\n-    pkg_resources.Requirement.parse(setup_requirement)).location\n-env = dict(\n-    os.environ,\n-    PYTHONPATH=setup_requirement_path)\n+    cmd.extend([\'-f\', find_links])\n+if options.download_base:\n+    cmd.extend(["-f", options.download_base])\n+if options.index_url:\n+    cmd.extend(["-i", options.index_url])\n+setuptools_path = ws.find(\n+    pkg_resources.Requirement.parse(\'setuptools\')).location\n \n requirement = \'zc.buildout\'\n version = options.version\n@@ -220,10 +203,14 @@ if version is None and not options.accept_buildout_test_releases:\n             if (part[:1] == \'*\') and (part not in _final_parts):\n                 return False\n         return True\n-    index = setuptools.package_index.PackageIndex(\n-        search_path=[setup_requirement_path])\n+    kwargs = dict(search_path=[setuptools_path])\n+    if options.index_url:\n+        kwargs[\'index_url\'] = options.index_url\n+    index = setuptools.package_index.PackageIndex(**kwargs)\n     if find_links:\n         index.add_find_links((find_links,))\n+    if options.download_base:\n+        index.add_find_links((options.download_base,))\n     req = pkg_resources.Requirement.parse(requirement)\n     if index.obtain(req) is not None:\n         best = []\n@@ -243,25 +230,29 @@ if version:\n     requirement = \'==\'.join((requirement, version))\n cmd.append(requirement)\n \n-if is_jython:\n-    import subprocess\n-    exitcode = subprocess.Popen(cmd, env=env).wait()\n-else:  # Windows prefers this, apparently; otherwise we would prefer subprocess\n-    exitcode = os.spawnle(*([os.P_WAIT, sys.executable] + cmd + [env]))\n-if exitcode != 0:\n-    sys.stdout.flush()\n-    sys.stderr.flush()\n-    print ("An error occurred when trying to install zc.buildout. "\n-           "Look above this message for any errors that "\n-           "were output by easy_install.")\n-    sys.exit(exitcode)\n-\n-ws.add_entry(eggs_dir)\n+import subprocess\n+if subprocess.call(cmd, env=dict(os.environ, PYTHONPATH=setuptools_path)) != 0:\n+    raise Exception(\n+        "Failed to execute command:\\n%s",\n+        repr(cmd)[1:-1])\n+\n+######################################################################\n+# Import and run buildout\n+# installing setuptools imported site.py, which added zc.buildout to the WorkingSet if it was previously installed\n+# this may raise a VerionConflict here; we just need to resolve the location of the buildout we just installed\n+# so we clear the WorkingSet\n+_cleanup_old_zc_buildout_modules()\n+ws.by_key = {}\n+ws.add_entry(tmpeggs)\n ws.require(requirement)\n import zc.buildout.buildout\n-if orig_args:\n-    # run buildout with commands passed to bootstrap.py, then actually bootstrap\n-    zc.buildout.buildout.main(args + orig_args)\n-zc.buildout.buildout.main(args + [\'bootstrap\'])\n-if not options.eggs:  # clean up temporary egg directory\n-    shutil.rmtree(eggs_dir)\n+\n+if not [a for a in args if \'=\' not in a]:\n+    args.append(\'bootstrap\')\n+\n+# if -c was provided, we push it back into args for buildout\' main function\n+if options.config_file is not None:\n+    args[0:0] = [\'-c\', options.config_file]\n+\n+zc.buildout.buildout.main(args)\n+shutil.rmtree(tmpeggs)\ndiff --git a/buildout.cfg b/buildout.cfg\nindex 81337fc..63c5290 100644\n--- a/buildout.cfg\n+++ b/buildout.cfg\n@@ -10,7 +10,7 @@ parts =\n [project]\n name = infi.memuse\n namespace_packages = []\n-install_requires = [\'distribute\', \'infi.pyutils\', \'psutil\']\n+install_requires = [\'distribute\', \'infi.pyutils\', \'psutil==1.0.1\']\n version_file = src/infi/memuse/__version__.py\n description = short description here\n long_description = long description here\n'