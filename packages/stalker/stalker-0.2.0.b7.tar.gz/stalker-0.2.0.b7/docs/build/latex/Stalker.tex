% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\setcounter{tocdepth}{3}

\title{Stalker Documentation}
\date{June 07, 2013}
\release{0.2.0.b7}
\author{Erkan Ozgur Yilmaz}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{contents::doc}



\chapter{About}
\label{about::doc}\label{about:about}\label{about:table-of-contents}\label{about:contents}
Stalker is an Open Source Production Asset Management (ProdAM) System designed
specifically for Animation and VFX Studios but can be used for any kind of
projects. Stalker is licensed under LGPL v2.1.
\begin{description}
\item[{Features:}] \leavevmode\begin{itemize}
\item {} 
Designed for animation and VFX Studios.

\item {} 
It is a Pyramid Web Application and also SOM (Stalker Object Model) API can
be used as a Python library.

\item {} 
Platform independent.

\item {} 
Default installation handles nearly all the asset and project management
needs of an animation and vfx studio.

\item {} 
Customizable with configuration scripts.

\item {} 
Customizable object model (Stalker Object Model - SOM).

\item {} 
Uses TaskJuggler as the project planing and tracking backend.

\item {} 
Can be used with any kind of databases supported by SQLAlchemy.

\item {} 
Can be connected to all the major 3d animation packages like Maya, Houdini,
Nuke, XSI, Vue, Blender etc. and any application that has a Python API.

\item {} 
Can work as a stand-alone application.

\end{itemize}

\item[{Stalker is build over these other OpenSource projects:}] \leavevmode\begin{itemize}
\item {} 
Python

\item {} 
Pyramid

\item {} 
SQLAlchemy and Alembic

\item {} 
Jinja2

\item {} 
TaskJuggler

\end{itemize}

\end{description}


\section{Source}
\label{about:source}
The latest development version is available in \href{http://code.google.com/p/stalker/}{Google Project page of
Stalker} or can be directly cloned with the following command if you already
have mercurial installed:

\begin{Verbatim}[commandchars=\\\{\}]
hg clone https://stalker.googlecode.com/hg/ stalker
\end{Verbatim}


\chapter{Installation}
\label{installation:installation-toplevel}\label{installation:google-project-page-of-stalker}\label{installation::doc}\label{installation:installation}

\section{How to Install Stalker}
\label{installation:how-to-install-stalker}
This document will help you install and run Stalker.


\section{Install Python}
\label{installation:install-python}
Stalker is completely written with Python, so it requires Python. It currently
works with Python version 2.6 and 2.7. So you first need to have Python
installed in your system. On Linux and OSX there is a system wide Python
already installed. For Windows, you need to download the Python installer
suitable for your Windows operating system (32 or 64 bit) from \href{http://www.python.org/}{Python.org}


\section{Install Stalker}
\label{installation:python-org}\label{installation:install-stalker}
The easiest way to install the latest version of Stalker along with all its
dependencies is to use the \emph{setuptools}. If your system doesn't have setuptools
(particularly Windows) you need to install \emph{setuptools} by using \emph{ez\_setup}
bootstrap script.


\subsection{Installing \emph{setuptools} with \emph{ez\_setup}:}
\label{installation:installing-setuptools-with-ez-setup}
These steps are generally needed just for Windows. Linux and OSX users can skip
this part.
\begin{enumerate}
\item {} 
download \href{http://peak.telecommunity.com/dist/ez\_setup.py}{ez\_setup.py}

\item {} 
run the following command in the command prompt/shell/terminal:

\begin{Verbatim}[commandchars=\\\{\}]
python ez\_setup
\end{Verbatim}

\end{enumerate}
\begin{quote}

It will install or build the \emph{setuptools} if there are no suitable installer
for your operating system.
\end{quote}


\subsection{Installing Stalker (All OSes):}
\label{installation:ez-setup-py}\label{installation:installing-stalker-all-oses}
After installing the \emph{setuptools} you can run the following command:

\begin{Verbatim}[commandchars=\\\{\}]
easy\_install -U stalker
\end{Verbatim}

Now you have installed Stalker along with all its dependencies.


\section{Checking the installation of Stalker}
\label{installation:checking-the-installation-of-stalker}
If everything went ok you should be able to import and check the version of
Stalker by using the Python prompt like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{stalker}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{stalker}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}version\PYGZus{}\PYGZus{}}
\PYG{g+go}{0.2.0.b6}
\end{Verbatim}


\section{For developers}
\label{installation:for-developers}
It is highly recommended to create a VirtualEnv specific for Stalker
development. So to setup a virtualenv for Stalker:

\begin{Verbatim}[commandchars=\\\{\}]
cd \textasciitilde{}/Documents/development
virtualenv --no-site-packages stalker
\end{Verbatim}

Then clone the repository (you need mercurial to do that):

\begin{Verbatim}[commandchars=\\\{\}]
cd stalker
hg clone https://stalker.googlecode.com/hg/ stalker
\end{Verbatim}

And then to setup the virtual environment for development:

\begin{Verbatim}[commandchars=\\\{\}]
cd stalker
../bin/python setup.py develop
\end{Verbatim}

This command should install any dependent package to the virtual environment.


\section{Installing a Database}
\label{installation:installing-a-database}
Stalker uses a database to store all the data. The only database backend that
doesn't require any extra installation is SQLite3. You can setup Stalker to run
with an SQLite3 database. But it is much suitable to have a dedicated database
server in your studio. And it is recommended to use the same kind of database
backend both in development and production to reduce any compatibility problems
and any migration headaches.

See the \href{http://www.sqlalchemy.org/docs/core/engines.html\#supported-dbapis}{SQLAlchemy documentation} for supported databases.


\chapter{API Tutorial}
\label{tutorial::doc}\label{tutorial:api-tutorial}\label{tutorial:sqlalchemy-documentation}\label{tutorial:tutorial-toplevel}

\section{Introduction}
\label{tutorial:introduction}
Using Stalker along with Python is all about interacting with a database by
using the Stalker Object Model (SOM). Stalker uses the powerful \href{http://www.sqlalchemy.org/docs/orm/tutorial.html}{SQLAlchemy
ORM}.

This tutorial section let you familiarise with the Stalker Python API and
Stalker Object Model (SOM). If you used SQLAlchemy before you will feel at
home and if you aren't you will see that it is fun dealing with databases with
SOM.


\section{Part I - Basics}
\label{tutorial:part-i-basics}
Lets say that we just installed Stalker (as you are right now) and want to use
Stalker in our first project.

The first thing we are going to learn about is how to connect to the database
so we can enter information about our studio and the projects.

We are going to use a helper script to connect to the default database. Use the
following command to connect to the database:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{stalker} \PYG{k+kn}{import} \PYG{n}{db}
\PYG{n}{db}\PYG{o}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

This will create an in-memory SQLite3 database, which is useless other than
testing purposes. To be able to get more out of Stalker we should give a proper
database information. The most basic setup is to use a file based SQLite3
database:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{db}\PYG{o}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sqlalchemy.url}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sqlite:///C:}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s}{studio.db}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)} \PYG{c}{\PYGZsh{} assumed Windows}
\end{Verbatim}

or:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{db}\PYG{o}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sqlalchemy.url}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sqlite:////home/ozgur/studio.db}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)} \PYG{c}{\PYGZsh{} under linux or osx}
\end{Verbatim}

Lets continue by creating a \code{User} for ourselves in
the database. The first thing we need to do is to import the
\code{User} class in to the current namespace:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{stalker} \PYG{k+kn}{import} \PYG{n}{User}
\end{Verbatim}

then create the \code{User} object:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{myUser} \PYG{o}{=} \PYG{n}{User}\PYG{p}{(}
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Erkan Ozgur Yilmaz}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{login}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{eoyilmaz}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{email}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{eoyilmaz@gmail.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{password}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{secret}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{description}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{This is me}\PYG{l+s}{\PYGZdq{}}
\PYG{p}{)}
\end{Verbatim}

Our studio possibly has \textbf{Departments}. Lets add a new
\code{Department} object to define your
department:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{stalker} \PYG{k+kn}{import} \PYG{n}{Department}
\PYG{n}{tds\PYGZus{}department} \PYG{o}{=} \PYG{n}{Department}\PYG{p}{(}
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TDs}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{description}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{This is the TDs department}\PYG{l+s}{\PYGZdq{}}
\PYG{p}{)}
\end{Verbatim}

Now add your user to the department:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{tds\PYGZus{}department}\PYG{o}{.}\PYG{n}{members}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{myUser}\PYG{p}{)}
\end{Verbatim}

or:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{myUser}\PYG{o}{.}\PYG{n}{department} \PYG{o}{=} \PYG{n}{tds\PYGZus{}department}
\end{Verbatim}

We have created successfully a \code{User} and a
\code{Department} and we assigned the user as one
of the member of the \textbf{TDs Department}.

For now, because we didn't tell Stalker to commit the changes, no data has been
saved to the database yet. So lets send it the data to the database:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{db}\PYG{o}{.}\PYG{n}{session}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{myUser}\PYG{p}{)}
\PYG{n}{db}\PYG{o}{.}\PYG{n}{session}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{tds\PYGZus{}department}\PYG{p}{)}
\PYG{n}{db}\PYG{o}{.}\PYG{n}{session}\PYG{o}{.}\PYG{n}{commit}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

These information are in the database right now. Lets show this by querying all
the departments, then getting the second one (the first department is always
the ``admins'' which is created by default) and getting its first members name:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{all\PYGZus{}departments} \PYG{o}{=} \PYG{n}{Department}\PYG{o}{.}\PYG{n}{query}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{all\PYGZus{}members} \PYG{o}{=} \PYG{n}{all\PYGZus{}departments}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{members}
\PYG{k}{print} \PYG{n}{all\PYGZus{}members}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{name}
\end{Verbatim}

this should print out ``Erkan Ozgur Yilmaz''.


\section{Part II/A - Creating Simple Data}
\label{tutorial:part-ii-a-creating-simple-data}
Lets say that we have this new commercial project coming and you want to start
using Stalker with it. So we need to create a
\code{Project} object to hold data about it.

A project instance needs to have a suitable
\code{StatusList}
(see \emph{status\_and\_status\_lists\_toplevel}) and it needs to be attached to a
\code{Repository} instance:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} lets create a couple of generic Statuses}
\PYG{k+kn}{from} \PYG{n+nn}{stalker} \PYG{k+kn}{import} \PYG{n}{Status}

\PYG{n}{status\PYGZus{}waiting} \PYG{o}{=} \PYG{n}{Status}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Waiting To Start}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{code}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{WTS}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{status\PYGZus{}wip} \PYG{o}{=} \PYG{n}{Status}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Work in Progress}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{code}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{WIP}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{status\PYGZus{}pendrev} \PYG{o}{=} \PYG{n}{Status}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Pending Review}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{code}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{PREV}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{status\PYGZus{}approved} \PYG{o}{=} \PYG{n}{Status}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Approved}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{code}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{APP}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{status\PYGZus{}complete} \PYG{o}{=} \PYG{n}{Status}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Complete}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{code}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CMPLT}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{status\PYGZus{}stopped} \PYG{o}{=} \PYG{n}{Status}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Stopped}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{code}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{STOP}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

For now we have just created generic statuses. These
\code{Status} instances can be used with any kind of
objects. The idea behind is to define the statuses only once, and use them in
mixtures suitable for different type of object. So you can define all the
possible Statuses for your entities, then you can create a list of them for
specific type of objects (Assets, Projects, Shots etc.).

Lets create a \code{StatusList} suitable for
\code{Project} instances:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} a status list which is suitable for Project instances}
\PYG{k+kn}{from} \PYG{n+nn}{stalker} \PYG{k+kn}{import} \PYG{n}{StatusList}\PYG{p}{,} \PYG{n}{Project}

\PYG{n}{project\PYGZus{}statuses} \PYG{o}{=} \PYG{n}{StatusList}\PYG{p}{(}
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Project Status List}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{statuses}\PYG{o}{=}\PYG{p}{[}\PYG{n}{status\PYGZus{}waiting}\PYG{p}{,}
              \PYG{n}{status\PYGZus{}wip}\PYG{p}{,}
              \PYG{n}{status\PYGZus{}stopped}\PYG{p}{,}
              \PYG{n}{status\PYGZus{}complete}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{target\PYGZus{}entity\PYGZus{}type}\PYG{o}{=}\PYG{n}{Project}
\PYG{p}{)}
\end{Verbatim}

So we defined a status list which is suitable for Project instances. As you
see we didn't used all the generic Statuses in our \code{project\_statuses} because
for a Project object we thought that these statuses are enough.

And finally, the \code{Repository}. The Repository
(or Repo if you like) is a path in our file server, where we place files and
which is visible to all the workstations/render farmers:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{stalker} \PYG{k+kn}{import} \PYG{n}{Repository}

\PYG{c}{\PYGZsh{} and the repository itself}
\PYG{n}{commercial\PYGZus{}repo} \PYG{o}{=} \PYG{n}{Repository}\PYG{p}{(}
  \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Commercial Repository}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{p}{)}
\end{Verbatim}

\code{Repository} class will be explained in
detail in upcoming sections.

So:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{new\PYGZus{}project} \PYG{o}{=} \PYG{n}{Project}\PYG{p}{(}
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Fancy Commercial}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{status\PYGZus{}list}\PYG{o}{=}\PYG{n}{project\PYGZus{}statuses}\PYG{p}{,}
    \PYG{n}{repository}\PYG{o}{=}\PYG{n}{commercial\PYGZus{}repo}\PYG{p}{,}
\PYG{p}{)}
\end{Verbatim}

So we have created our project now.

Lets enter more information about this new project:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{datetime}
\PYG{k+kn}{from} \PYG{n+nn}{stalker} \PYG{k+kn}{import} \PYG{n}{ImageFormat}

\PYG{n}{new\PYGZus{}project}\PYG{o}{.}\PYG{n}{description} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s}{The commercial is about this fancy product. The}
\PYG{l+s}{                             client want us to have a shiny look with their}
\PYG{l+s}{                             product bla bla bla...}\PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{n}{new\PYGZus{}project}\PYG{o}{.}\PYG{n}{image\PYGZus{}format} \PYG{o}{=} \PYG{n}{ImageFormat}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{HD 1080}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{width}\PYG{o}{=}\PYG{l+m+mi}{1920}\PYG{p}{,} \PYG{n}{height}\PYG{o}{=}\PYG{l+m+mi}{1080}\PYG{p}{)}
\PYG{n}{new\PYGZus{}project}\PYG{o}{.}\PYG{n}{fps} \PYG{o}{=} \PYG{l+m+mi}{25}
\PYG{n}{new\PYGZus{}project}\PYG{o}{.}\PYG{n}{end} \PYG{o}{=} \PYG{n}{datetime}\PYG{o}{.}\PYG{n}{date}\PYG{p}{(}\PYG{l+m+mi}{2011}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{)}
\PYG{n}{new\PYGZus{}project}\PYG{o}{.}\PYG{n}{lead} \PYG{o}{=} \PYG{n}{myUser}
\end{Verbatim}

Lets save all the new data to the database:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{db}\PYG{o}{.}\PYG{n}{session}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{new\PYGZus{}project}\PYG{p}{)}
\PYG{n}{db}\PYG{o}{.}\PYG{n}{session}\PYG{o}{.}\PYG{n}{commit}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

As you see, even though we have created multiple objects (new\_project,
statuses, status lists etc.) we've just added the \code{new\_project} object to the
database, but don't worry all the related objects will be added to the
database.

A Project generally contains \code{Sequence}s, so
lets create one, again we need to create a status list suitable for sequences
and a sequence should be initialized with a project instance:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{stalker} \PYG{k+kn}{import} \PYG{n}{Sequence}

\PYG{n}{seq\PYGZus{}statuses} \PYG{o}{=} \PYG{n}{StatusList}\PYG{p}{(}
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sequence Status List}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{statuses}\PYG{o}{=}\PYG{p}{[}\PYG{n}{status\PYGZus{}waiting}\PYG{p}{,}
              \PYG{n}{status\PYGZus{}wip}\PYG{p}{,}
              \PYG{n}{status\PYGZus{}stopped}\PYG{p}{,}
              \PYG{n}{status\PYGZus{}complete}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{target\PYGZus{}entity\PYGZus{}type}\PYG{o}{=}\PYG{n}{Sequence}\PYG{p}{,}
\PYG{p}{)}

\PYG{n}{seq1} \PYG{o}{=} \PYG{n}{Sequence}\PYG{p}{(}
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sequence 1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{code}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SEQ1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{status\PYGZus{}list} \PYG{o}{=} \PYG{n}{seq\PYGZus{}statuses}\PYG{p}{,}
    \PYG{n}{project}\PYG{o}{=}\PYG{n}{new\PYGZus{}project}\PYG{p}{,}
\PYG{p}{)}
\end{Verbatim}

And a Sequence generally has \code{Shot}s:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{stalker} \PYG{k+kn}{import} \PYG{n}{Shot}

\PYG{n}{shot\PYGZus{}statuses} \PYG{o}{=} \PYG{n}{StatusList}\PYG{p}{(}
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Shot Status List}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{statuses}\PYG{o}{=}\PYG{p}{[}\PYG{n}{status\PYGZus{}waiting}\PYG{p}{,}
              \PYG{n}{status\PYGZus{}wip}\PYG{p}{,}
              \PYG{n}{status\PYGZus{}stopped}\PYG{p}{,}
              \PYG{n}{status\PYGZus{}pendrev}\PYG{p}{,}
              \PYG{n}{status\PYGZus{}approved}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{target\PYGZus{}entity\PYGZus{}type}\PYG{o}{=}\PYG{n}{Shot}\PYG{p}{,}
\PYG{p}{)}

\PYG{n}{sh001} \PYG{o}{=} \PYG{n}{Shot}\PYG{p}{(}\PYG{n}{code}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SH001}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{sequence}\PYG{o}{=}\PYG{n}{seq1}\PYG{p}{,} \PYG{n}{status\PYGZus{}list}\PYG{o}{=}\PYG{n}{shot\PYGZus{}statuses}\PYG{p}{)}
\PYG{n}{sh002} \PYG{o}{=} \PYG{n}{Shot}\PYG{p}{(}\PYG{n}{code}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SH002}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{sequence}\PYG{o}{=}\PYG{n}{seq1}\PYG{p}{,} \PYG{n}{status\PYGZus{}list}\PYG{o}{=}\PYG{n}{shot\PYGZus{}statuses}\PYG{p}{)}
\PYG{n}{sh003} \PYG{o}{=} \PYG{n}{Shot}\PYG{p}{(}\PYG{n}{code}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SH003}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{sequence}\PYG{o}{=}\PYG{n}{seq1}\PYG{p}{,} \PYG{n}{status\PYGZus{}list}\PYG{o}{=}\PYG{n}{shot\PYGZus{}statuses}\PYG{p}{)}
\end{Verbatim}

send them to the database:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{db}\PYG{o}{.}\PYG{n}{session}\PYG{o}{.}\PYG{n}{add\PYGZus{}all}\PYG{p}{(}\PYG{p}{[}\PYG{n}{sh001}\PYG{p}{,} \PYG{n}{sh002}\PYG{p}{,} \PYG{n}{sh003}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{db}\PYG{o}{.}\PYG{n}{session}\PYG{o}{.}\PYG{n}{commit}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{Part II/B - Querying, Updating and Deleting Data}
\label{tutorial:part-ii-b-querying-updating-and-deleting-data}
So far we just created some simple data. What about updating them. Let say that
we created a new shot with wrong info:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{sh004} \PYG{o}{=} \PYG{n}{Shot}\PYG{p}{(}\PYG{n}{code}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SH005}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{sequence}\PYG{o}{=}\PYG{n}{seq1}\PYG{p}{,} \PYG{n}{status\PYGZus{}list}\PYG{o}{=}\PYG{n}{shot\PYGZus{}statuses}\PYG{p}{)}
\PYG{n}{db}\PYG{o}{.}\PYG{n}{session}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{sh004}\PYG{p}{)}
\PYG{n}{db}\PYG{o}{.}\PYG{n}{session}\PYG{o}{.}\PYG{n}{commit}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

and you figured out that you have created and committed a wrong info and you
want to correct it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{sh004}\PYG{o}{.}\PYG{n}{code} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SH004}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{db}\PYG{o}{.}\PYG{n}{session}\PYG{o}{.}\PYG{n}{commit}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

but lets say that you don't have any variable holding the shot alread:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} first find the data}
\PYG{n}{wrong\PYGZus{}shot} \PYG{o}{=} \PYG{n}{db}\PYG{o}{.}\PYG{n}{query}\PYG{p}{(}\PYG{n}{Shot}\PYG{p}{)}\PYG{o}{.}\PYG{n}{filter\PYGZus{}by}\PYG{p}{(}\PYG{n}{code}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SH005}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{first}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} now update it}
\PYG{n}{wrong\PYGZus{}shot}\PYG{o}{.}\PYG{n}{code} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SH004}\PYG{l+s}{\PYGZdq{}}

\PYG{c}{\PYGZsh{} commit the changes to the database}
\PYG{n}{db}\PYG{o}{.}\PYG{n}{session}\PYG{o}{.}\PYG{n}{commit}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

and let say that you decided to delete the data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{db}\PYG{o}{.}\PYG{n}{session}\PYG{o}{.}\PYG{n}{delete}\PYG{p}{(}\PYG{n}{wrong\PYGZus{}shot}\PYG{p}{)}
\PYG{n}{db}\PYG{o}{.}\PYG{n}{session}\PYG{o}{.}\PYG{n}{commit}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

for more info about update and delete options (like cascades) in SQLAlchemy
please see the \href{http://www.sqlalchemy.org/docs/orm/session.html}{SQLAlchemy documentation}.


\section{Part III - Pipeline}
\label{tutorial:part-iii-pipeline}\label{tutorial:sqlalchemy-documentation}
Up until now, we skipped a lot of stuff here to take little steps every time.
Eventough we have created users, departments, projects, sequences and shots,
Stalker still doesn't know much about our studio. For example, it doesn't have
any information about the \textbf{pipeline} that we are following and what steps we
do to complete those shots, thus to complete the project.

In Stalker, pipeline is managed by \code{Task}s. So
you create Tasks for Shots and then you can create dependencies between tasks.

So lets create a couple of tasks for one of the shots we have created before:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{stalker} \PYG{k+kn}{import} \PYG{n}{Task}

\PYG{n}{task\PYGZus{}statuses} \PYG{o}{=} \PYG{n}{StatusList}\PYG{p}{(}
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Task Status List}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{statuses}\PYG{o}{=}\PYG{p}{[}\PYG{n}{status\PYGZus{}waiting}\PYG{p}{,}
              \PYG{n}{status\PYGZus{}wip}\PYG{p}{,}
              \PYG{n}{status\PYGZus{}pendrev}\PYG{p}{,}
              \PYG{n}{status\PYGZus{}approved}\PYG{p}{,}
              \PYG{n}{status\PYGZus{}complete}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{target\PYGZus{}entity\PYGZus{}type}\PYG{o}{=}\PYG{n}{Task}
\PYG{p}{)}

\PYG{n}{previs} \PYG{o}{=} \PYG{n}{Task}\PYG{p}{(}
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Previs of SH001}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{status\PYGZus{}list}\PYG{o}{=}\PYG{n}{task\PYGZus{}statuses}\PYG{p}{,}
    \PYG{n}{task\PYGZus{}of}\PYG{o}{=}\PYG{n}{sh001}
\PYG{p}{)}

\PYG{n}{matchmove} \PYG{o}{=} \PYG{n}{Task}\PYG{p}{(}
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Matchmove of SH001}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{status\PYGZus{}list}\PYG{o}{=}\PYG{n}{task\PYGZus{}statuses}\PYG{p}{,}
    \PYG{n}{task\PYGZus{}of}\PYG{o}{=}\PYG{n}{sh001}
\PYG{p}{)}

\PYG{n}{anim} \PYG{o}{=} \PYG{n}{Task}\PYG{p}{(}
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Animation}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{status\PYGZus{}list}\PYG{o}{=}\PYG{n}{task\PYGZus{}statuses}\PYG{p}{,}
    \PYG{n}{task\PYGZus{}of}\PYG{o}{=}\PYG{n}{sh001}
\PYG{p}{)}

\PYG{n}{lighting} \PYG{o}{=} \PYG{n}{Task}\PYG{p}{(}
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Lighting}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{status\PYGZus{}list}\PYG{o}{=}\PYG{n}{task\PYGZus{}statuses}\PYG{p}{,}
    \PYG{n}{task\PYGZus{}of}\PYG{o}{=}\PYG{n}{sh001}
\PYG{p}{)}

\PYG{n}{compositing} \PYG{o}{=} \PYG{n}{Task}\PYG{p}{(}
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Compositing}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{status\PYGZus{}list}\PYG{o}{=}\PYG{n}{task\PYGZus{}statuses}\PYG{p}{,}
    \PYG{n}{task\PYGZus{}of}\PYG{o}{=}\PYG{n}{sh001}
\PYG{p}{)}
\end{Verbatim}

Now create the dependecies:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{compositing}\PYG{o}{.}\PYG{n}{depends} \PYG{o}{=} \PYG{p}{[}\PYG{n}{lighting}\PYG{p}{]}
\PYG{n}{lighting}\PYG{o}{.}\PYG{n}{depends} \PYG{o}{=} \PYG{p}{[}\PYG{n}{anim}\PYG{p}{]}
\PYG{n}{anim}\PYG{o}{.}\PYG{n}{depends} \PYG{o}{=} \PYG{p}{[}\PYG{n}{previs}\PYG{p}{,} \PYG{n}{matchmove}\PYG{p}{]}
\end{Verbatim}

For now the dependencies are only useful to have an information about the
relation of the tasks, but in the future releases of Stalker it is also going
to be used in the planned Project Scheduler.


\section{Part IV - Task \& Resource Management}
\label{tutorial:part-iv-task-resource-management}
Now we have a couple of Shots with couple of tasks inside it but we didn't
assign the tasks to anybody to let them finish this job.

Lets assign all this stuff to our self (for now :) ):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{previs}\PYG{o}{.}\PYG{n}{resources} \PYG{o}{=} \PYG{p}{[}\PYG{n}{myUser}\PYG{p}{]}
\PYG{n}{previs}\PYG{o}{.}\PYG{n}{effort} \PYG{o}{=} \PYG{n}{timedelta}\PYG{p}{(}\PYG{n}{days}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{matchmove}\PYG{o}{.}\PYG{n}{resources} \PYG{o}{=} \PYG{p}{[}\PYG{n}{myUser}\PYG{p}{]}
\PYG{n}{matchmove}\PYG{o}{.}\PYG{n}{effort} \PYG{o}{=} \PYG{n}{timedelta}\PYG{p}{(}\PYG{n}{days}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{anim}\PYG{o}{.}\PYG{n}{resources} \PYG{o}{=} \PYG{p}{[}\PYG{n}{myUser}\PYG{p}{]}
\PYG{n}{anim}\PYG{o}{.}\PYG{n}{effort} \PYG{o}{=} \PYG{n}{timedelta}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c}{\PYGZsh{} the default argument is days in timedelta}

\PYG{n}{lighting}\PYG{o}{.}\PYG{n}{resources} \PYG{o}{=} \PYG{p}{[}\PYG{n}{myUser}\PYG{p}{]}
\PYG{n}{lighting}\PYG{o}{.}\PYG{n}{effort} \PYG{o}{=} \PYG{n}{timdelta}\PYG{p}{(}\PYG{n}{hours}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c}{\PYGZsh{} one another way is to add the task to the users tasks}
\PYG{c}{\PYGZsh{} it will have the same effect of assign a user to a task}
\PYG{n}{myUser}\PYG{o}{.}\PYG{n}{tasks}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{comp}\PYG{p}{)}
\PYG{n}{comp}\PYG{o}{.}\PYG{n}{effort} \PYG{o}{=} \PYG{n}{timedelta}\PYG{p}{(}\PYG{n}{days}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{Verbatim}

Now Stalker knows the hierarchy of the tasks. Next versions of Stalker will
have a \code{Project Scheduler} included to solve the task timings and create data
for things like Gantt Charts.

Lets commit the changes again:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{session}\PYG{o}{.}\PYG{n}{commit}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

If you noticed, this time we didn't add anything to the session, cause we have
added the \code{sh001} in a previous commit, and because all the objects are
attached to this shot object in some way, all the changes has been tracked and
added to the database.


\section{Part V - Asset Management}
\label{tutorial:part-v-asset-management}
Now we have created a lot of things but other then storing all the data in the
database, we didn't do much. Stalker still doesn't have information about a lot
of things. For example, it doesn't know how to handle your asset versions
(\code{Version}) namely it doesn't know how to store
your data that you are going to create while completing this tasks.

So what we need to define is a place in our file structure. It doesn't need to
be a network shared directory but if you are not working alone than it means
that everyone needs to reach your data and the simplest way to do this is to
place your files in a network share or a SAN storage, there are other
alternatives like storing your files locally and sharing your revisions with a
Software Configuration Management (SCM) system. We are going to see the first
alternative, which uses a network share in our fileserver, and this network
share is called a \code{Reposiory} in Stalker.

A repository is a file path, preferably a path which is mapped or mounted to
the same path on every computer in our studio. You can have several
repositories let say one for Commercials and another one for big Movie
projects. You can define repositories and assign projects to those
repositories. We have already created a repository while creating our first
project. But the repository has missing informations. A Repository object shows
the path that we create our projects into. Lets enter the paths for all the
major operating systems:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{commercial\PYGZus{}repo}\PYG{o}{.}\PYG{n}{windows\PYGZus{}path} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{M:/PROJECTS}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{commercial\PYGZus{}repo}\PYG{o}{.}\PYG{n}{linux\PYGZus{}path}   \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/mnt/M/PROJECTS}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{commercial\PYGZus{}repo}\PYG{o}{.}\PYG{n}{osx\PYGZus{}path}     \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Volumes/M/PROJECTS}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}

And if you ask for the path to a repository object it will always give the
correct answer according to your operating system:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{repo1}\PYG{o}{.}\PYG{n}{path}
\PYG{c}{\PYGZsh{} under Windows outputs:}
\PYG{c}{\PYGZsh{} M:/PROJECTS}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} in Linux and variants:}
\PYG{c}{\PYGZsh{} /mnt/M/PROJECTS}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} and in OSX:}
\PYG{c}{\PYGZsh{} /Volumes/M/PROJECTS}
\PYG{c}{\PYGZsh{}}
\end{Verbatim}

\begin{notice}{note}{Note:}
Stalker always uses forward slashes no matter what operating system you are
using.
\end{notice}

Assigning this repository to our project is not enough, Stalker still doesn't
know about the project \code{Structure}, or in
other words it doesn't have information about the folder structure about your
project. To explain the project structure we can use the
\code{Structure} object:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{stalker} \PYG{k+kn}{import} \PYG{n}{Structure}

\PYG{n}{commercial\PYGZus{}project\PYGZus{}structure} \PYG{o}{=} \PYG{n}{Structure}\PYG{p}{(}
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Commercial Projects Structure}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{description}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s}{This is a project structure, which can be used for simple}
\PYG{l+s}{        commercial projects}\PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{p}{)}

\PYG{c}{\PYGZsh{} lets create the folder structure as a Jinja2 template}
\PYG{n}{custom\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s}{   \PYGZob{}\PYGZob{} project.code \PYGZcb{}\PYGZcb{}}
\PYG{l+s}{   \PYGZob{}\PYGZob{} project.code \PYGZcb{}\PYGZcb{}/Assets}
\PYG{l+s}{   \PYGZob{}\PYGZob{} project.code \PYGZcb{}\PYGZcb{}/References/Storyboard}
\PYG{l+s}{   \PYGZob{}\PYGZob{} project.code \PYGZcb{}\PYGZcb{}/References/Videos}
\PYG{l+s}{   \PYGZob{}\PYGZob{} project.code \PYGZcb{}\PYGZcb{}/References/Images}
\PYG{l+s}{   \PYGZob{}\PYGZob{} project.code \PYGZcb{}\PYGZcb{}/Sequences}\PYG{l+s}{\PYGZdq{}}

\PYG{l+s}{   \PYGZob{}}\PYG{l+s+si}{\PYGZpc{} i}\PYG{l+s}{f project.sequences }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{\PYGZcb{}}
\PYG{l+s}{       \PYGZob{}}\PYG{l+s+si}{\PYGZpc{} f}\PYG{l+s}{or sequence in project.sequences }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{\PYGZcb{}}
\PYG{l+s}{           \PYGZob{}}\PYG{l+s+si}{\PYGZpc{} s}\PYG{l+s}{et seq\PYGZus{}path = project.code + }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/Sequences/}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ + sequence.code }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{\PYGZcb{}}
\PYG{l+s}{           \PYGZob{}\PYGZob{} seq\PYGZus{}path \PYGZcb{}\PYGZcb{}}
\PYG{l+s}{           \PYGZob{}\PYGZob{} seq\PYGZus{}path \PYGZcb{}\PYGZcb{}/Edit}
\PYG{l+s}{           \PYGZob{}\PYGZob{} seq\PYGZus{}path \PYGZcb{}\PYGZcb{}/Edit/AnimaticStoryboard}
\PYG{l+s}{           \PYGZob{}\PYGZob{} seq\PYGZus{}path \PYGZcb{}\PYGZcb{}/Edit/Export}
\PYG{l+s}{           \PYGZob{}\PYGZob{} seq\PYGZus{}path \PYGZcb{}\PYGZcb{}/Shots}

\PYG{l+s}{           \PYGZob{}}\PYG{l+s+si}{\PYGZpc{} i}\PYG{l+s}{f sequence.shots }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{\PYGZcb{}}
\PYG{l+s}{               \PYGZob{}}\PYG{l+s+si}{\PYGZpc{} f}\PYG{l+s}{or shot in sequence.shots }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{\PYGZcb{}}
\PYG{l+s}{                   \PYGZob{}}\PYG{l+s+si}{\PYGZpc{} s}\PYG{l+s}{et shot\PYGZus{}path = seq\PYGZus{}path + }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/SHOTS/}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ + shot.code }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{\PYGZcb{}}
\PYG{l+s}{                   \PYGZob{}\PYGZob{} shot\PYGZus{}path \PYGZcb{}\PYGZcb{}}
\PYG{l+s}{               \PYGZob{}}\PYG{l+s+si}{\PYGZpc{} e}\PYG{l+s}{ndfor }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{\PYGZcb{}}
\PYG{l+s}{           \PYGZob{}}\PYG{l+s+si}{\PYGZpc{} e}\PYG{l+s}{ndif }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{\PYGZcb{}}

\PYG{l+s}{       \PYGZob{}}\PYG{l+s+si}{\PYGZpc{} e}\PYG{l+s}{ndfor }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{\PYGZcb{}}

\PYG{l+s}{   \PYGZob{}}\PYG{l+s+si}{\PYGZpc{} e}\PYG{l+s}{ndif }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{\PYGZcb{}}

\PYG{l+s}{   \PYGZob{}\PYGZob{} project.code \PYGZcb{}\PYGZcb{}/References}
\PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{n}{commercial\PYGZus{}project\PYGZus{}structure}\PYG{o}{.}\PYG{n}{custom\PYGZus{}template} \PYG{o}{=} \PYG{n}{custom\PYGZus{}template}

\PYG{c}{\PYGZsh{} now assign this structure to our project}
\PYG{n}{new\PYGZus{}project}\PYG{o}{.}\PYG{n}{structure} \PYG{o}{=} \PYG{n}{commercial\PYGZus{}project\PYGZus{}structure}
\end{Verbatim}

Now we have entered a couple of \href{http://jinja.pocoo.org/}{Jinja2} directives as a string. This template
will be used when creating the project structure.

The above template will produce the following folders for our project:

\begin{Verbatim}[commandchars=\\\{\}]
M:/PROJECTS/FANCY\_COMMERCIAL
M:/PROJECTS/FANCY\_COMMERCIAL/Assets
M:/PROJECTS/FANCY\_COMMERCIAL/References
M:/PROJECTS/FANCY\_COMMERCIAL/References/Videos
M:/PROJECTS/FANCY\_COMMERCIAL/References/Images
M:/PROJECTS/FANCY\_COMMERCIAL/Sequences
M:/PROJECTS/FANCY\_COMMERCIAL/Sequences/SEQ1
M:/PROJECTS/FANCY\_COMMERCIAL/Sequences/SEQ1/Edit
M:/PROJECTS/FANCY\_COMMERCIAL/Sequences/SEQ1/Edit/AnimaticStoryboard
M:/PROJECTS/FANCY\_COMMERCIAL/Sequences/SEQ1/Edit/Export
M:/PROJECTS/FANCY\_COMMERCIAL/Sequences/SEQ1/Storyboard
M:/PROJECTS/FANCY\_COMMERCIAL/Sequences/SEQ1/Shots
M:/PROJECTS/FANCY\_COMMERCIAL/Sequences/SEQ1/Shots/SH001
M:/PROJECTS/FANCY\_COMMERCIAL/Sequences/SEQ1/Shots/SH002
M:/PROJECTS/FANCY\_COMMERCIAL/Sequences/SEQ1/Shots/SH003
\end{Verbatim}

We are still not done with defining the templates. Even though Stalker now
knows what is the project structure like, it is not aware of the placements of
individual \code{Version} files specific for a Task.
A \code{Version} is an object holding information
about every single iteration of one Task and has a connection to files in the
repository.

So before creating a new version for any kind of task, we need to tell Stalker
where to place the related files. This can be done by using a
\code{FilenameTemplate} object.

A \code{FilenameTemplate} object has information
about the path, the filename, and the target entity type to apply this template
to:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{stalker} \PYG{k+kn}{import} \PYG{n}{FilenameTemplate}

\PYG{n}{shot\PYGZus{}version\PYGZus{}template} \PYG{o}{=} \PYG{n}{FilenameTemplate}\PYG{p}{(}
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Shot Template}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{target\PYGZus{}entity\PYGZus{}type}\PYG{o}{=}\PYG{n}{Shot}
\PYG{p}{)}

\PYG{c}{\PYGZsh{} lets create the templates}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} task = version.task}
\PYG{c}{\PYGZsh{} shot = task.part\PYGZus{}of}
\PYG{c}{\PYGZsh{} asset = task.part\PYGZus{}of}
\PYG{c}{\PYGZsh{} try:}
\PYG{c}{\PYGZsh{}     sequence = shot.sequence}
\PYG{c}{\PYGZsh{} except AttributeError:}
\PYG{c}{\PYGZsh{}     sequence = asset.sequences[0]}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} task\PYGZus{}type = task.type}
\PYG{c}{\PYGZsh{} user = auth.get\PYGZus{}user()}
\PYG{c}{\PYGZsh{}}

\PYG{n}{path\PYGZus{}code} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sequences/\PYGZob{}\PYGZob{} sequence.code \PYGZcb{}\PYGZcb{}/Shots/\PYGZob{}\PYGZob{} shot.code \PYGZcb{}\PYGZcb{}/\PYGZob{}\PYGZob{} task\PYGZus{}type.code \PYGZcb{}\PYGZcb{}}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{filename\PYGZus{}code} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZob{}\PYGZob{} shot.code \PYGZcb{}\PYGZcb{}\PYGZus{}\PYGZob{}\PYGZob{} version.take \PYGZcb{}\PYGZcb{}\PYGZus{}\PYGZob{}\PYGZob{} task\PYGZus{}type.code \PYGZcb{}\PYGZcb{}\PYGZus{}v\PYGZob{}\PYGZob{} version.version \PYGZcb{}\PYGZcb{}}\PYG{l+s}{\PYGZdq{}}

\PYG{n}{shot\PYGZus{}version\PYGZus{}template}\PYG{o}{.}\PYG{n}{path\PYGZus{}code} \PYG{o}{=} \PYG{n}{path\PYGZus{}code}
\PYG{n}{shot\PYGZus{}version\PYGZus{}template}\PYG{o}{.}\PYG{n}{filename\PYGZus{}code} \PYG{o}{=} \PYG{n}{filename\PYGZus{}code}

\PYG{c}{\PYGZsh{} now assign this template to our project structure}
\PYG{c}{\PYGZsh{} do you save the \PYGZdq{}structure1\PYGZdq{} we have created before}
\PYG{n}{commercial\PYGZus{}project\PYGZus{}structure}\PYG{o}{.}\PYG{n}{templates}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{shot\PYGZus{}version\PYGZus{}template}\PYG{p}{)}
\end{Verbatim}

Now Stalker knows ``Kung-Fu''. It can place any version related file to the
repository and organise your works. You can define all the templates for all
your entities independently.


\section{Part VI - Collaboration (coming)}
\label{tutorial:part-vi-collaboration-coming}
We came a lot from the start, but what is the use of an Production Asset
Management System if we can not communicate with our colleagues.

In Stalker you can communicate with others in the system, by:
\begin{itemize}
\item {} 
Leaving a \code{Note} to anything created in
Stalker (except to notes and tags, you can not create a note to a note and
to a tag)

\item {} 
Sending a \code{Message} directly to them or
to a group of users

\item {} 
Anyone can create \code{Ticket}s to a
\code{Version}

\end{itemize}


\section{Part VII - Session Management (coming)}
\label{tutorial:part-vii-session-management-coming}
This part will be covered soon


\section{Part VIII - Extending SOM (coming)}
\label{tutorial:part-viii-extending-som-coming}
This part will be covered soon


\chapter{Design}
\label{design:design}\label{design::doc}\label{design:design-toplevel}
The design of Stalker is mentioned in the following sections.


\section{Introduction}
\label{design:introduction}
As you probably have got by now Stalker is an Open Source Production Asset
Management System. Although it is designed VFX and Animation studios in mind,
its flexible Project Management muscles will allow it to be used in a wide
variety of fields.

An Asset Management Systems' duty is to hold the data which are created by the
users of the system in an organised manner, and let them quickly reach and find
their files. A Production Asset Management Systems' duty is, in addition to the
asset management systems', also handle the production steps or tasks and
allow the users of the system to collaborate. If more information about this
subject is needed, there are great books about Digital Asset Management (DAM)
Systems.

The usage of an asset management system in an animation/vfx studio is an
obligatory duty for the sake of the studio itself. Even the benefits of the
system becomes silly to be mentioned when compared to the lack of even a simple
system to organise stuff.

Every studio outside establishes and develops their own asset management
system. Stalker will try to be the framework that these proprietary asset
management systems will be build over. Thus reducing the work repeated on every
big projects' start.


\section{Concepts}
\label{design:concepts}
There are a couple of design concepts those needs to be clarified before any
further explanation of Stalker.


\subsection{Stalker Object Model (SOM)}
\label{design:stalker-object-model-som}
Stalker has a very robust object model, which is called
\textbf{Stalker Object Model} or \textbf{SOM}. The idea behind SOM is to create a simple
class hierarchy which is both usable right out of the box and also expandable
by the studios' pipeline TDs. SOM is actually a little bit more complex than
the basic possible model, it is designed in this way just to be able to create
a simple pipeline to be able to build the system on it.

Lets look at how a simple studio works and try to create our asset management
concepts around it.

An animation/vfx studios duty is to complete a
\code{Project}. A project, generally is about to
create a \code{Sequence} of
\code{Shot}s which are a series of images those at the
end converts to a movie. So a sequence in general contains Shots. And Shots can
use \code{Asset}s. So basically to complete a
project the studio should complete the shots and assets needed by those shots.

Furthermore all the Projects, Sequences, Shots or Assets are splitted in to
different \code{Task}s those need to be done
sequentially or in parallel to complete that project.

A Task relates to a work, a work is a quantity of time spend or going to be
spend for that specific task. The time spend on the course of completion of a
Task can be recorded with \code{TimeLog}s. TimeLogs
shows the time of an artist has spent for a certain Task. So it holds
information about how much \textbf{effort} has been spent to complete a Task.

During the completion of the Task or at the end of the work a \textbf{User} creates
\code{Versions} for that particular Task. Versions
are the different incarnations or the progress of the resultant product, and it
is connected to files in the fileserver or in Stalkers term the
\code{Repository}.

All the names those shown in bold fonts are a class in SOM. and there are a
series of other classes to accommodate the needs of a
\code{Studio}.

The inheritance diagram of the classes in the SOM is shown below:


\section{Inheritance Diagram}
\label{design:inheritance-diagram-toplevel}\label{design:inheritance-diagram}
Stalker is a configurable and expandable system. Both of these feature allows
the system to have a flexible structure.

There are two levels of expansion, the first level is the simplest one, by just
adding different statuses, different types or these kind of things in
which Stalker's current design is ready to. This is explained in {\hyperref[design:how-to-customize-stalker]{How To
Customize Stalker}}

The second level of expansion is achieved by expanding the SOM. Expanding the
SOM includes creating new classes and database tables, and updating the old
ones which are already coming with Stalker. These expansion schemes are
further explained in {\hyperref[design:how-to-extend-som]{How To Extend SOM}}.


\subsection{Features and Requirements}
\label{design:features-and-requirements}
Features:
\begin{enumerate}
\item {} 
Developed purely in Python (2.6 and over) using TDD (Test Driven
Development) practices

\item {} 
SQLAlchemy for the database back-end and ORM

\item {} 
PyQt/PySide and Pyramid based web interfaces. All the interfaces designed
in MVC structure.

\item {} 
Jinja2 as the template engine

\item {} 
Users are able to select their preferred database like PostgreSQL, MySQL,
Oracle, SQLite etc. (whatever SQLAlchemy supports)

\item {} 
It is possible to use both one or different databases for studio specific
and project specific data. It is mostly beneficial when the setup uses
SQLite. The project specific data could be kept in project folder as an
SQLite db file and the studio specific data can be another SQLite db file
or another database connection to PostgreSQL, MySQL, Oracle etc. databases.
In an SQLite setup, the database can be backed up with the project folder
itself.

\item {} 
Uses Jinja2 as the template system for the file and folder naming
convention will be used like:

\{repository.path\}/\{project.name\}/assets/\{asset.name\}/\{pipelineStep.name\}/
\{asset.variation.name\}/\{asset.name\}\_\{asset.type.name\}\_v\{asset.version\}.\{
asset.fileFormat.extension\}

\item {} 
file and folders and file sequences can be uploaded to the server as
assets, and the server decides where to place the folder or file by using
the template system.

\item {} 
The event system gives full control for every CRUD (create/insert, read,
update, delete) by giving step like before insert, after insert
call-backs.

\item {} 
The messaging system allows the users collaborate efficiently.

\end{enumerate}

For usage exmaples see {\hyperref[tutorial:tutorial-toplevel]{\emph{API Tutorial}}}


\section{How To Customize Stalker}
\label{design:how-to-customize-stalker}
This part explains the customization of Stalker.


\section{How To Extend SOM}
\label{design:how-to-extend-som}
This part explains how to extend Stalker Object Model or SOM.


\chapter{How To Contribute}
\label{contribute:contribute-toplevel}\label{contribute::doc}\label{contribute:how-to-contribute}
Stalker started as an Open Source project with the expectation of
contributions. The soul of the open source is to share the knowledge and
contribute.
\begin{description}
\item[{These are the areas that you can contribute to:}] \leavevmode\begin{itemize}
\item {} 
Documentation

\item {} 
Testing the code

\item {} 
Writing the code

\item {} 
Creating user interface elements (graphics, icons etc.)

\end{itemize}

\end{description}


\section{Development Style}
\label{contribute:development-style}
Stalker is developed strictly by following \href{http://en.wikipedia.org/wiki/Test-driven\_development}{TDD} practices. So every
participant should follow TDD methodology. Skipping this steps is highly
prohibited. Every added code to the trunk should have a corresponding test and
the tests should be written before implementing a single line of code.

\href{http:http://en.wikipedia.org/wiki/Don\%27t\_repeat\_yourself}{DRY} is also another methodology that a participant should follow. So nothing
should be repeated. If something needs to be repeated, then it is a good sign
that this part needs to be in a special module, class or function.


\section{Testing}
\label{contribute:dry}\label{contribute:testing}
As stated above all the code written should have a corresponding test.

Adding new features should start with design sketches. These sketches could be
plain text files or mind maps or anything that can express the thing in you
mind. While writing down these sketches, it should be kept in mind that these
files also could be used to generate the documentation of the system. So
writing down the sketches as rest files inside the docs is something very
meaningful.

The design should be followed by the tests. And the test should be followed by
the implementation, and the implementation should be followed by tests again,
until you are confident about your code and it is rock solid. Then the
refactoring phase can start, and because you have enough tests that will keep
your code doing a certain thing, you can freely change your code, because you
know that you code will do the same thing if it passes all the tests.

The first tests written should always fail by having:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fail}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the test is not implemented yet}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

failures. This is something good to have. This will inform us that the test is
not written yet. After blocking all the tests and you are confident about the
tests are covering all the aspects of your design sketches, you can start
writing the tests.

Another very important note about the tests are the docstrings of the test
methods. You should explain what is this test method testing, and what you
expect as a result of the test. It

After finishing implementing the tests you can start adding the code that will
pass the tests.

The test framework of Stalker is unitTest and nose to help testing.

These python modules should be installed to test Stalker properly:
\begin{itemize}
\item {} 
Nose

\item {} 
Coverage

\end{itemize}

The coverage of the tests should be kept as close as possible to \%100.

There is a helper script in the root of the project, called \emph{doTests}. This is
a shell script for linux, which runs all the necessary tests and prints the
tests results and the coverage table.

\begin{notice}{note}{Note:}
From version 0.1.1 the use of Mocker library is discontinued. The tests are
done using real objects. It is done in this way cause the design of the
objects were changing too quickly, and it started to be a guess work to see
which of the tests are effected by this changes. So the Mocker is removed and
it will not be used in future releases.
\end{notice}


\section{Coding Style}
\label{contribute:coding-style}
For the general coding style every participant should strictly follow \href{http://www.python.org/dev/peps/pep-0008/}{PEP 8}
rules, and there are some extra rules as listed below:
\begin{itemize}
\item {} 
Class names should start with an upper-case letter, function and method
names should start with lower-case letter:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MyClass}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}the doc string of the class}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{pass}

    \PYG{k}{def} \PYG{n+nf}{my\PYGZus{}method}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{pass}
\end{Verbatim}

\item {} 
There should be 1 spaces before and after functions and class methods:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{StatusBase}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}The StatusBase class}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name}\PYG{p}{,} \PYG{n}{abbreviation}\PYG{p}{,} \PYG{n}{thumbnail}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}name} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}checkName}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}checkName}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}checks the name attribute}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{k}{if} \PYG{n}{name} \PYG{o}{==} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o+ow}{or} \PYG{o+ow}{not} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{,} \PYG{n+nb}{unicode}\PYG{p}{)} \PYG{p}{)}\PYG{p}{:}
            \PYG{k}{raise}\PYG{p}{(}\PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the name shouldn}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{t be empty and it should }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s}{                be a str or unicode}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}

            \PYG{k}{return} \PYG{n}{name}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\item {} 
And also there should be 1 spaces before and after a class body:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}\PYGZhy{}*\PYGZhy{} coding: utf\PYGZhy{}8 \PYGZhy{}*\PYGZhy{}}

\PYG{k}{class} \PYG{n+nc}{A}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{pass}

\PYG{k}{class} \PYG{n+nc}{B}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{pass}

\PYG{k}{pass}
\end{Verbatim}

\item {} 
Any lines that may contain a code or comment can not be longer than 79
characters, all the longer lines should be cancelled with ``\textbackslash{}'' character and
should continue properly from the line below:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{\PYGZus{}checkName}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}checks the name attribute}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{if} \PYG{n}{name} \PYG{o}{==} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}} \PYG{o+ow}{or} \PYG{o+ow}{not} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{,} \PYG{n+nb}{unicode}\PYG{p}{)} \PYG{p}{)}\PYG{p}{:}
        \PYG{k}{raise}\PYG{p}{(}\PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the name shouldn}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{t be empty and it should be a }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s}{        str or unicode}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{name}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

This rule is not followed for the first line of the docstrings and in long
function or method names (particularly in tests).

\item {} 
If anything is going to be checked against being None you should do it in
this way:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{a} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
    \PYG{k}{pass}
\end{Verbatim}

\item {} 
Do not add docstrings to \_\_init\_\_ rather use the classes' own docstring.

\item {} 
The first line in the docstring should be a brief summary separated from the
rest by a blank line.

\end{itemize}

If you are going to add a new python file (*.py), use the following line in
the first line:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}\PYGZhy{}*\PYGZhy{} coding: utf\PYGZhy{}8 \PYGZhy{}*\PYGZhy{}}
\end{Verbatim}


\section{SCM - Mercurial (HG)}
\label{contribute:pep-8}\label{contribute:scm-mercurial-hg}
The choice of SCM is Mercurial. Every developer should be familiar with it. It
is a good start to go the \href{http://mercurial.selenic.com}{Selenic Mercurial Site} and do the tutorial if you
don't feel familiar enough with hg.


\section{Adding Changes}
\label{contribute:selenic-mercurial-site}\label{contribute:adding-changes}
If you want to do changes in Stalker, the basic pipeline is as follows:
\begin{quote}
\begin{itemize}
\item {} 
When you first start to develop, clone the repository to your computer (it
should be done only once) by using the following command:

\begin{Verbatim}[commandchars=\\\{\}]
hg clone https://stalker.googlecode.com/hg/ stalker
\end{Verbatim}

\item {} 
Note the changeset that you have started to make new additions:

\begin{Verbatim}[commandchars=\\\{\}]
hg identify

aee27d8c6820+ tip
\end{Verbatim}

Note the \textbf{aee27d8c6820} to somewhere, it will be needed when you are going
to create the bundle file.

\item {} 
Do your addition, run your tests, and be sure that your part doesn't have
any errors or failures, in stalker root directory run this command:
\begin{quote}

Linux/Mac:

\begin{Verbatim}[commandchars=\\\{\}]
./doTests
\end{Verbatim}

Windows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{doTests}\PYG{o}{.}\PYG{n}{bat}
\end{Verbatim}
\end{quote}

\item {} 
Commit your changes:

\begin{Verbatim}[commandchars=\\\{\}]
hg ci -m "I did this and that"
\end{Verbatim}

You can use the text you have written in the CHANGELOG.

\item {} 
Before creating a bundle check if there are new revisions in the
google repository:

\begin{Verbatim}[commandchars=\\\{\}]
hg pull
\end{Verbatim}

\item {} 
If there are changes and mercurial pulled them update your repository:

\begin{Verbatim}[commandchars=\\\{\}]
hg update
\end{Verbatim}

\item {} 
If there are conflicts where mercurial is waiting for you to solve them,
solve the conflicts by using your text editor and opening the file which has
conflicts. You will see lines like ``\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{} other'' and ``\textless{}\textless{}\textless{}\textless{}\textless{}\textless{}\textless{} local'',
showing the conflicting code. Clean the code and save the file, and inform
mercurial that you have resolved the conflicts by:

\begin{Verbatim}[commandchars=\\\{\}]
hg resolve -m the\_conflicting\_source\_file.py
\end{Verbatim}

or better, use a merge tool like \href{http://meld.sourceforge.net/}{Meld}.

\item {} 
Delete the file with *.orig extension (generally not needed if you are
using a merge tool):

\begin{Verbatim}[commandchars=\\\{\}]
Linux/Mac:

  rm the\_conflicting\_source\_file.py.orig

Windows:

  del the\_conflicting\_source\_file.py.orig

Or use your favourite file browser.
\end{Verbatim}

\item {} 
Do the tests again:
\begin{quote}

Linux/Mac:

\begin{Verbatim}[commandchars=\\\{\}]
./doTests
\end{Verbatim}

Windows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{doTests}\PYG{o}{.}\PYG{n}{bat}
\end{Verbatim}
\end{quote}

If there are problems in your part of the code, solve the errors/failures.

\item {} 
Commit your changes:

\begin{Verbatim}[commandchars=\\\{\}]
hg ci -m "Pulled changes from the server and merged..."
\end{Verbatim}

\item {} 
Create a bundle:

\begin{Verbatim}[commandchars=\\\{\}]
hg bundle --base aee27d8c6820 \textasciitilde{}/my.bundle
\end{Verbatim}

\end{itemize}
\begin{quote}

and send it to \href{mailto:eoyilmaz-you-know-what-to-do-with-this-part@gmail.com}{eoyilmaz-you-know-what-to-do-with-this-part@gmail.com}. I also
accept, diffs in git format.
\end{quote}
\end{quote}


\chapter{Stalker Development Roadmap}
\label{roadmap:roadmap-toplevel}\label{roadmap:stalker-development-roadmap}\label{roadmap::doc}
This section describes the direction Stalker is going.


\section{Roadmap Based on Versions}
\label{roadmap:roadmap-based-on-versions}
Below you can find the roadmap based on the version


\subsection{0.1.0:}
\label{roadmap:id1}\begin{itemize}
\item {} 
A complete working set of models in SOM which are using
SQLAlchemy.ext.declarative.

\end{itemize}


\subsection{0.2.0:}
\label{roadmap:id2}\begin{itemize}
\item {} 
Web interface

\item {} 
Complete ProdAM capabilities.

\end{itemize}


\chapter{Stalker Changes}
\label{changelog:changelog-toplevel}\label{changelog::doc}\label{changelog:stalker-changes}

\section{0.2.0.b7}
\label{changelog:b7}\begin{itemize}
\item {} 
\textbf{SOM:}
\begin{itemize}
\item {} 
\textbf{Update:} \textbf{Task.schedule\_constraint} is now reflected to the tjp file
correctly.

\item {} 
\textbf{Fix:} \textbf{check\_circular\_dependency()} now checks if the \textbf{entity} and
the \textbf{other\_entity} are the same.

\item {} 
\textbf{Fix:} \textbf{Task.to\_tjp()} now correctly add the dependent tasks of a
container task.

\item {} 
\textbf{Fix:} \textbf{Task.\_\_eq\_\_()} now correctly considers the parent, depends and
children Tasks.

\item {} 
\textbf{Update:} \textbf{Task.priority} is now reflected in tjp file if it is
different than the default value (500).

\item {} 
\textbf{New::} Added a new class called \textbf{Vacation} to hold user vacations.

\end{itemize}

\item {} 
\textbf{WebUI:}
\begin{itemize}
\item {} 
\textbf{Fix:} GanttChart  view of Assets, Shots,Sequences or Tasks now displays
only the children and parents of that Task derivative.

\item {} 
\textbf{Update:} Task create/update dialog now displays the full hierarchy in
parent/dependent task listings.

\item {} 
\textbf{Fix:} TimeLog create/update dialog now displays the default times
correctly when creating a new TimeLog.

\item {} 
\textbf{Fix:} TimeLog create/update view callables are now checking if there
will be any OverBookedError raised.

\item {} 
\textbf{Fix:} Task create/update dialog now will not list the task itself in
parent and dependent task lists, if the UI is called with a Task instance
(\{\{task\}\} is not None).

\item {} 
\textbf{Update:} For Asset Page and Task Page tab order is changed.

\item {} 
\textbf{New:} Starts and Ends attributes are added to Task Summary Page.

\item {} 
\textbf{Update:} List of Users, Departments and Groups are now sorted by using
the name of the entity.

\item {} 
\textbf{Update:} Task create/update dialog now has a new field called
\code{priority}.

\item {} 
\textbf{Update:} \textbf{Task.schedule\_constraint} is now filled with correct
information when creating/updating a Task.

\item {} 
\textbf{JQueryGantt:}
\begin{itemize}
\item {} 
\textbf{Update:} Context menu can now be opened in task names in grid editor.

\item {} 
\textbf{Update:} Optimized the creation of task rows.

\item {} 
\textbf{Update:} Replaced the \code{input} elements with \code{div} in the task row.

\item {} 
\textbf{New:} Holding the mouse on Task bar elements will now show a popup
window for more info.

\item {} 
\textbf{Update:} Gantt Chart zoom levels are now fully controlled by the start
and end date DateTextBoxes.

\item {} 
\textbf{New:} Added a new button which will center the gantt chart on today.

\end{itemize}

\end{itemize}

\end{itemize}


\section{0.2.0.b6}
\label{changelog:b6}\begin{itemize}
\item {} 
\textbf{SOM}:
\begin{itemize}
\item {} 
\textbf{Fix:} Fixed \textbf{LocalSession.\_write\_data()}, previously it was not
creating the local session folder.

\item {} 
\textbf{New:} Added a new method called \textbf{LocalSession.delete()} to remove the
local session file.

\item {} 
\textbf{Update:} \textbf{Link.full\_path} can now be set to an empty string. This is
updated in this way for \textbf{Version} class.

\item {} 
\textbf{Update:} Updated the formatting of \textbf{SimpleEntity.nice\_name}, it is now
possible to have uppercase letters and camel case format will be preserved.

\item {} 
\textbf{Update}: \textbf{Version.take\_name} formatting is enhanced.

\item {} 
\textbf{New}: \textbf{Task} class is now mixed in with \textbf{ReferenceMixin} making it
unnecessary to have \textbf{Asset}, \textbf{Shot} and \textbf{Sequence} classes all mixed
in individually. Thus removed the \textbf{ReferenceMixin} from \textbf{Asset},
\textbf{Shot} and \textbf{Sequence} classes.

\item {} 
\textbf{Update}: Added \textbf{Task.schedule\_model} validation and its tests.

\item {} 
\textbf{New}: Added \textbf{ScheduleMixin.total\_seconds} and
\textbf{ScheduleMixin.computed\_total\_seconds}.

\end{itemize}

\textbf{WebUI}:
\begin{itemize}
\item {} 
\textbf{New}: Added `duration' field to TimeLog's List dgrid.

\end{itemize}

\end{itemize}


\section{0.2.0.b5}
\label{changelog:b5}\begin{itemize}
\item {} 
\textbf{SOM}:
\begin{itemize}
\item {} 
\textbf{New:} \textbf{Version} class now has two new attributes called \code{parent} and
\code{children} which will be used in tracking of the history of Version
instances and track which Versions are derived from which Version.

\item {} 
\textbf{New:} \textbf{Versions} instances are now derived from \textbf{Link} class and not
\textbf{Entity}.

\item {} 
\textbf{Update:} Added new revisions to \textbf{alembic} to reflect the change in
\textbf{Versions} table.

\item {} 
\textbf{Update:} \textbf{Links.path} is renamed to \textbf{Links.full\_path} and added
three new attributes called \textbf{path}, \textbf{filename} and \textbf{extension}.

\item {} 
\textbf{Update:} Added new revisions to alembic to reflect the change in
\textbf{Links} table.

\item {} 
\textbf{New:} Added a new class called \textbf{LocalSession} to store session data in
users local filesystem. It is going to be replaced with some other system
like \textbf{Beaker}.

\item {} 
\textbf{Fix:} Database part of Stalker can now be imported without depending to
\textbf{Pyramid}.

\item {} 
\textbf{Fix:} Fixed documentation errors that \textbf{Sphinx} complained about.

\end{itemize}

\end{itemize}


\section{0.2.0.b4}
\label{changelog:b4}\begin{itemize}
\item {} 
\textbf{WebUI}:
\begin{itemize}
\item {} 
\textbf{Fix:} Fixed the error in rendering of the \textbf{home} occurred when there is no
user login information found in the request.

\item {} 
\textbf{New:} User thumbnails now can be changed.

\item {} 
\textbf{New:} Project thumbnails now can be changed.

\item {} 
\textbf{New:} \code{content\_list\_projects} now shows the project thumbnails.

\item {} 
\textbf{New:} \code{content\_list\_users} now shows the user thumbnails.

\item {} 
\textbf{New:} \code{submitForm.js} now enables all the disabled fields of the given
form, and disables them back again upon error.

\item {} 
\textbf{Fix:} \code{TagSelect.js} will now correctly disable the child widgets if the
\code{disabled} attribute is set to \textbf{true}.

\item {} 
\textbf{New:} Added \code{fields} javascript library which are a special group of input
fields designed to be used with Stalker.

\item {} 
\textbf{New:} Added the first input field to stalker/fields, called \code{tagField}. It
is now possible to add a TagSelect field which is correctly updated by only
two lines of code.

\item {} 
\textbf{New:} Added \code{get\_tags()} to stalker.views.\_\_init\_\_ module. Because all the
tags now should be created with the \code{tagField} the way to retrieve tags
is the same, so this helper function will let you retrieve tags from the
given request instance.

\item {} 
\textbf{New:} Permissions page is added to Group Page.

\item {} 
\textbf{Fix:} dgrid object is declared from {[}Grid, Selection, Keyboard{]}. So it's
possible to select a row and navigate by Keyboard.

\item {} 
\textbf{New:} Permission controls are added to `Page' and `List' files.

\item {} 
\textbf{New:} Permission controls are added to `Dialog' and `Summary' files.

\end{itemize}

\end{itemize}


\section{0.2.0.b3}
\label{changelog:b3}\begin{itemize}
\item {} 
\textbf{SOM}:
\begin{itemize}
\item {} 
\textbf{Update:} FilenameTemplate's are not \code{strictly typed} anymore.

\item {} 
\textbf{Update:} Removed the FilenameTemplate type initialization, FilenameTemplates
do not depend on Types anymore.

\item {} 
\textbf{Update:} Added back the \code{plural\_class\_name} (previously \code{plural\_name})
property to the ORMClass class, so all the classes in SOM now have this new
property.

\item {} 
\textbf{Update:} Added \code{accepts\_references} attribute to the EntityType class.

\item {} 
\textbf{New:} The Link class has a new attribute called \code{original\_filename} to
store the original file names of link files.

\item {} 
\textbf{New:} Added \textbf{alembic} to the project requirements.

\item {} 
\textbf{New:} Added alembic migrations which adds the \code{accepts\_references} column
to \code{EntityTypes} table and \code{original\_name} to the \code{Links} table.

\end{itemize}

\item {} 
\textbf{WebUI}:
\begin{itemize}
\item {} 
\textbf{Update:} Updated to Dojo 1.9

\item {} 
\textbf{Update:} stalker.js is renamed to dialogs.js and it is now fully compatible
with Dojo AMD.

\item {} 
\textbf{Update:} Merged StatusList create and update dialogs in to one.

\item {} 
\textbf{Update:} Content List - Task now checks user permissions to disable part of
the UI.

\item {} 
\textbf{Update:} Added description field to the Summarize Task view.

\item {} 
\textbf{Update:} Added permission checks to several views.

\item {} 
\textbf{Fix:} Fixed fieldUpdater.js to work properly with Dojo 1.9 especially for
MultiSelect widgets.

\item {} 
\textbf{Fix:} Separated the dialog and action routes for Structure.

\item {} 
\textbf{Fix:} Fixed unnecessary module imports in stalker.js.

\item {} 
\textbf{Fix:} Schedule button is now working properly.

\item {} 
\textbf{Fix:} Fixed Image Format creation.

\item {} 
\textbf{Fix:} Fixed Filename Template create dialog routine.

\item {} 
\textbf{Fix:} Fixed Filename Template update dialog routine.

\item {} 
\textbf{Fix:} Fixed entity\_types in Filename Template creation UI.

\item {} 
\textbf{Fix:} Fixed Group update dialog, the permissions were not displayed and the
name was not updated on the server side.

\item {} 
\textbf{Fix:} Fixed TaskBox CSS template

\item {} 
\textbf{New:} GanttChart now displays the finished/unfinished tasks with a green/red
`id' column.

\item {} 
\textbf{Fix:} Status color attribute converted from unicode to integer.

\item {} 
\textbf{Fix:} To destroy previous open dialog, same dialog id is given for create
and update dialogs.

\item {} 
\textbf{Update:} In create/update\_group dialog, to check all rows new checkboxes are
added to head of each column.

\item {} 
\textbf{Update:} \code{ComboBox} is added to TagSelect widget as a new input widget
type.

\item {} 
\textbf{Update:} Description field is added to Department dialog.

\end{itemize}

\end{itemize}


\section{0.2.0.b2}
\label{changelog:b2}\begin{itemize}
\item {} 
Stalker is now compatible with Python 2.6.

\item {} 
SOM:
\begin{itemize}
\item {} 
Task:
\begin{itemize}
\item {} 
\textbf{Update:} Tasks now have a new attribute called \code{watchers} which holds a
list of User instances watching the particular Task.

\item {} 
\textbf{Update:} Users now have a new attribute called \code{watching} which is a
list of Task instances that this user is watching.

\end{itemize}

\item {} 
TimeLog:
\begin{itemize}
\item {} 
\textbf{Update:} TimeLog instances will expand Task.schedule\_timing value
automatically if the total amount of logged time is more than the
schedule\_timing value.

\item {} 
\textbf{Update:} TimeLogs are now considered while scheduling the task.

\item {} 
\textbf{Fix:} TimeLogs raises OverBookedError when appending the same TimeLog
instance to the same resource.

\end{itemize}

\item {} 
Auth:
\begin{itemize}
\item {} 
\textbf{Fix:} The default ACLs for determining the permissions are now working
properly.

\end{itemize}

\end{itemize}

\item {} 
WebUI:
\begin{itemize}
\item {} 
\textbf{Fix:} \code{user\_create\_dialog} now shows and updates groups.

\item {} 
\textbf{Fix:} Updating a project now correctly refreshes the \code{project\_summary}
content pane.

\item {} 
\textbf{Fix:} Separated the dialog and action routes for ImageFormat.

\item {} 
\textbf{Fix:} Separated the dialog and action routes for Asset.

\item {} 
\textbf{Fix:} Separated the dialog and action routes for Repository.

\item {} 
\textbf{Fix:} The working hours were not correctly passed to the studio instance
in Studio creation.

\item {} 
\textbf{Fix:} ``Append User Dialog'' is now working properly.

\item {} 
\textbf{Fix:} Links between pages is created with redirectLink function which is
written in base.jinja2. goToLink.js is deprecated, but still there are some
codes that uses gotolink.js, they must be changed for next update.

\item {} 
\textbf{Update:} Combined \code{user\_create\_dialog} and \code{user\_update\_dialog} into
one.

\item {} 
\textbf{Update:} Logged in work times will now be visible in gantt charts as a green
bar in the TaskBar div.

\item {} 
\textbf{Update:} Department menus under `Crew' menu are now showing the department
users.

\item {} 
\textbf{Update:} Color choosers in ``Create Status Dialog'' now have colors picked by
default for BG and FG colors.

\item {} 
\textbf{Update:} Replaced DataGrid objects with dgrid.

\item {} 
\textbf{Update:} Added navigation bar for assets, shots, sequences.

\item {} 
\textbf{Update:} Combined \code{project\_create\_dialog} and \code{project\_update\_dialog}
into one.

\item {} 
\textbf{Update:} Merged the `Crew' menu creation code in to one single
teamMenuCreator.js, which is able to create menus for any groups and faux
groups.

\item {} 
\textbf{Update:} All DataGrid field updated with dgrid class.

\item {} 
\textbf{New:} Placeholder images added for user and department.

\item {} 
\textbf{New:} Added update group dialog.

\item {} 
\textbf{Update:} Colors for the layouts are changed with MiamiNice PieChart's color.

\item {} 
\textbf{New:} Added update group dialog.

\item {} 
\textbf{New:} Append department and append group pages has connected to database.

\item {} 
\textbf{New:} Timelog List page added.

\item {} 
\textbf{New:} New placeholders added for different type of object.

\end{itemize}

\item {} 
jQueryGantt:
\begin{itemize}
\item {} 
\textbf{Update:} Replaced the \code{duration} column with \code{timing} which correctly
shows the schedule timing info of the related task.

\item {} 
\textbf{Fix:} The \code{depends} column shows the dependent task names correctly.

\item {} 
\textbf{Update:} jQueryGantt displays the owner Project of the Tasks as a container
task.

\item {} 
\textbf{Update:} Added content link (this will be updated to support proper links,
hardcoded links to be removed).

\item {} 
\textbf{Update:} Disabled drag and resize of TaskBar elements.

\item {} 
\textbf{Update:} Moved the resource link code to the JST template code instead of
the Task class.

\end{itemize}

\end{itemize}


\section{0.2.0.b1}
\label{changelog:b1}\begin{itemize}
\item {} 
WorkingHours.is\_working\_hour() is working now.

\item {} 
WorkingHours class is moved from stalker.models.project to
stalker.models.studio module.

\item {} 
\code{daily\_working\_hours} attribute is moved from
stalker.models.project.Project to stalker.models.studio.Studio class.

\item {} 
Repository path variables now ends with a forward slash even if it is not
given.

\item {} 
Updated Project classes validation messages to correlate with Stalker
standard.

\item {} 
Implementation of the Studio class is finished. The scheduling works like a
charm.

\item {} 
Added dialogCreator.js which helps creating a dialog without having a widget
(Button or MenuItem) calling it and updated dialogCaller.js to use
dialogCreator while creating a dialog.

\item {} 
It is now possible to use any characters in SimpleEntity.name and the derived
classes.

\item {} 
jQueryGantt:
\begin{itemize}
\item {} 
Fix; t is now possible to correctly move a TaskBar without getting in to
an infinite loop which was freezing the browser.

\item {} 
The timing resolution of jQueryGantt is now 1 hour.

\item {} 
Fix; GanttMaster.task\_ids were not properly cleaned in GanttMaster.reset(),
resulting wrong links to be created.

\item {} 
Added a new zoom level where it is possible to see the every 1 hour of 1
day.

\item {} 
Colorized the Sunday column in suitable zoom levels. In upcoming releases
it will use the stalker.models.studio.Studio.working\_hours attribute to
determine if the day/hour is an off day/hour.

\item {} 
Disabled editing of date fields.

\item {} 
Disabled undo/redo queue for performance test.

\item {} 
Fixed vertical overflow in gantt chart.

\item {} 
It is now possible to not to align a tasks start to its dependent tasks
end.

\end{itemize}

\item {} 
The Shot, Asset, Sequence detail pages under the Project Overview now opens
inside the related tab on the Project Page.

\item {} 
Booking class is renamed to TimeLog.

\end{itemize}


\section{0.2.0.a10}
\label{changelog:a10}\begin{itemize}
\item {} 
jQueryGantt:
\begin{itemize}
\item {} 
jQueryGantt is now using the Task ids coming from Stalker instead of the
ridiculous rowId.

\item {} 
Fixed a lot of issues related with the new data structure, it seems
everything is working properly right now.

\item {} 
Parent Tasks displayed differently than the leaf tasks (on paar with the
other gantt charts).

\item {} 
Gantt chart in User Detail page is now showing the parent tasks of the
tasks of the user.

\item {} 
Now there are two different context menus for container/parent tasks and
leaf tasks.

\end{itemize}

\item {} 
Added new attribute to WorkingHours class called \code{weekly\_working\_hours},
which calculates the weekly working hours based on the working hours defined
in the instance.

\item {} 
Updated the Create Task Dialog to reflect the TaskJuggler integration.

\item {} 
Task class now has a new attribute called \code{schedule\_timing} which is
replacing the \code{effort}, \code{length} and \code{duration} attributes. Together
with the \code{schedule\_model} attribute it will be used in scheduling the Task.

\item {} 
Updated the config system to the one used in oyProjectManager (based on
Sphinx config system). Now to reach the defaults:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} instead of doing the following}
\PYG{k+kn}{from} \PYG{n+nn}{stalker.conf} \PYG{k+kn}{import} \PYG{n}{defaults} \PYG{c}{\PYGZsh{} not valid anymore}

\PYG{c}{\PYGZsh{} use this}
\PYG{k+kn}{from} \PYG{n+nn}{stalker} \PYG{k+kn}{import} \PYG{n}{defaults}
\end{Verbatim}

If the above idiom is used, the old \code{defaults} module behaviour is
retained, so no code change is required other than the new lower case config
variable names.

\end{itemize}


\section{0.2.0.a9}
\label{changelog:a9}\begin{itemize}
\item {} 
A new property called \code{to\_tjp} added to the SimpleEntity class which needs
to be implemented in the child and is going to be used in TaskJuggler
integration.

\item {} 
A new attribute called \code{is\_scheduled} added to Task class and it is going
to be used in Gantt charts. Where it will lock the class and will not try
to snap it to anywhere if it is scheduled.

\item {} 
Changed the \code{resolution} attribute name to \code{timing\_resolution} to comply
with TaskJuggler.

\item {} 
ScheduleMixin:
\begin{itemize}
\item {} 
Updated ScheduleMixin class documentation.

\item {} 
There are two new read-only attributes called \code{computed\_start} and
\code{computed\_end}. These attributes will be used in storing of the values
calculated by TaskJuggler, and will be used in Gantt Charts if available.

\item {} 
Added \code{computed\_duration}.

\end{itemize}

\item {} 
Task:
\begin{itemize}
\item {} 
Arranged the TaskJuggler workflow.

\item {} 
The task will use the effort \textgreater{} length \textgreater{} duration attributes in \emph{to\_tjp}
property.

\end{itemize}

\item {} 
Changed the license of Stalker from BSD-2 to LGPL 2.1. Any version previous
to 0.2.0.a9 will be still BSD-2 and any version from and including 0.2.0.a9
will be distributed under LGPL 2.1 license.

\item {} 
Added new types of classes called Schedulers which are going to be used in
scheduling the tasks.

\item {} 
Added TaskJugglerScheduler, it uses the given project and schedules its
tasks.

\end{itemize}


\section{0.2.0.a8}
\label{changelog:a8}\begin{itemize}
\item {} 
TagSelect now can be filled by setting its \code{value} attribute (Ex:
TagSelect.set(`value', data))

\item {} 
Fixed Projects menu in base.jinja2, the link is now updating correctly when a
new project is added.

\item {} 
Added a new method called \code{is\_root} to Task class. It is true for tasks
where there are no parents.

\item {} 
Added a new attribute called \code{users} to the Department class which is a
synonym for the \code{members} attribute.

\item {} 
Task:
\begin{itemize}
\item {} 
Task class is now preventing one of the dependents to be set as the parent
of a task.

\item {} 
Task class is now preventing one of the parents to be set as the one of the
dependents of a task.

\item {} 
Fixed \code{autoflush} bugs in Task class.

\end{itemize}

\item {} 
Fixed \emph{admin} users department initialization.

\item {} 
Added \code{thumbnail} attribute to the SimpleEntity class which is a reference
to a Link instance, showing the path of the thumbnail.

\item {} 
Fixed Circular Dependency bug in Task class, where a parent of a newly
created task is depending to another task which is set as the dependee for
this newly created task (T1 -\textgreater{} T3 -\textgreater{} T2 -\textgreater{} T1 (parent relation) -\textgreater{} T3 -\textgreater{} T2
etc.).

\item {} 
jQueryGantt: Moving any child task will adjust the parent start and end dates
so they fit to the children.

\end{itemize}


\section{0.2.0.a7}
\label{changelog:a7}\begin{itemize}
\item {} 
Changed these default setting value names to corresponding new names:
\begin{itemize}
\item {} 
\code{DEFAULT\_TASK\_DURATION} -\textgreater{} \code{TASK\_DURATION}

\item {} 
\code{DEFAULT\_TASK\_PRIORITY} -\textgreater{} \code{TASK\_PRIORITY}

\item {} 
\code{DEFAULT\_VERSION\_TAKE\_NAME} -\textgreater{} \code{VERSION\_TAKE\_NAME}

\item {} 
\code{DEFAULT\_TICKET\_LABEL} -\textgreater{} \code{TICKET\_LABEL}

\item {} 
\code{DEFAULT\_ACTIONS} -\textgreater{} \code{ACTIONS}

\item {} 
\code{DEFAULT\_BG\_COLOR} -\textgreater{} \code{BG\_COLOR}

\item {} 
\code{DEFAULT\_FG\_COLOR} -\textgreater{} \code{FG\_COLOR}

\end{itemize}

\item {} 
stalker.conf.defaults:
\begin{itemize}
\item {} 
Added default settings for project working hours (\code{WORKING\_HOURS},
\code{DAY\_ORDER}, \code{DAILY\_WORKING\_HOURS})

\item {} 
Added a new variable for setting the task time resolution called
\code{TIME\_RESOLUTION}.

\end{itemize}

\item {} 
stalker.models.project.Project:
\begin{itemize}
\item {} 
Removed Project.project\_tasks attribute, use Project.tasks directly to get
all the Tasks in that project. For root task you can do a quick query:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Task}\PYG{o}{.}\PYG{n}{query}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{Task}\PYG{o}{.}\PYG{n}{project}\PYG{o}{==}\PYG{n}{proj\PYGZus{}id}\PYG{p}{)}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{n}{Task}\PYG{o}{.}\PYG{n}{parent}\PYG{o}{==}\PYG{n+nb+bp}{None}\PYG{p}{)}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

This will also return the Assets, Sequences and Shots in that project,
which are also Tasks.

\item {} 
Users are now assigned to Projects by appending them to the Project.users
list. This is done in this way to allow a reduced list of resources to be
shown in the Task creation dialogs.

\item {} 
Added a new helper class for Project working hour management, called
WorkingHours.

\item {} 
Added a new attribute to Project class called \code{working\_hours} which holds
stalker.models.project.WorkingHours instances to manage the Project working
hours. It will directly be passed to TaskJuggler.

\end{itemize}

\item {} 
stalker.models.task.Task:
\begin{itemize}
\item {} 
Removed the Task.task\_of attribute, use Task.parent to get the owner of
this Task.

\item {} 
Task now has two new attributes called Task.parent and Task.children which
allow more complex Task-to-Task relation.

\item {} 
Secondary table name for holding Task to Task dependency relation is
renamed from \code{Task\_Tasks} to \code{Task\_Dependencies}.

\item {} 
check\_circular\_dependency function is now accepting a third argument which
is the name of the attribute to be investigated for circular relationship.
It is done in that way to be able to use the same function in searching for
circular relations both in parent/child and depender/dependee relations.

\end{itemize}

\item {} 
ScheduleMixin:
\begin{itemize}
\item {} 
Added a new attribute to ScheduleMixin for time resolution adjustment.
Default value is 1 hour and can be set with
stalker.conf.defaults.TIME\_RESOLUTION. Any finer time than the resolution
is rounded to the closest multiply of the resolution. It is possible to set
it from microseconds to years. Although 1 hour is a very reasonable
resolution which is also the default resolution for TaskJuggler.

\item {} 
ScheduleMixin now uses datetime.datetime for the start and end attributes.

\item {} 
Renamed the \code{start\_date} attribute to \code{start}.

\item {} 
Renamed the \code{end\_date} attribute to \code{end}

\end{itemize}

\item {} 
Removed the TaskableEntity.

\item {} 
Asset, Sequence and Shot classes are now derived from Task class allowing
more complex Task relation combined with the new parent/child relation of
Tasks. Use Asset.children or Asset.tasks to reach the child tasks of that
asset (same with Sequence and Shot classes).

\item {} 
stalker.models.shot.Shot:
\begin{itemize}
\item {} 
Removed the sequence and introduced sequences attribute in Shot class. Now
one shot can be in more than one Sequence. Allowing more complex
Shot/Sequence relations..

\item {} 
Shots can now be created without a Sequence instance. The sequence
attribute is just used to group the Shots.

\item {} 
Shots now have a new attribute called \code{scenes}, holding Scene instances.
It is created to group same shots occurring in the same scenes.

\end{itemize}

\item {} 
In tests all the Warnings are now properly handled as Warnings.

\item {} 
stalker.models.ticket.Ticket:
\begin{itemize}
\item {} 
Ticket instances are now tied to Projects and it is now possible to create
Tickets without supplying a Version. They are free now.

\item {} 
It is now possible to link any SimpleEntity to a Ticket.

\item {} 
The Ticket Workflow is now fully customizable. Use
stalker.conf.defaults.TICKET\_WORKFLOW dictionary to define the workflow and
stalker.conf.defaults.TICKET\_STATUS\_ORDER for the order of the ticket
statuses.

\end{itemize}

\item {} 
Added a new class called \code{Scene} to manage Shots with another property.

\item {} 
Removed the \code{output\_path} attribute in FilenameTemplate class.

\item {} 
Grouped the templates for each entity under a directory with the entity name.

\item {} 
Converted the \code{view.py} to a python module and put the views for each
entity to its own python file.

\end{itemize}


\section{0.2.0.a6}
\label{changelog:a6}\begin{itemize}
\item {} 
Added a new Dojo Widget called Tag to help the creation of the tags in the
TagSelect.

\item {} 
Users now can have more than one Department.

\item {} 
Updated java scripts to be \emph{required} in Dojo AMD way.

\item {} 
Updated setup.py to include ``pyramid\_jinja2''

\item {} 
User instances now have two new properties for getting the user tickets
(User.tickets) and the open tickets (User.open\_tickets).

\item {} 
New shortcut Task.project returns the Task.task\_of.project value.

\item {} 
Added `PlaceHolder' property for `FilterSelect Widgets'. And `Label' property
is used in construction of `PlaceHolder' property.

\item {} 
Set disabled prerequisite fields, until their prerequisite is selected.

\item {} 
Added `StartDate', `EndDate' and `Duration' field to add\_project page.
`StartDate', `EndDate' properties are written on database.

\item {} 
jQueryGannt:
\begin{itemize}
\item {} 
Gannt view is now communicating with Stalker correctly. The only left issue
is the end date value is not properly shown in the gannt view.

\item {} 
Updated the jQueryGannt css's to work with Stalker and Dojo.

\end{itemize}

\item {} 
Project page is redesigned. SplitContainer is removed. All contents are
displayed in TabContainer. New Contents in TabContainer are:
\begin{itemize}
\item {} 
ProjectName (Disabled Field - Used for displaying projectname.)

\item {} 
Overview  (It has InlineEditable fields. Although they are not connected
to DB.)

\end{itemize}

\item {} 
Shot and Asset creation dialogs now automatically updated with the given
Project instance info.

\item {} 
User overview page is now reflection the new design.

\end{itemize}


\section{0.2.0.a5}
\label{changelog:a5}\begin{itemize}
\item {} 
The \code{code} attribute of the SimpleEntity is now introduced as a separate
mixin. To let it be used by the classes it is really needed.

\item {} 
The \code{query} method is now converted to a property so it is now possible to
use it like a property as in the SQLAlchemy.orm.Session as shown below:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{stalker} \PYG{k+kn}{import} \PYG{n}{Project}
\PYG{n}{Project}\PYG{o}{.}\PYG{n}{query}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{} instead of Project.query().all()}
\end{Verbatim}

\item {} 
ScheduleMixin.due\_date is renamed to ScheduleMixin.end\_date.

\item {} 
Added a new class attribute to SimpleEntity called \code{\_\_auto\_name\_\_} which
controls the naming of the instances and instances derived from SimpleEntity.
If \code{\_\_auto\_name\_\_} is set to True the \code{name} attribute of the instance
will be automatically generated and it will have the following format:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZob{}ClassName\PYGZcb{}\PYGZcb{}\_\PYGZob{}\PYGZob{}UUID4\PYGZcb{}\PYGZcb{}
\end{Verbatim}

Here are a couple of naming examples:

\begin{Verbatim}[commandchars=\\\{\}]
Ticket\_74bb46b0-29de-4f3e-b4e6-8bcf6aed352d
Version\_2fa5749e-8cdb-4887-aef2-6d8cec6a4faa
\end{Verbatim}

\item {} 
Fixed an autoflush issue with SQLAlchemy in StatusList class. Now the status
column is again not nullable in StatusMixin.

\item {} 
The WebUI form fields are now refreshed with newly added data.

\item {} 
Added a new Dojo widget called TagSelect. Which is basically a widget for
adding Tag style widgets.

\end{itemize}


\section{0.2.0.a4}
\label{changelog:a4}\begin{itemize}
\item {} 
Added a new class called EntityType to hold all the available class names and
capabilities.

\item {} 
Version class now has a new attribute called \code{inputs} to hold the inputs of
the current Version instance. It is a list of Link instances.

\item {} 
FilenameTemplate classes \code{path} and \code{filename} attributes are no more
converted to string, so given a non string value will raise TypeError.

\item {} 
Structure.custom\_template now only accepts strings and None, setting it to
anything else will raise a TypeError.

\item {} 
Two Type's for FilenameTemplate's are created by default when initializing
the database, first is called ``Version'' and it is used to define
FilenameTemplates which are used for placing Version source files. The second
one is called ``Reference'' and it is used when injecting references to a given
class. Along with the FilenameTemplate.target\_entity\_type this will allow one
to create two different FilenameTemplates for one class:

\begin{Verbatim}[commandchars=\\\{\}]
\# first get the Types
vers\_type = Type.query()\PYGZbs{}
            .filter\_by(target\_entity\_type="FilenameTemplate")\PYGZbs{}
            .filter\_by(type="Version")\PYGZbs{}
            .first()

ref\_type = Type.query()\PYGZbs{}
           .filter\_by(target\_entity\_type="FilenameTemplate")\PYGZbs{}
           .filter\_by(type="Reference")\PYGZbs{}
           .first()

\# lets create a FilenameTemplate for placing Asset Version files.
f\_ver = FilenameTemplate(
    target\_entity\_type="Asset",
    type=vers\_type,
    path="Assets/\PYGZob{}\PYGZob{}asset.type.code\PYGZcb{}\PYGZcb{}/\PYGZob{}\PYGZob{}asset.code\PYGZcb{}\PYGZcb{}/\PYGZob{}\PYGZob{}task.type.code\PYGZcb{}\PYGZcb{}",
    filename="\PYGZob{}\PYGZob{}asset.code\PYGZcb{}\PYGZcb{}\_\PYGZob{}\PYGZob{}version.take\_name\PYGZcb{}\PYGZcb{}\_\PYGZob{}\PYGZob{}task.type.code\PYGZcb{}\PYGZcb{}\_v\PYGZob{}\PYGZob{}'\%03d'\textbar{}version.version\_number\PYGZcb{}\PYGZcb{}\PYGZob{}\PYGZob{}link.extension\PYGZcb{}\PYGZcb{}"
    output\_path="\PYGZob{}\PYGZob{}version.path\PYGZcb{}\PYGZcb{}/Outputs/\PYGZob{}\PYGZob{}version.take\_name\PYGZcb{}\PYGZcb{}"
)

\# and now define a FilenameTemplate for placing Asset Reference files.
\# no need to have an output\_path here...
f\_ref = FilenameTemplate(
    target\_entity\_type="Asset",
    type=ref\_type,
    path="Assets/\PYGZob{}\PYGZob{}asset.type.code\PYGZcb{}\PYGZcb{}/\PYGZob{}\PYGZob{}asset.code\PYGZcb{}\PYGZcb{}/References",
    filename="\PYGZob{}\PYGZob{}link.type.code\PYGZcb{}\PYGZcb{}/\PYGZob{}\PYGZob{}link.id\PYGZcb{}\PYGZcb{}\PYGZob{}\PYGZob{}link.extension\PYGZcb{}\PYGZcb{}"
)
\end{Verbatim}

\item {} 
stalker.db.register() now accepts only real classes instead of class names.
This way it can store more information about classes.

\item {} 
Status.bg\_color and Status.fg\_color attributes are now simple integers. And
the Color class is removed.

\item {} 
StatusMixin.status is now a ForeignKey to a the Statuses table, thus it is a
real Status instance instead of an integer showing the index of the Status in
the related StatusList. This way the Status of the object will not change if
the content of the StatusList is changed.

\item {} 
Added new attribute Project.project\_tasks which holds all the direct or
indirect Tasks created for that project.

\item {} 
User.login\_name is renamed to User.login.

\item {} 
Removed the \code{first\_name}, \code{last\_name} and \code{initials} attributes from
User class. Now the \code{name} and \code{code} attributes are going to be used,
thus the \code{name} attribute is no more the equivalent of \code{login} and the
\code{code} attribute is doing what was \code{initials} doing previously.

\end{itemize}


\section{0.2.0.a3}
\label{changelog:a3}\begin{itemize}
\item {} 
Status class now has two new attributes \code{bg\_color} and \code{fg\_color} to hold
the UI colors of the Status instance. The colors are Color instances.

\end{itemize}


\section{0.2.0.a2}
\label{changelog:a2}\begin{itemize}
\item {} 
SimpleEntity now has an attribute called \code{generic\_data} which can hold any
kind of \code{SOM} object inside and it is a list.

\item {} 
Changed the formatting rules for the \code{name} in SimpleEntity class, now it
can start with a number, and it is not allowed to have multiple whitespace
characters following each other.

\item {} 
The \code{source} attribute in Version is renamed to \code{source\_file}.

\item {} 
The \code{version} attribute in Version is renamed to \code{version\_number}.

\item {} 
The \code{take} attribute in Version is renamed to \code{take\_name}.

\item {} 
The \code{version\_number} in Version is now generated automatically if it is
skipped or given as None or it is too low where there is already a version
number for the same Version series (means attached to the same Task and has
the same \code{take\_name}.

\item {} 
Moved the User class to \code{stalker.models.auth module}.

\item {} 
Removed the \code{stalker.ext.auth} module because it is not necessary anymore.
Thus the User now handles all the password conversions by itself.

\item {} 
\code{PermissionGroup} is renamed back to Group
again to match with the general naming of the authorization concept.

\item {} 
Created two new classes for the Authorization system, first one is called
Permission and the second one is a Mixin which is called ACLMixin which adds
ACLs to the mixed in class. For now, only the User and Group classes are
mixed with this mixin by default.

\item {} 
The declarative Base class of SQLAlchemy is now created by binding it to a
ORMClass (a random name) which lets all the derived class to have a method
called \code{query} which will bypass the need of calling
\code{DBSession.query(class\_)} but instead just call \code{class\_.query()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{stalker.models.auth} \PYG{k+kn}{import} \PYG{n}{User}
\PYG{n}{user\PYGZus{}1} \PYG{o}{=} \PYG{n}{User}\PYG{o}{.}\PYG{n}{query}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{filter\PYGZus{}by}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a user name}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{first}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\end{itemize}


\section{0.2.0.a1}
\label{changelog:a1}\begin{itemize}
\item {} 
Converted the whole system to a Pyramid Web application. If the previous
implementations investigated, it will be understood that it was only the
database model of a Web Application.

\item {} 
Changed the \code{db.setup} arguments. It is now accepting a dictionary instead
of just a string to comply with the SQLAlchemy scaffold and this dictionary
should contain keys for the SQLAlchemy engine setup. There is another utility
that comes with Pyramid to setup the database under the \emph{scripts} folder, it
is also working without any problem with stalker.db.

\item {} 
The \code{session} variable is renamed to \code{DBSession} and is now a scopped
session, so there is no need to use \code{DBSession.commit} it will be handled
by the system it self.

\item {} 
Even though the \code{DBSession} is using the Zope Transaction Manager extension
normally, in the database tests no extension is used because the transaction
manager was swallowing all errors and it was a little weird to try to catch
this errors out of the \code{with} block.

\item {} 
Refactored the code, all the models are now in separate python files, but can
be directly imported from the main stalker module as shown:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{stalker} \PYG{k+kn}{import} \PYG{n}{User}\PYG{p}{,} \PYG{n}{Department}\PYG{p}{,} \PYG{n}{Task}
\end{Verbatim}

By using this kind of organization, both development and usage will be eased
out.

\item {} 
\code{task\_of} now only accepts TaskableEntity instances.

\item {} 
Updated the examples. It is now showing how to extend SOM correctly.

\item {} 
Updated the references to the SOM classes in docstrings and rst files.

\item {} 
Removed the \code{Review} class. And introduced the much handier Ticket class.
Now reviewing a data is the process of creating Ticket's to that data.

\item {} 
The database is now initialized with a StatusList and a couple of Statuses
appropriate for Ticket instances.

\item {} 
The database is now initialized with two Type instances (`Enhancement' and
`Defect') suitable for Ticket instances.

\item {} 
StatusMixin now stores the status attribute as an Integer showing the index
of the Status in the \code{status\_list} attribute but when asked for the value
of \code{StatusMixin.status} attribute it will return a proper Status instance
and the attribute can be set with an integer or with a proper Status
instance.

\end{itemize}


\chapter{TODO}
\label{todo:todo-toplevel}\label{todo:todo}\label{todo::doc}\begin{itemize}
\item {} 
Unicode:

All the string attributes should be unicode so for string attributes which
are checked against being a string should now be checked against being
unicode.

\item {} 
SCM Integration:

The repository can be a local path, and the project can be managed with an
SCM, preferably with Mercurial.

\item {} 
Per user settings file:

To let Pipeline TDs easily setup a new workstation with a setup script,
a predefined file let say with a name of ''.strc'' can be placed in to the
users home folder and Stalker can search for this file and parse it to get
things like the database server path, user name and the password.

There could be also an \$STRC environment variable which is showing a common
place lets say in the fileserver, which also may have a ''.strc'' file. In
this way it will be easy to setup only one ''.strc'' file for the whole studio.

\item {} 
\code{\_\_tablename\_\_} and \code{\_\_mapper\_args\_\_}:

The duty of the \code{\_\_tablename\_\_} and \code{\_\_mapper\_args\_\_} variables are
very common to any class in the SOM. It can be gathered in a mixin and the
\code{SimpleEntity} can be mixed with this class and
the rest will have their table name and polymorphic identity by default.

\item {} 
use pyseq for file sequence handling:

PySeq is a great, simple library which handles all the file sequence actions.
It would be great to use it in the \code{Link}
instances. So, the \code{Link} class can also hold a
string which can be uncompressed with the pyseq.uncompress function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyseq} \PYG{k+kn}{import} \PYG{n}{uncompress}
\PYG{n}{seq} \PYG{o}{=} \PYG{n}{uncompress}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{./tests/012\PYGZus{}vb\PYGZus{}110\PYGZus{}v001.}\PYG{l+s+si}{\PYGZpc{}04d}\PYG{l+s}{.png 1\PYGZhy{}10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                 \PYG{n}{format}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}h\PYGZpc{}}\PYG{l+s}{p}\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{t }\PYG{l+s+si}{\PYGZpc{}r}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

\item {} 
Update error messages:

Not all error message are clear. Generally, because of the heavy
inheritance, it is not very obvious which class gave the error. Writing down
the class name should help the user to understand at least what class is
giving the error message.

\item {} 
Hidden keyword arguments:

Because of the heavy inheritance, it is not very clear what parameters are
needed to initialize a class. A simple solution is to repeat all the
parameters of the inherited class in the \_\_init\_\_ of the child class.

\item {} 
Test CRUD:

The database tests should test if all the Create, Read, Update and Delete
operations are happening properly.

\end{itemize}


\chapter{DONE:}
\label{todo:done}\begin{itemize}
\item {} 
Plural name:

The plural name attribute needs to be reintroduced.

\item {} 
datetime instead of date

In the Task class all the time calculation should be done over the
datetime.datetime class instead of datetime.date object. This will let us
to increase the granularity of the scheduling.

\item {} 
\code{end\_date} attribute in ScheduleMixin:

there could be a synonym for the \code{due\_date} attribute in the
\code{ScheduleMixin}. Which will be meaningful for
\code{Booking} class.

\item {} 
Logging:

Use the Python logging module to output Debug messages.

\item {} 
StatusMixin and string indices:

StatusMixin should be able to set the status with a string, because it is
possible to use strings in StatusList.

\item {} 
Start \& End Date For Classes Mixed With TaskMixin:

All the classes which are mixed with TaskMixin should have a start and end
date attribute which will be set to the start date of the first task to the
due\_date of the last task.

\item {} 
Refactor target\_entity\_type attributes

StatusList, FilenameTemplate and Type classes are using the same
target\_entity\_type attribute, create a mixin for that.

\item {} 
OverBookingWarning:

Create a new Warning for the \code{Booking} class
which will be emitted when a resource is booked for the same time period
more than once.

\item {} 
Auto StatusList connection:

StatusLists can be automatically connected to the created instance if there
is already a database setup and a StatusList instance already defined for
the current class. This means mixing the model part with the control part
but it is acceptable.

\item {} 
Stop the fight between SimpleEntity.name and SimpleEntity.code.

Currently name superseeds code, but it is annoying to change the code over
and over again just because the name is changed. So change the behaviour to
something like that; the code is only updated to the same value with name if
it is set to None or empty string. In any other case the code should remain
in the same value.

\item {} 
SQLAlchemy ORM Declarative:

Use declarative for the whole system. It started to make no sense to use
classical approach with Python objects and it started to be very hard to try
to update all the relations which is handled automatically by SQLAlchemy.
Besides, the work done by all the attributes which are using ValidatedList
is replaced with a neat system whenever the mapping has occured. Which is
the usage case \%90 of the time.

Tests are going to be nearly the same. The only programming overhead is the
implementation itself.

Mixin classes also needs some attention, but as far as I see it is
successfully handled withing declarative approach.

\item {} 
``\_\_stalker\_version\_\_'' in SimpleEntity:

Create an attribute called \_\_stalker\_version\_\_ in the SimpleEntity, and
automatically update it to the current version string of Stalker to be able
to see with which version of Stalker this data is created, mainly important
for the database part.

\item {} 
Replace all the Mocker based tests with Unittest's which are using real
objects. It was necessary to use the Mocker library while designing the rest
of the system, but it is now making things complex and started to hide the
changes of one object from the others in the system.

\item {} 
Convert all the list comparison test to assertItemsEqual

\item {} 
Add a slot in the ValidatedList which will hold the callable for the
validation process when any of the objects are changed (set, remove, delete
etc.) to allow the callable to be called when something has changed. This
will allow more control on the list, e.g. this will help controling the
relation of the classes to each other.

\item {} 
Check FilenameTemplate class documentation.

\item {} 
Check database part of all the previous Type dependent classes (Link, Asset,
Project, Task)

\item {} 
Update the exceptions. Check if a proper exception is raised instead of
raising ValueErrors all the time.

\item {} 
A Status in StatusList should be accessed by its name used as the index

\item {} 
A status should be comparable with a string like project.status==''complete''
or project.status==''cmplt''

\item {} 
for an object which stores a list of other objects, stalker is validating if
the list is gathered from the correct type of objects, for example,
StatusList objects only accepts a list of Status objects. Stalker is able to
check if the elements in a list are Status objects when a list is assigned
to the StatusList.statuses attribute, but it can not check anything if the
list element is changed individually afterwards. This behaviour should be
extended with a validating system which is able to track changes on list
elements.

SOLUTION:
\begin{quote}

Added the ValidatedList list variant which does all the necessary things
explained in the problem.
\end{quote}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
