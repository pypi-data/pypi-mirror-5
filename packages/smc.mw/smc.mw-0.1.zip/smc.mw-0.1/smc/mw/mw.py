#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# CAVEAT UTILITOR
# This file was automatically generated by Grako.
#    https://bitbucket.org/apalala/grako/
# Any changes you make to it will be overwritten the
# next time the file is generated.
#

from __future__ import print_function, division, absolute_import, unicode_literals
from grako.parsing import * # @UnusedWildImport
from grako.exceptions import * # @UnusedWildImport

__version__ = '13.249.00.34.48'

class mwParser(Parser):
    def __init__(self, whitespace='', nameguard=False, **kwargs):
        super(mwParser, self).__init__(whitespace=whitespace,
            nameguard=nameguard, **kwargs)

    @rule_def
    def blank(self):
        with self._optional():
            self._pattern(r'[ \t]+')

    @rule_def
    def multiline_blank(self):
        def block0():
            with self._choice():
                with self._option():
                    self.empty_line()
                    self.check_bol_skip()
                with self._option():
                    self._pattern(r'[ \t]+')
                self._error('expecting one of: [ \t]+')
        self._closure(block0)

    @rule_def
    def document(self):
        def block1():
            with self._ifnot():
                self.empty_tail()
            self.document_block()
        self._closure(block1)
        self.ast['blocks'] = self.last_node
        with self._optional():
            self.empty_tail()
        self._check_eof()

    @rule_def
    def empty_tail(self):
        def block0():
            self.empty_line()
        self._closure(block0)
        self.blank()
        self._check_eof()

    @rule_def
    def document_block(self):
        with self._optional():
            self.empty_line()
        self.block()
        self.ast['@'] = self.last_node

    @rule_def
    def empty_line(self):
        self._pattern(r'[ \t]*\n')

    @rule_def
    def block(self):
        with self._group():
            with self._choice():
                with self._option():
                    self.block_not_par()
                with self._option():
                    self.paragraph()
                self._error('no available options')
        self._cut()

    @rule_def
    def block_not_par(self):
        with self._choice():
            with self._option():
                self.block_at_bol()
            with self._option():
                self.block_anywhere()
            self._error('no available options')

    @rule_def
    def block_at_bol(self):
        with self._if():
            self._pattern(r'^')
        with self._group():
            with self._choice():
                with self._option():
                    self.heading_block()
                with self._option():
                    self.horizontal_rule_block()
                with self._option():
                    self.table_block()
                with self._option():
                    self.list_block()
                with self._option():
                    self.toc_block()
                with self._option():
                    self.wspre_block()
                self._error('no available options')

    @rule_def
    def block_anywhere(self):
        with self._choice():
            with self._option():
                self.html_block()
            with self._option():
                self.html_block_no_wspre()
            with self._option():
                self.html_p()
            with self._option():
                self.pre()
            with self._option():
                self.html_heading()
            with self._option():
                self.html_table()
            with self._option():
                self.html_list()
            with self._option():
                self.html_dl()
            self._error('no available options')

    @rule_def
    def heading_block(self):
        with self._group():
            with self._choice():
                with self._option():
                    self.h6()
                with self._option():
                    self.h5()
                with self._option():
                    self.h4()
                with self._option():
                    self.h3()
                with self._option():
                    self.h2()
                with self._option():
                    self.h1()
                self._error('no available options')
        self.ast['@'] = self.last_node
        self.blank()
        with self._group():
            with self._choice():
                with self._option():
                    self._pattern(r'\n')
                with self._option():
                    self._check_eof()
                self._error('expecting one of: \n')
        def block2():
            self.empty_line()
        self._closure(block2)

    @rule_def
    def h6(self):
        self._token('======')
        self.push_no_h6()
        self.heading_inline()
        self.ast['@'] = self.last_node
        self.pop_no()
        self._token('======')

    @rule_def
    def h5(self):
        self._token('=====')
        self.push_no_h5()
        self.heading_inline()
        self.ast['@'] = self.last_node
        self.pop_no()
        self._token('=====')

    @rule_def
    def h4(self):
        self._token('====')
        self.push_no_h4()
        self.heading_inline()
        self.ast['@'] = self.last_node
        self.pop_no()
        self._token('====')

    @rule_def
    def h3(self):
        self._token('===')
        self.push_no_h3()
        self.heading_inline()
        self.ast['@'] = self.last_node
        self.pop_no()
        self._token('===')

    @rule_def
    def h2(self):
        self._token('==')
        self.push_no_h2()
        self.heading_inline()
        self.ast['@'] = self.last_node
        self.pop_no()
        self._token('==')

    @rule_def
    def h1(self):
        self._token('=')
        self.push_no_h1()
        self.heading_inline()
        self.ast['@'] = self.last_node
        self.pop_no()
        self._token('=')

    @rule_def
    def heading_inline(self):
        self.push_no_nl()
        self.heading_content()
        self.pop_no()

    @rule_def
    def heading_content(self):
        def block0():
            self.check_ifnots()
            self._pattern(r'(.|\n)')
        self._closure(block0)

    @rule_def
    def push_no_h6(self):
        pass

    @rule_def
    def push_no_h5(self):
        pass

    @rule_def
    def push_no_h4(self):
        pass

    @rule_def
    def push_no_h3(self):
        pass

    @rule_def
    def push_no_h2(self):
        pass

    @rule_def
    def push_no_h1(self):
        pass

    @rule_def
    def horizontal_rule_block(self):
        self._pattern(r'-{4,}')
        self.blank()
        with self._optional():
            self._pattern(r'\n')

    @rule_def
    def list_block(self):
        self.list_list()
        self.ast['@'] = self.last_node
        with self._group():
            with self._choice():
                with self._option():
                    self.list_newline()
                with self._option():
                    self._check_eof()
                self._error('no available options')

    @rule_def
    def list_list(self):
        with self._choice():
            with self._option():
                self.ul_block()
            with self._option():
                self.ol_block()
            with self._option():
                self.dl_block()
            self._error('no available options')

    @rule_def
    def list_newline(self):
        self._pattern(r'\n')
        self.check_bol_skip()

    @rule_def
    def ul_block(self):
        self._token('*')
        self.push_bol_skip_ul()
        self.list_li()
        self.ast.add_list('li', self.last_node)
        def block1():
            self.list_newline()
            self.list_li()
            self.ast['li'] = self.last_node
        self._closure(block1)
        self.pop_bol_skip()

    @rule_def
    def ol_block(self):
        self._token('#')
        self.push_bol_skip_ol()
        self.list_li()
        self.ast.add_list('li', self.last_node)
        def block1():
            self.list_newline()
            self.list_li()
            self.ast['li'] = self.last_node
        self._closure(block1)
        self.pop_bol_skip()

    @rule_def
    def dl_block(self):
        self._pattern(r'[;:]')
        self.push_bol_skip_dl()
        self.dt_or_dd()
        self.ast.add_list('li', self.last_node)
        def block1():
            self.list_newline()
            self.dt_or_dd()
            self.ast['li'] = self.last_node
        self._closure(block1)
        self.pop_bol_skip()

    @rule_def
    def push_bol_skip_ul(self):
        pass

    @rule_def
    def push_bol_skip_ol(self):
        pass

    @rule_def
    def push_bol_skip_dl(self):
        pass

    @rule_def
    def dt_or_dd(self):
        with self._choice():
            with self._option():
                self.dl_dt()
            with self._option():
                self.dl_dd()
            self._error('no available options')

    @rule_def
    def dl_dt(self):
        self._pattern(r'(?<=;)')
        self.list_dt()
        self.ast['@'] = self.last_node

    @rule_def
    def dl_dd(self):
        self._pattern(r'(?<=:)')
        self.list_li()
        self.ast['@'] = self.last_node

    @rule_def
    def list_li(self):
        with self._group():
            with self._choice():
                with self._option():
                    self.list_list()
                    self.ast.add_list('sublists', self.last_node)
                with self._option():
                    self.li_inline()
                    self.ast['inline'] = self.last_node
                self._error('no available options')
        def block3():
            self.list_sublist()
            self.ast.add_list('sublists', self.last_node)
        self._closure(block3)

    @rule_def
    def li_inline(self):
        self.push_no_nl()
        self.inline()
        self.ast['@'] = self.last_node
        self.pop_no()

    @rule_def
    def list_sublist(self):
        self.list_newline()
        self.list_list()
        self.ast['@'] = self.last_node

    @rule_def
    def list_dt(self):
        with self._group():
            with self._choice():
                with self._option():
                    self.list_list()
                    self.ast.add_list('sublists', self.last_node)
                    def block1():
                        self.list_sublist()
                        self.ast.add_list('sublists', self.last_node)
                    self._closure(block1)
                with self._option():
                    self.dt_inline_dd()
                    self.ast['inline_dd'] = self.last_node
                with self._option():
                    self.li_inline()
                    self.ast['inline'] = self.last_node
                    def block5():
                        self.list_sublist()
                        self.ast.add_list('sublists', self.last_node)
                    self._closure(block5)
                self._error('no available options')

    @rule_def
    def dt_inline_dd(self):
        self.push_no_nl()
        self.push_ifnot_dt()
        self.inline()
        self.ast['dt'] = self.last_node
        self.pop_ifnot()
        self._token(':')
        self.inline()
        self.ast['dd'] = self.last_node
        self.pop_no()

    @rule_def
    def push_ifnot_dt(self):
        pass

    @rule_def
    def wspre_block(self):
        self.check_wspre()
        with self._if():
            self._pattern(r'^')
        self._token(' ')
        with self._ifnot():
            self.empty_line()
        self.push_bol_skip_wspre()
        self.wspre_inline()
        self.ast['@'] = self.last_node
        self.pop_bol_skip()
        with self._group():
            with self._choice():
                with self._option():
                    self._pattern(r'\n')
                with self._option():
                    self._check_eof()
                self._error('expecting one of: \n')

    @rule_def
    def wspre_inline(self):
        def block1():
            with self._ifnot():
                self.block_anywhere()
            self.wspre_inline_one()
        self._positive_closure(block1)

        self.ast['content'] = self.last_node

    @rule_def
    def wspre_inline_one(self):
        with self._choice():
            with self._option():
                self.wspre_newline()
            with self._option():
                self.inline_impl_one_no_newline()
            self._error('no available options')

    @rule_def
    def wspre_newline(self):
        self.empty_line()
        self.ast['@'] = self.last_node
        self.check_bol_skip()

    @rule_def
    def push_bol_skip_wspre(self):
        pass

    @rule_def
    def push_wspre_off(self):
        pass

    @rule_def
    def pop_wspre(self):
        pass

    @rule_def
    def set_wspre_on(self):
        pass

    @rule_def
    def check_wspre(self):
        pass

    @rule_def
    def check_ifnots(self):
        self.check_ifnot()
        self.check_no()

    @rule_def
    def pop_ifnot(self):
        pass

    @rule_def
    def check_ifnot(self):
        pass

    @rule_def
    def pop_no(self):
        pass

    @rule_def
    def check_no(self):
        pass

    @rule_def
    def push_no_nl(self):
        pass

    @rule_def
    def pop_bol_skip(self):
        pass

    @rule_def
    def check_bol_skip(self):
        pass

    @rule_def
    def toc_block(self):
        with self._choice():
            with self._option():
                self.toc()
            with self._option():
                self.notoc()
            with self._option():
                self.forcetoc()
            self._error('no available options')

    @rule_def
    def toc(self):
        self.blank()
        self._token('__TOC__')
        self.blank()
        with self._group():
            with self._choice():
                with self._option():
                    self._pattern(r'\n')
                with self._option():
                    self._check_eof()
                self._error('expecting one of: \n')

    @rule_def
    def notoc(self):
        self.blank()
        self._token('__NOTOC__')
        self.blank()
        with self._group():
            with self._choice():
                with self._option():
                    self._pattern(r'\n')
                with self._option():
                    self._check_eof()
                self._error('expecting one of: \n')

    @rule_def
    def forcetoc(self):
        self.blank()
        self._token('__FORCETOC__')
        self.blank()
        with self._group():
            with self._choice():
                with self._option():
                    self._pattern(r'\n')
                with self._option():
                    self._check_eof()
                self._error('expecting one of: \n')

    @rule_def
    def table_attribute_junk(self):
        def block0():
            with self._ifnot():
                self.html_attribute()
            self._pattern(r'[^ \t\n]*')
            self._pattern(r'[ \t]+')
        self._closure(block0)

    @rule_def
    def table_attribute_one(self):
        self.html_attribute()
        self.ast['@'] = self.last_node
        with self._optional():
            self.table_attribute_junk()

    @rule_def
    def table_attributes(self):
        with self._optional():
            self.table_attribute_junk()
        def block0():
            self.table_attribute_one()
        self._closure(block0)
        self.ast['@'] = self.last_node

    @rule_def
    def table_cell_attribute_junk(self):
        def block0():
            with self._ifnot():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('|')
                        with self._option():
                            self.html_attribute()
                        self._error('expecting one of: |')
            self._pattern(r'[^| \t\n]*')
            self._pattern(r'[ \t]+')
        self._closure(block0)

    @rule_def
    def table_cell_attribute_one(self):
        self.html_attribute()
        self.ast['@'] = self.last_node
        with self._optional():
            self.table_cell_attribute_junk()

    @rule_def
    def table_cell_attributes(self):
        with self._optional():
            self.table_cell_attribute_junk()
        def block0():
            self.table_cell_attribute_one()
        self._closure(block0)
        self.ast['@'] = self.last_node

    @rule_def
    def table_header_attribute_junk(self):
        def block0():
            with self._ifnot():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('|')
                        with self._option():
                            self._token('!!')
                        with self._option():
                            self._token('||')
                        with self._option():
                            self.html_attribute()
                        self._error('expecting one of: || | !!')
            self._pattern(r'(?:[^|! \t\n]+|!(?!!))*')
            self._pattern(r'[ \t]+')
        self._closure(block0)

    @rule_def
    def table_header_attribute_one(self):
        self.html_attribute()
        self.ast['@'] = self.last_node
        with self._optional():
            self.table_header_attribute_junk()

    @rule_def
    def table_header_attributes(self):
        with self._optional():
            self.table_header_attribute_junk()
        def block0():
            self.table_header_attribute_one()
        self._closure(block0)
        self.ast['@'] = self.last_node

    @rule_def
    def table_block(self):
        self.blank()
        self._pattern(r':*')
        self.ast['indent'] = self.last_node
        self._token('{|')
        self.table_attributes()
        self.ast['attribs'] = self.last_node
        with self._optional():
            def block2():
                self.empty_line()
            self._positive_closure(block2)

            with self._optional():
                self.table_caption()
                self.ast['caption'] = self.last_node
            self.table_rows()
            self.ast['rows'] = self.last_node
        self.blank()
        self._token('|}')
        self.blank()
        with self._group():
            with self._choice():
                with self._option():
                    self._pattern(r'\n')
                with self._option():
                    self._check_eof()
                self._error('expecting one of: \n')

    @rule_def
    def table_caption(self):
        self.blank()
        self._token('|+')
        with self._optional():
            self.table_cell_attributes()
            self.ast['attribs'] = self.last_node
            self.blank()
            self._token('|')
        self.table_mode_document()
        self.ast['content'] = self.last_node

    @rule_def
    def table_rows(self):
        with self._optional():
            self.table_row_first()
            self.ast['first'] = self.last_node
        def block2():
            self.table_row()
        self._closure(block2)
        self.ast['rest'] = self.last_node

    @rule_def
    def table_row_first(self):
        def block1():
            with self._choice():
                with self._option():
                    self.table_data()
                with self._option():
                    self.table_header()
                self._error('no available options')
        self._positive_closure(block1)

        self.ast['content'] = self.last_node

    @rule_def
    def table_row(self):
        self.blank()
        self._pattern(r'\|-+')
        self.table_attributes()
        self.ast['attribs'] = self.last_node
        self.blank()
        self._pattern(r'\n+')
        def block2():
            with self._choice():
                with self._option():
                    self.table_data()
                with self._option():
                    self.table_header()
                self._error('no available options')
        self._closure(block2)
        self.ast['content'] = self.last_node

    @rule_def
    def table_header(self):
        self.blank()
        self._token('!')
        self.push_no_nl()
        def block1():
            self.table_header_cell_inline()
        self._closure(block1)
        self.ast['inline'] = self.last_node
        self.pop_no()
        self.table_header_cell()
        self.ast['final'] = self.last_node

    @rule_def
    def table_header_cell_inline(self):
        with self._optional():
            self.table_header_attributes()
            self.ast['attribs'] = self.last_node
            self.blank()
            self._token('|')
        self.blank()
        self.push_ifnot_table_header()
        self.inline()
        self.ast['text'] = self.last_node
        self.pop_ifnot()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('!!')
                with self._option():
                    self._token('||')
                self._error('expecting one of: || !!')

    @rule_def
    def table_header_cell(self):
        with self._optional():
            self.table_cell_attributes()
            self.ast['attribs'] = self.last_node
            self.blank()
            self._token('|')
        self.blank()
        self.table_mode_document()
        self.ast['content'] = self.last_node

    @rule_def
    def push_ifnot_table_header(self):
        pass

    @rule_def
    def table_data(self):
        self.blank()
        self._token('|')
        with self._ifnot():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('}')
                    with self._option():
                        self._token('-')
                    self._error('expecting one of: - }')
        self.push_no_nl()
        def block2():
            self.table_data_cell_inline()
        self._closure(block2)
        self.ast['inline'] = self.last_node
        self.pop_no()
        with self._optional():
            self.table_data_cell()
            self.ast['final'] = self.last_node

    @rule_def
    def table_data_cell_inline(self):
        with self._optional():
            self.table_cell_attributes()
            self.ast['attribs'] = self.last_node
            self.blank()
            self._token('|')
            with self._ifnot():
                self._token('|')
        self.blank()
        self.push_ifnot_table_data()
        self.inline()
        self.ast['text'] = self.last_node
        self.pop_ifnot()
        self._token('||')

    @rule_def
    def table_data_cell(self):
        with self._optional():
            self.table_cell_attributes()
            self.ast['attribs'] = self.last_node
            self.blank()
            self._token('|')
            with self._ifnot():
                self._token('|')
        self.blank()
        with self._optional():
            self.empty_line()
        self.table_mode_document()
        self.ast['content'] = self.last_node

    @rule_def
    def push_ifnot_table_data(self):
        pass

    @rule_def
    def table_mode_document(self):
        self.push_no_tableline()
        def block1():
            with self._ifnot():
                with self._group():
                    with self._choice():
                        with self._option():
                            self.blank()
                            self._token('|')
                        with self._option():
                            self.blank()
                            self._token('!')
                        self._error('no available options')
            self.document_block()
        self._closure(block1)
        self.ast['blocks'] = self.last_node
        self.pop_no()

    @rule_def
    def push_no_tableline(self):
        pass

    @rule_def
    def non_special_chars(self):
        self._pattern(r'((?!(http://|https://|ftp://|telnet://|irc://|ircs://|nntp://|worldwind://|mailto:|news:|svn://|git://|mms://))[^\n\[\]{\'"|=<&!:])+')

    @rule_def
    def paragraph(self):
        with self._choice():
            with self._option():
                self.paragraph_only_br()
            with self._option():
                self.paragraph_impl()
            self._error('no available options')

    @rule_def
    def paragraph_only_br(self):
        self.empty_line()
        with self._group():
            with self._choice():
                with self._option():
                    self.empty_line()
                with self._option():
                    with self._if():
                        self.block_not_par()
                with self._option():
                    with self._ifnot():
                        self.check_ifnots()
                self._error('no available options')

    @rule_def
    def paragraph_impl(self):
        with self._optional():
            self.paragraph_br()
            self.ast.add_list('content', self.last_node)
        def block1():
            with self._ifnot():
                self.block_anywhere()
            self.inline_impl_one()
            self.ast.add_list('content', self.last_node)
        self._positive_closure(block1)

        with self._optional():
            self.empty_line()
            self.ast.add_list('content', self.last_node)

    @rule_def
    def paragraph_br(self):
        self.empty_line()

    @rule_def
    def inline(self):
        def block0():
            with self._ifnot():
                self.block_anywhere()
            self.inline_impl_one()
        self._closure(block0)

    @rule_def
    def inline_impl_one(self):
        self.check_ifnots()
        with self._group():
            with self._choice():
                with self._option():
                    self.inline_newline()
                with self._option():
                    self.inline_impl_one_no_newline()
                self._error('no available options')

    @rule_def
    def inline_impl_one_no_newline(self):
        with self._choice():
            with self._option():
                self.non_special_chars()
            with self._option():
                self.internal_link()
            with self._option():
                self.external_link()
            with self._option():
                self.plain_link()
            with self._option():
                self.many_quotes()
            with self._option():
                self.bold_and_italic()
            with self._option():
                self.bold()
            with self._option():
                self.italic()
            with self._option():
                self.html_inline()
            with self._option():
                self.html_entity()
            with self._option():
                self.ref()
            with self._option():
                self.nowiki()
            with self._option():
                self.comment()
            with self._option():
                self._pattern(r'.')
            self._error('expecting one of: .')

    @rule_def
    def inline_newline(self):
        self.empty_line()
        self.check_bol_skip()
        with self._ifnot():
            self.empty_line()
        with self._ifnot():
            self.block_not_par()

    @rule_def
    def internal_link_trail(self):
        self._pattern(r"([a-zA-Z]|'(?!'))+")

    @rule_def
    def internal_link(self):
        self._token('[[')
        self.blank()
        self.push_ifnot_intlink_target()
        self.inline()
        self.ast['target'] = self.last_node
        self.pop_ifnot()
        self.blank()
        with self._optional():
            self._token('|')
            self.push_wspre_off()
            self.push_ifnot_intlink()
            self.multiline_blank()
            self.inline()
            self.ast['text'] = self.last_node
            self.pop_ifnot()
            self.pop_wspre()
        self._token(']]')
        with self._optional():
            self.internal_link_trail()
            self.ast['suffix'] = self.last_node

    @rule_def
    def push_ifnot_intlink_target(self):
        pass

    @rule_def
    def push_ifnot_intlink(self):
        pass

    @rule_def
    def link_tail_chars_no_parens(self):
        self._pattern(r'[,;\.:!\?\(\)]+')

    @rule_def
    def link_tail_chars(self):
        self._pattern(r'[,;\.:!\?]+')

    @rule_def
    def link_terminators(self):
        with self._choice():
            with self._option():
                self._pattern(r'[\n\[\] \t]')
            with self._option():
                self._check_eof()
            self._error('expecting one of: [\n\\[\\] \t]')

    @rule_def
    def link_normal_chars_no_parens(self):
        self._pattern(r'[^&,;\.:!\?\(\)\n\[\] \t]+')

    @rule_def
    def link_normal_chars(self):
        self._pattern(r'[^&,;\.:!\?\n\[\] \t]+')

    @rule_def
    def more_link_chars_no_parens(self):
        def block0():
            with self._choice():
                with self._option():
                    self.link_normal_chars_no_parens()
                with self._option():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self.link_tail_chars_no_parens()
                            with self._option():
                                self.html_entity()
                            self._error('no available options')
                    with self._ifnot():
                        self.link_terminators()
                with self._option():
                    self._token('&')
                self._error('expecting one of: &')
        self._positive_closure(block0)

        with self._ifnot():
            self._token('(')

    @rule_def
    def more_link_chars_parens(self):
        def block0():
            with self._choice():
                with self._option():
                    self.link_normal_chars_no_parens()
                with self._option():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self.link_tail_chars()
                            with self._option():
                                self.html_entity()
                            self._error('no available options')
                    with self._ifnot():
                        self.link_terminators()
                with self._option():
                    self._token('&')
                self._error('expecting one of: &')
        self._positive_closure(block0)

    @rule_def
    def more_link_chars(self):
        with self._choice():
            with self._option():
                self.more_link_chars_no_parens()
            with self._option():
                self.more_link_chars_parens()
            self._error('no available options')

    @rule_def
    def link_chars(self):
        self._pattern(r'(http://|https://|ftp://|telnet://|irc://|ircs://|nntp://|worldwind://|mailto:|news:|svn://|git://|mms://|//)')
        self.more_link_chars()

    @rule_def
    def external_link(self):
        self._token('[')
        self.push_ifnot_extlink()
        self.link_chars()
        self.ast['target'] = self.last_node
        self.blank()
        with self._optional():
            self.push_no_nl()
            self.inline()
            self.ast['text'] = self.last_node
            self.pop_no()
        self.pop_ifnot()
        self._token(']')

    @rule_def
    def push_ifnot_extlink(self):
        pass

    @rule_def
    def plain_link(self):
        self._pattern(r'(?=\b)(http://|https://|ftp://|telnet://|irc://|ircs://|nntp://|worldwind://|mailto:|news:|svn://|git://|mms://)')
        self.more_link_chars()

    @rule_def
    def many_quotes(self):
        with self._choice():
            with self._option():
                self._token("'")
                with self._if():
                    self._token("'''''")
            with self._option():
                self._token("'")
                with self._if():
                    with self._group():
                        self._token("'''")
                        with self._ifnot():
                            self._token("'")
            self._error("expecting one of: '")

    @rule_def
    def bold(self):
        self._token("'''")
        with self._ifnot():
            self._token("'")
        self.push_no_nl()
        self.bold_inline()
        self.ast['content'] = self.last_node
        self.pop_no()
        with self._group():
            with self._choice():
                with self._option():
                    self._token("'''")
                with self._option():
                    with self._if():
                        self._pattern(r'\n')
                with self._option():
                    self._check_eof()
                self._error("expecting one of: ''' \n")

    @rule_def
    def bold_inline(self):
        def block0():
            with self._group():
                with self._choice():
                    with self._option():
                        with self._if():
                            self.many_quotes()
                    with self._option():
                        with self._ifnot():
                            self._token("'''")
                    self._error("expecting one of: '''")
            self.inline_impl_one()
        self._closure(block0)

    @rule_def
    def italic(self):
        self._token("''")
        with self._ifnot():
            self._token("'")
        self.push_no_nl()
        self.italic_inline()
        self.ast['content'] = self.last_node
        self.pop_no()
        with self._group():
            with self._choice():
                with self._option():
                    self._token("''")
                with self._option():
                    with self._if():
                        self._pattern(r'\n')
                with self._option():
                    self._check_eof()
                self._error("expecting one of: '' \n")

    @rule_def
    def italic_inline(self):
        def block0():
            with self._group():
                with self._choice():
                    with self._option():
                        with self._if():
                            self.many_quotes()
                    with self._option():
                        with self._group():
                            with self._if():
                                self._token("'''")
                            with self._ifnot():
                                self._token("'''''")
                    with self._option():
                        with self._ifnot():
                            with self._group():
                                with self._choice():
                                    with self._option():
                                        self._token("''")
                                    with self._option():
                                        self._token("'''''")
                                    self._error("expecting one of: '' '''''")
                    self._error("expecting one of: ''' '' '''''")
            self.inline_impl_one()
        self._closure(block0)

    @rule_def
    def bold_and_italic(self):
        with self._choice():
            with self._option():
                self.bold_italic_both()
            with self._option():
                self.italic_bold()
            with self._option():
                self.bold_italic()
            self._error('no available options')

    @rule_def
    def bold_italic_both(self):
        self._token("'''''")
        self.push_no_nl()
        self.bold_italic_inline()
        self.ast['content'] = self.last_node
        self.pop_no()
        with self._group():
            with self._choice():
                with self._option():
                    self._token("'''''")
                with self._option():
                    with self._if():
                        self._pattern(r'\n')
                with self._option():
                    self._check_eof()
                self._error("expecting one of: \n '''''")

    @rule_def
    def italic_bold(self):
        self._token("'''''")
        self.push_no_nl()
        self.bold_italic_inline()
        self.ast['bold_content'] = self.last_node
        self._token("'''")
        self.italic_inline()
        self.ast['italic_content'] = self.last_node
        self.pop_no()
        with self._group():
            with self._choice():
                with self._option():
                    self._token("''")
                with self._option():
                    with self._if():
                        self._pattern(r'\n')
                with self._option():
                    self._check_eof()
                self._error("expecting one of: '' \n")

    @rule_def
    def bold_italic(self):
        self._token("'''''")
        self.push_no_nl()
        self.bold_italic_inline()
        self.ast['italic_content'] = self.last_node
        self._token("''")
        self.bold_inline()
        self.ast['bold_content'] = self.last_node
        self.pop_no()
        with self._group():
            with self._choice():
                with self._option():
                    self._token("'''")
                with self._option():
                    with self._if():
                        self._pattern(r'\n')
                with self._option():
                    self._check_eof()
                self._error("expecting one of: ''' \n")

    @rule_def
    def bold_italic_inline(self):
        def block0():
            with self._group():
                with self._choice():
                    with self._option():
                        with self._if():
                            self.many_quotes()
                    with self._option():
                        with self._ifnot():
                            self._token("''")
                    self._error("expecting one of: ''")
            self.inline_impl_one()
        self._closure(block0)

    @rule_def
    def comment(self):
        self._pattern(r'<!--(.|\n)*?-->')

    @rule_def
    def html_entity(self):
        self._token('&')
        with self._group():
            with self._choice():
                with self._option():
                    self.html_named_entity()
                with self._option():
                    self.html_numbered_entity()
                self._error('no available options')
        self.ast['@'] = self.last_node
        self._token(';')

    @rule_def
    def html_named_entity(self):
        self._pattern(r'[a-zA-Z0-9]+')
        self.ast['name'] = self.last_node

    @rule_def
    def html_numbered_entity(self):
        self._token('#')
        with self._group():
            with self._choice():
                with self._option():
                    self._pattern(r'[0-9]+')
                    self.ast['number'] = self.last_node
                with self._option():
                    self._pattern(r'[xX]')
                    self._pattern(r'[0-9a-fA-F]+')
                    self.ast['hexnumber'] = self.last_node
                self._error('expecting one of: [xX] [0-9]+')

    @rule_def
    def html_attribute_value_doublequote(self):
        self._token('"')
        def block0():
            with self._choice():
                with self._option():
                    self._pattern(r'[^<"&]+')
                with self._option():
                    self.html_entity()
                with self._option():
                    self._token('&')
                self._error('expecting one of: & [^<"&]+')
        self._closure(block0)
        self.ast['@'] = self.last_node
        self._token('"')

    @rule_def
    def html_attribute_value_singlequote(self):
        self._token("'")
        def block0():
            with self._choice():
                with self._option():
                    self._pattern(r"[^<'&]+")
                with self._option():
                    self.html_entity()
                with self._option():
                    self._token('&')
                self._error("expecting one of: & [^<'&]+")
        self._closure(block0)
        self.ast['@'] = self.last_node
        self._token("'")

    @rule_def
    def html_attribute_value_noquote(self):
        def block0():
            with self._choice():
                with self._option():
                    self._pattern(r'[a-zA-Z0-9!#$%()*,\-./:;<>?@[\]^_`{|}~]+')
                with self._option():
                    self.html_entity()
                with self._option():
                    self._token('&')
                self._error('expecting one of: & [a-zA-Z0-9!#$%()*,\\-./:;<>?@[\\]^_`{|}~]+')
        self._positive_closure(block0)

    @rule_def
    def html_attribute_value(self):
        with self._choice():
            with self._option():
                self.html_attribute_value_doublequote()
            with self._option():
                self.html_attribute_value_singlequote()
            with self._option():
                self.html_attribute_value_noquote()
            self._error('no available options')

    @rule_def
    def html_attribute(self):
        self.html_attribute_name()
        self.ast['name'] = self.last_node
        self.multiline_blank()
        self._token('=')
        self.multiline_blank()
        self.html_attribute_value()
        self.ast['value'] = self.last_node

    @rule_def
    def html_attribute_junk(self):
        def block0():
            with self._ifnot():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('/>')
                        with self._option():
                            self._token('>')
                        with self._option():
                            self.html_attribute()
                        self._error('expecting one of: > />')
            self._pattern(r'(?:[^/<> \t\n]+|/(?!>))*')
            self._pattern(r'[ \t\n]+')
        self._closure(block0)

    @rule_def
    def html_attribute_name(self):
        self._pattern(r'[:A-Z_a-z0-9][:A-Z_a-z0-9\-.]*')

    @rule_def
    def html_attribute_one(self):
        self.html_attribute()
        self.ast['@'] = self.last_node
        with self._optional():
            self.html_attribute_junk()

    @rule_def
    def html_attributes(self):
        with self._optional():
            self.html_attribute_junk()
        def block0():
            self.html_attribute_one()
        self._closure(block0)
        self.ast['@'] = self.last_node

    @rule_def
    def html_inline(self):
        self._token('<')
        with self._if():
            self.html_inline_element()
        self.push_ifnot_html_tag()
        self.ast['name'] = self.last_node
        self.html_attributes()
        self.ast['attribs'] = self.last_node
        self.multiline_blank()
        self.html_attribute_junk()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/>')
                with self._option():
                    self._token('>')
                    self.inline()
                    self.ast['content'] = self.last_node
                    with self._optional():
                        with self._ifnot():
                            self.check_ifnot()
                        self._pattern(r'</\w+[ \t\n]*>')
                self._error('expecting one of: />')
        self.pop_ifnot()

    @rule_def
    def push_ifnot_html_tag(self):
        self._pattern(r'\w+')

    @rule_def
    def html_inline_element(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token('abbr')
                with self._option():
                    self._token('br')
                with self._option():
                    self._token('big')
                with self._option():
                    self._token('b')
                with self._option():
                    self._token('cite')
                with self._option():
                    self._token('code')
                with self._option():
                    self._token('data')
                with self._option():
                    self._token('del')
                with self._option():
                    self._token('dfn')
                with self._option():
                    self._token('em')
                with self._option():
                    self._token('font')
                with self._option():
                    self._token('ins')
                with self._option():
                    self._token('i')
                with self._option():
                    self._token('kbd')
                with self._option():
                    self._token('mark')
                with self._option():
                    self._token('samp')
                with self._option():
                    self._token('small')
                with self._option():
                    self._token('span')
                with self._option():
                    self._token('strong')
                with self._option():
                    self._token('sub')
                with self._option():
                    self._token('sup')
                with self._option():
                    self._token('strike')
                with self._option():
                    self._token('s')
                with self._option():
                    self._token('time')
                with self._option():
                    self._token('tt')
                with self._option():
                    self._token('u')
                with self._option():
                    self._token('var')
                self._error('expecting one of: mark abbr samp br tt cite u b big span sub s strong dfn kbd del ins em font data sup i code time var strike small')
        with self._ifnot():
            self._pattern(r'\w')

    @rule_def
    def nowiki(self):
        self._token('<')
        with self._if():
            self.nowiki_element()
        self.push_ifnot_html_tag()
        self.ast['name'] = self.last_node
        self.html_attributes()
        self.ast['attribs'] = self.last_node
        self.multiline_blank()
        self.html_attribute_junk()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/>')
                with self._option():
                    self._token('>')
                    self.nowiki_inline()
                    self.ast['content'] = self.last_node
                    with self._optional():
                        with self._ifnot():
                            self.check_ifnot()
                        self._pattern(r'</\w+[ \t\n]*>')
                self._error('expecting one of: />')
        self.pop_ifnot()

    @rule_def
    def nowiki_element(self):
        with self._group():
            self._token('nowiki')
        with self._ifnot():
            self._pattern(r'\w')

    @rule_def
    def nowiki_inline(self):
        def block0():
            self.check_ifnot()
            with self._group():
                with self._choice():
                    with self._option():
                        self.html_entity()
                    with self._option():
                        self.nowiki_non_special_chars()
                    with self._option():
                        self._pattern(r'.')
                    self._error('expecting one of: .')
        self._closure(block0)

    @rule_def
    def nowiki_non_special_chars(self):
        self._pattern(r'[^<&]+')

    @rule_def
    def pre_nowiki(self):
        self._token('<')
        with self._if():
            self.nowiki_element()
        self.push_ifnot_html_tag()
        self.ast['name'] = self.last_node
        self.html_attributes()
        self.ast['attribs'] = self.last_node
        self.multiline_blank()
        self.html_attribute_junk()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/>')
                with self._option():
                    self._token('>')
                    self.pre_nowiki_inline()
                    self.ast['content'] = self.last_node
                    with self._ifnot():
                        self.check_ifnot()
                    self._pattern(r'</\w+[ \t\n]*>')
                self._error('expecting one of: />')
        self.pop_ifnot()

    @rule_def
    def pre_nowiki_inline(self):
        def block0():
            self.check_ifnot()
            with self._ifnot():
                self._pattern(r'</pre[ \t\n]*>')
            with self._group():
                with self._choice():
                    with self._option():
                        self.html_entity()
                    with self._option():
                        self.nowiki_non_special_chars()
                    with self._option():
                        self._pattern(r'.')
                    self._error('expecting one of: .')
        self._closure(block0)

    @rule_def
    def pre(self):
        self._token('<')
        with self._if():
            self.pre_element()
        self.push_ifnot_html_tag()
        self.ast['name'] = self.last_node
        self.html_attributes()
        self.ast['attribs'] = self.last_node
        self.multiline_blank()
        self.html_attribute_junk()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/>')
                with self._option():
                    self._token('>')
                    self.pre_inline()
                    self.ast['content'] = self.last_node
                    with self._optional():
                        with self._ifnot():
                            self.check_ifnot()
                        self._pattern(r'</\w+[ \t\n]*>')
                self._error('expecting one of: />')
        self.pop_ifnot()
        with self._optional():
            self.empty_line()

    @rule_def
    def pre_element(self):
        self._pattern(r'(?i)(?:pre)(?!\w)')

    @rule_def
    def pre_non_special_chars(self):
        self._pattern(r'[^<&]+')

    @rule_def
    def pre_inline(self):
        def block0():
            self.check_ifnot()
            with self._group():
                with self._choice():
                    with self._option():
                        self.html_entity()
                    with self._option():
                        self.pre_nowiki()
                    with self._option():
                        self.pre_non_special_chars()
                    with self._option():
                        self._pattern(r'.')
                    self._error('expecting one of: .')
        self._closure(block0)

    @rule_def
    def ref(self):
        self._token('<')
        with self._if():
            self.ref_element()
        self.push_ifnot_html_tag()
        self.ast['name'] = self.last_node
        self.html_attributes()
        self.ast['attribs'] = self.last_node
        self.multiline_blank()
        self.html_attribute_junk()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/>')
                with self._option():
                    self._token('>')
                    self.html_block_no_wspre_document()
                    self.ast['content'] = self.last_node
                    with self._optional():
                        with self._ifnot():
                            self.check_ifnot()
                        self._pattern(r'</\w+[ \t\n]*>')
                self._error('expecting one of: />')
        self.pop_ifnot()
        with self._optional():
            self.empty_line()

    @rule_def
    def ref_element(self):
        self._pattern(r'(?i)(?:ref)(?!\w)')

    @rule_def
    def html_heading(self):
        self.blank()
        self._token('<')
        with self._if():
            self.html_heading_element()
        self.push_ifnot_html_tag()
        self.ast['name'] = self.last_node
        self.html_attributes()
        self.ast['attribs'] = self.last_node
        self.multiline_blank()
        self.html_attribute_junk()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/>')
                with self._option():
                    self._token('>')
                    self.heading_content()
                    self.ast['content'] = self.last_node
                    with self._optional():
                        with self._ifnot():
                            self.check_ifnot()
                        self._pattern(r'</\w+[ \t\n]*>')
                self._error('expecting one of: />')
        self.pop_ifnot()
        with self._optional():
            self.empty_line()

    @rule_def
    def html_heading_element(self):
        self._pattern(r'(?i)(?:h[1-6])(?!\w)')

    @rule_def
    def html_block(self):
        self.blank()
        self._token('<')
        with self._if():
            self.html_block_element()
        self.push_ifnot_html_tag()
        self.ast['name'] = self.last_node
        self.html_attributes()
        self.ast['attribs'] = self.last_node
        self.multiline_blank()
        self.html_attribute_junk()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/>')
                with self._option():
                    self._token('>')
                    self.html_block_document()
                    self.ast['content'] = self.last_node
                    with self._optional():
                        with self._ifnot():
                            self.check_ifnot()
                        self._pattern(r'</\w+[ \t\n]*>')
                self._error('expecting one of: />')
        self.pop_ifnot()
        with self._optional():
            self.empty_line()

    @rule_def
    def html_block_document(self):
        def block1():
            self.document_block()
        self._closure(block1)
        self.ast['blocks'] = self.last_node

    @rule_def
    def html_block_element(self):
        self._pattern(r'(?i)(?:center|div|references)(?!\w)')

    @rule_def
    def html_block_no_wspre(self):
        self.blank()
        self._token('<')
        with self._if():
            self.html_block_no_wspre_element()
        self.push_ifnot_html_tag()
        self.ast['name'] = self.last_node
        self.html_attributes()
        self.ast['attribs'] = self.last_node
        self.multiline_blank()
        self.html_attribute_junk()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/>')
                with self._option():
                    self._token('>')
                    self.html_block_no_wspre_document()
                    self.ast['content'] = self.last_node
                    with self._optional():
                        with self._ifnot():
                            self.check_ifnot()
                        self._pattern(r'</\w+[ \t\n]*>')
                self._error('expecting one of: />')
        self.pop_ifnot()
        with self._optional():
            self.empty_line()

    @rule_def
    def html_block_no_wspre_element(self):
        self._pattern(r'(?i)(?:blockquote)(?!\w)')

    @rule_def
    def html_block_no_wspre_document(self):
        self.push_wspre_off()
        def block1():
            self.document_block()
        self._closure(block1)
        self.ast['blocks'] = self.last_node
        self.pop_wspre()

    @rule_def
    def html_p(self):
        self.blank()
        self._token('<')
        with self._if():
            self.html_p_element()
        self.push_ifnot_html_tag()
        self.ast['name'] = self.last_node
        self.html_attributes()
        self.ast['attribs'] = self.last_node
        self.multiline_blank()
        self.html_attribute_junk()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/>')
                with self._option():
                    self._token('>')
                    self.html_p_inline()
                    self.ast['content'] = self.last_node
                    with self._optional():
                        with self._ifnot():
                            self.check_ifnot()
                        self._pattern(r'</\w+[ \t\n]*>')
                self._error('expecting one of: />')
        self.pop_ifnot()
        with self._optional():
            self.empty_line()

    @rule_def
    def html_p_element(self):
        self._pattern(r'(?i)(?:p)(?!\w)')

    @rule_def
    def html_p_inline(self):
        self.push_wspre_off()
        def block0():
            with self._ifnot():
                self.block_anywhere()
            self.inline_impl_one()
        self._closure(block0)
        self.pop_wspre()

    @rule_def
    def html_table(self):
        self.blank()
        self._token('<')
        with self._if():
            self.html_table_element()
        self.push_ifnot_html_tag()
        self.ast['name'] = self.last_node
        self.html_attributes()
        self.ast['attribs'] = self.last_node
        self.multiline_blank()
        self.html_attribute_junk()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/>')
                with self._option():
                    self._token('>')
                    self.html_table_content()
                    self.ast['content'] = self.last_node
                    with self._optional():
                        with self._ifnot():
                            self.check_ifnot()
                        self._pattern(r'</\w+[ \t\n]*>')
                self._error('expecting one of: />')
        self.pop_ifnot()
        with self._optional():
            self.empty_line()

    @rule_def
    def html_table_element(self):
        self._pattern(r'(?i)(?:table)(?!\w)')

    @rule_def
    def html_table_content(self):
        def block0():
            self.html_table_content_item()
        self._closure(block0)

    @rule_def
    def html_table_content_item(self):
        self.multiline_blank()
        self.html_table_tr()
        self.ast['@'] = self.last_node

    @rule_def
    def html_table_tr(self):
        self._token('<')
        with self._if():
            self.html_table_tr_element()
        self.push_ifnot_html_tag()
        self.ast['name'] = self.last_node
        self.html_attributes()
        self.ast['attribs'] = self.last_node
        self.multiline_blank()
        self.html_attribute_junk()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/>')
                with self._option():
                    self._token('>')
                    self.html_table_tr_content()
                    self.ast['content'] = self.last_node
                    with self._optional():
                        with self._ifnot():
                            self.check_ifnot()
                        self._pattern(r'</\w+[ \t\n]*>')
                self._error('expecting one of: />')
        self.pop_ifnot()
        with self._optional():
            self.empty_line()

    @rule_def
    def html_table_tr_element(self):
        self._pattern(r'(?i)(?:tr)(?!\w)')

    @rule_def
    def html_table_tr_content(self):
        def block0():
            self.html_table_tr_content_item()
        self._closure(block0)

    @rule_def
    def html_table_tr_content_item(self):
        self.multiline_blank()
        with self._group():
            self.html_table_cell()
        self.ast['@'] = self.last_node

    @rule_def
    def html_table_cell(self):
        self._token('<')
        with self._if():
            self.html_table_cell_element()
        self.push_ifnot_html_tag()
        self.ast['name'] = self.last_node
        self.html_attributes()
        self.ast['attribs'] = self.last_node
        self.multiline_blank()
        self.html_attribute_junk()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/>')
                with self._option():
                    self._token('>')
                    self.html_block_document()
                    self.ast['content'] = self.last_node
                    with self._optional():
                        with self._ifnot():
                            self.check_ifnot()
                        self._pattern(r'</\w+[ \t\n]*>')
                self._error('expecting one of: />')
        self.pop_ifnot()
        with self._optional():
            self.empty_line()

    @rule_def
    def html_table_cell_element(self):
        self._pattern(r'(?i)(?:td|th)(?!\w)')

    @rule_def
    def html_list(self):
        self._token('<')
        with self._if():
            self.html_list_element()
        self.push_ifnot_html_tag()
        self.ast['name'] = self.last_node
        self.html_attributes()
        self.ast['attribs'] = self.last_node
        self.multiline_blank()
        self.html_attribute_junk()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/>')
                with self._option():
                    self._token('>')
                    self.html_list_content()
                    self.ast['content'] = self.last_node
                    with self._optional():
                        with self._ifnot():
                            self.check_ifnot()
                        self._pattern(r'</\w+[ \t\n]*>')
                self._error('expecting one of: />')
        self.pop_ifnot()
        with self._optional():
            self.empty_line()

    @rule_def
    def html_list_element(self):
        self._pattern(r'(?i)(?:ul|ol)(?!\w)')

    @rule_def
    def html_list_content(self):
        def block0():
            self.html_list_content_item()
        self._closure(block0)

    @rule_def
    def html_list_content_item(self):
        self.multiline_blank()
        with self._group():
            self.html_list_item()
        self.ast['@'] = self.last_node

    @rule_def
    def html_list_item(self):
        self._token('<')
        with self._if():
            self.html_list_item_element()
        self.push_ifnot_html_tag()
        self.ast['name'] = self.last_node
        self.html_attributes()
        self.ast['attribs'] = self.last_node
        self.multiline_blank()
        self.html_attribute_junk()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/>')
                with self._option():
                    self._token('>')
                    self.html_block_no_wspre_document()
                    self.ast['content'] = self.last_node
                    with self._optional():
                        with self._ifnot():
                            self.check_ifnot()
                        self._pattern(r'</\w+[ \t\n]*>')
                self._error('expecting one of: />')
        self.pop_ifnot()
        with self._optional():
            self.empty_line()

    @rule_def
    def html_list_item_element(self):
        self._pattern(r'(?i)(?:li)(?!\w)')

    @rule_def
    def html_dl(self):
        self._token('<')
        with self._if():
            self.html_dl_element()
        self.push_ifnot_html_tag()
        self.ast['name'] = self.last_node
        self.html_attributes()
        self.ast['attribs'] = self.last_node
        self.multiline_blank()
        self.html_attribute_junk()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/>')
                with self._option():
                    self._token('>')
                    self.html_dl_content()
                    self.ast['content'] = self.last_node
                    with self._optional():
                        with self._ifnot():
                            self.check_ifnot()
                        self._pattern(r'</\w+[ \t\n]*>')
                self._error('expecting one of: />')
        self.pop_ifnot()
        with self._optional():
            self.empty_line()

    @rule_def
    def html_dl_element(self):
        self._pattern(r'(?i)(?:dl)(?!\w)')

    @rule_def
    def html_dl_content(self):
        def block0():
            self.html_dl_content_item()
        self._closure(block0)

    @rule_def
    def html_dl_content_item(self):
        self.multiline_blank()
        with self._group():
            self.html_dl_item()
        self.ast['@'] = self.last_node

    @rule_def
    def html_dl_item(self):
        self._token('<')
        with self._if():
            self.html_dl_item_element()
        self.push_ifnot_html_tag()
        self.ast['name'] = self.last_node
        self.html_attributes()
        self.ast['attribs'] = self.last_node
        self.multiline_blank()
        self.html_attribute_junk()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('/>')
                with self._option():
                    self._token('>')
                    self.html_block_no_wspre_document()
                    self.ast['content'] = self.last_node
                    with self._optional():
                        with self._ifnot():
                            self.check_ifnot()
                        self._pattern(r'</\w+[ \t\n]*>')
                self._error('expecting one of: />')
        self.pop_ifnot()
        with self._optional():
            self.empty_line()

    @rule_def
    def html_dl_item_element(self):
        self._pattern(r'(?i)(?:dt|dd)(?!\w)')



class mwSemanticParser(CheckSemanticsMixin, mwParser):
    pass


class mwSemantics(object):
    def blank(self, ast):
        return ast

    def multiline_blank(self, ast):
        return ast

    def document(self, ast):
        return ast

    def empty_tail(self, ast):
        return ast

    def document_block(self, ast):
        return ast

    def empty_line(self, ast):
        return ast

    def block(self, ast):
        return ast

    def block_not_par(self, ast):
        return ast

    def block_at_bol(self, ast):
        return ast

    def block_anywhere(self, ast):
        return ast

    def heading_block(self, ast):
        return ast

    def h6(self, ast):
        return ast

    def h5(self, ast):
        return ast

    def h4(self, ast):
        return ast

    def h3(self, ast):
        return ast

    def h2(self, ast):
        return ast

    def h1(self, ast):
        return ast

    def heading_inline(self, ast):
        return ast

    def heading_content(self, ast):
        return ast

    def push_no_h6(self, ast):
        return ast

    def push_no_h5(self, ast):
        return ast

    def push_no_h4(self, ast):
        return ast

    def push_no_h3(self, ast):
        return ast

    def push_no_h2(self, ast):
        return ast

    def push_no_h1(self, ast):
        return ast

    def horizontal_rule_block(self, ast):
        return ast

    def list_block(self, ast):
        return ast

    def list_list(self, ast):
        return ast

    def list_newline(self, ast):
        return ast

    def ul_block(self, ast):
        return ast

    def ol_block(self, ast):
        return ast

    def dl_block(self, ast):
        return ast

    def push_bol_skip_ul(self, ast):
        return ast

    def push_bol_skip_ol(self, ast):
        return ast

    def push_bol_skip_dl(self, ast):
        return ast

    def dt_or_dd(self, ast):
        return ast

    def dl_dt(self, ast):
        return ast

    def dl_dd(self, ast):
        return ast

    def list_li(self, ast):
        return ast

    def li_inline(self, ast):
        return ast

    def list_sublist(self, ast):
        return ast

    def list_dt(self, ast):
        return ast

    def dt_inline_dd(self, ast):
        return ast

    def push_ifnot_dt(self, ast):
        return ast

    def wspre_block(self, ast):
        return ast

    def wspre_inline(self, ast):
        return ast

    def wspre_inline_one(self, ast):
        return ast

    def wspre_newline(self, ast):
        return ast

    def push_bol_skip_wspre(self, ast):
        return ast

    def push_wspre_off(self, ast):
        return ast

    def pop_wspre(self, ast):
        return ast

    def set_wspre_on(self, ast):
        return ast

    def check_wspre(self, ast):
        return ast

    def check_ifnots(self, ast):
        return ast

    def pop_ifnot(self, ast):
        return ast

    def check_ifnot(self, ast):
        return ast

    def pop_no(self, ast):
        return ast

    def check_no(self, ast):
        return ast

    def push_no_nl(self, ast):
        return ast

    def pop_bol_skip(self, ast):
        return ast

    def check_bol_skip(self, ast):
        return ast

    def toc_block(self, ast):
        return ast

    def toc(self, ast):
        return ast

    def notoc(self, ast):
        return ast

    def forcetoc(self, ast):
        return ast

    def table_attribute_junk(self, ast):
        return ast

    def table_attribute_one(self, ast):
        return ast

    def table_attributes(self, ast):
        return ast

    def table_cell_attribute_junk(self, ast):
        return ast

    def table_cell_attribute_one(self, ast):
        return ast

    def table_cell_attributes(self, ast):
        return ast

    def table_header_attribute_junk(self, ast):
        return ast

    def table_header_attribute_one(self, ast):
        return ast

    def table_header_attributes(self, ast):
        return ast

    def table_block(self, ast):
        return ast

    def table_caption(self, ast):
        return ast

    def table_rows(self, ast):
        return ast

    def table_row_first(self, ast):
        return ast

    def table_row(self, ast):
        return ast

    def table_header(self, ast):
        return ast

    def table_header_cell_inline(self, ast):
        return ast

    def table_header_cell(self, ast):
        return ast

    def push_ifnot_table_header(self, ast):
        return ast

    def table_data(self, ast):
        return ast

    def table_data_cell_inline(self, ast):
        return ast

    def table_data_cell(self, ast):
        return ast

    def push_ifnot_table_data(self, ast):
        return ast

    def table_mode_document(self, ast):
        return ast

    def push_no_tableline(self, ast):
        return ast

    def non_special_chars(self, ast):
        return ast

    def paragraph(self, ast):
        return ast

    def paragraph_only_br(self, ast):
        return ast

    def paragraph_impl(self, ast):
        return ast

    def paragraph_br(self, ast):
        return ast

    def inline(self, ast):
        return ast

    def inline_impl_one(self, ast):
        return ast

    def inline_impl_one_no_newline(self, ast):
        return ast

    def inline_newline(self, ast):
        return ast

    def internal_link_trail(self, ast):
        return ast

    def internal_link(self, ast):
        return ast

    def push_ifnot_intlink_target(self, ast):
        return ast

    def push_ifnot_intlink(self, ast):
        return ast

    def link_tail_chars_no_parens(self, ast):
        return ast

    def link_tail_chars(self, ast):
        return ast

    def link_terminators(self, ast):
        return ast

    def link_normal_chars_no_parens(self, ast):
        return ast

    def link_normal_chars(self, ast):
        return ast

    def more_link_chars_no_parens(self, ast):
        return ast

    def more_link_chars_parens(self, ast):
        return ast

    def more_link_chars(self, ast):
        return ast

    def link_chars(self, ast):
        return ast

    def external_link(self, ast):
        return ast

    def push_ifnot_extlink(self, ast):
        return ast

    def plain_link(self, ast):
        return ast

    def many_quotes(self, ast):
        return ast

    def bold(self, ast):
        return ast

    def bold_inline(self, ast):
        return ast

    def italic(self, ast):
        return ast

    def italic_inline(self, ast):
        return ast

    def bold_and_italic(self, ast):
        return ast

    def bold_italic_both(self, ast):
        return ast

    def italic_bold(self, ast):
        return ast

    def bold_italic(self, ast):
        return ast

    def bold_italic_inline(self, ast):
        return ast

    def comment(self, ast):
        return ast

    def html_entity(self, ast):
        return ast

    def html_named_entity(self, ast):
        return ast

    def html_numbered_entity(self, ast):
        return ast

    def html_attribute_value_doublequote(self, ast):
        return ast

    def html_attribute_value_singlequote(self, ast):
        return ast

    def html_attribute_value_noquote(self, ast):
        return ast

    def html_attribute_value(self, ast):
        return ast

    def html_attribute(self, ast):
        return ast

    def html_attribute_junk(self, ast):
        return ast

    def html_attribute_name(self, ast):
        return ast

    def html_attribute_one(self, ast):
        return ast

    def html_attributes(self, ast):
        return ast

    def html_inline(self, ast):
        return ast

    def push_ifnot_html_tag(self, ast):
        return ast

    def html_inline_element(self, ast):
        return ast

    def nowiki(self, ast):
        return ast

    def nowiki_element(self, ast):
        return ast

    def nowiki_inline(self, ast):
        return ast

    def nowiki_non_special_chars(self, ast):
        return ast

    def pre_nowiki(self, ast):
        return ast

    def pre_nowiki_inline(self, ast):
        return ast

    def pre(self, ast):
        return ast

    def pre_element(self, ast):
        return ast

    def pre_non_special_chars(self, ast):
        return ast

    def pre_inline(self, ast):
        return ast

    def ref(self, ast):
        return ast

    def ref_element(self, ast):
        return ast

    def html_heading(self, ast):
        return ast

    def html_heading_element(self, ast):
        return ast

    def html_block(self, ast):
        return ast

    def html_block_document(self, ast):
        return ast

    def html_block_element(self, ast):
        return ast

    def html_block_no_wspre(self, ast):
        return ast

    def html_block_no_wspre_element(self, ast):
        return ast

    def html_block_no_wspre_document(self, ast):
        return ast

    def html_p(self, ast):
        return ast

    def html_p_element(self, ast):
        return ast

    def html_p_inline(self, ast):
        return ast

    def html_table(self, ast):
        return ast

    def html_table_element(self, ast):
        return ast

    def html_table_content(self, ast):
        return ast

    def html_table_content_item(self, ast):
        return ast

    def html_table_tr(self, ast):
        return ast

    def html_table_tr_element(self, ast):
        return ast

    def html_table_tr_content(self, ast):
        return ast

    def html_table_tr_content_item(self, ast):
        return ast

    def html_table_cell(self, ast):
        return ast

    def html_table_cell_element(self, ast):
        return ast

    def html_list(self, ast):
        return ast

    def html_list_element(self, ast):
        return ast

    def html_list_content(self, ast):
        return ast

    def html_list_content_item(self, ast):
        return ast

    def html_list_item(self, ast):
        return ast

    def html_list_item_element(self, ast):
        return ast

    def html_dl(self, ast):
        return ast

    def html_dl_element(self, ast):
        return ast

    def html_dl_content(self, ast):
        return ast

    def html_dl_content_item(self, ast):
        return ast

    def html_dl_item(self, ast):
        return ast

    def html_dl_item_element(self, ast):
        return ast

def main(filename, startrule, trace=False):
    import json
    with open(filename) as f:
        text = f.read()
    parser = mwParser(parseinfo=False)
    ast = parser.parse(text, startrule, filename=filename, trace=trace)
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()

if __name__ == '__main__':
    import argparse
    import sys
    class ListRules(argparse.Action):
        def __call__(self, parser, namespace, values, option_string):
            print('Rules:')
            for r in mwParser.rule_list():
                print(r)
            print()
            sys.exit(0)
    parser = argparse.ArgumentParser(description="Simple parser for mw.")
    parser.add_argument('-l', '--list', action=ListRules, nargs=0,
                        help="list all rules and exit")
    parser.add_argument('-t', '--trace', action='store_true',
                        help="output trace information")
    parser.add_argument('file', metavar="FILE", help="the input file to parse")
    parser.add_argument('startrule', metavar="STARTRULE",
                        help="the start rule for parsing")
    args = parser.parse_args()

    main(args.file, args.startrule, trace=args.trace)
