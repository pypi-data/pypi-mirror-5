# -*- coding: utf-8 -*-
import logging
import socket
from weakref import WeakValueDictionary

import amqp
import gevent
from gevent.queue import Queue

from base import safe_repr, AmqpRpcAbstract
from consumer import FailsafeAmqpConsumer
from exception import WrongRequest, IgnoreRequest
from publisher import FailsafeAmqpPublisher
from serializer import RpcJsonSerializer


class AutoCleaningCounter(dict):
    """Works like collections.Counter from Python 2.7
    but does not stores zero values for memory saving."""
    def __missing__(self, key):
        return 0

    def __set__(self, key, value):
        if value > 0:
            super(AutoCleaningCounter, self).__set__(key, value)
        else:
            assert value == 0
            del self[key]


class QueueMaxCall(object):
    def __init__(self):
        self._queue = Queue()
        self.count = 0

    def tick(self):
        if self.count <= 0:
            raise ValueError
        self.count -= 1
        self._queue.put(self.count)
        return self.count > 0

    def wait_tick(self):
        return self._queue.get()


class AmqpRpcServer(AmqpRpcAbstract):
    """Server class for AMQP RPC.

    :param service_name: Namespace of your RPC service.
    :type service_name: str
    :param serializer: Class for generating AMQP messages.
        JSON messages generated by default.
    :type serializer: ``AbstractRpcSerializer``
    :param amqp_host: IP address or hostname of AMQP server.
        By default ``127.0.0.1``.
    :type amqp_host: str
    :param amqp_port: TCP port of AMQP server. By default 5672.
    :type amqp_port: int
    :param amqp_user: Username for authentication in AMQP.
        By default ``guest``.
    :type amqp_user: str
    :param amqp_password: Password for authentication in AMQP.
        By default ``guest``.
    :type amqp_password: str
    :param amqp_vhost: Virtual host for authentication in AMQP.
        By default ``/``.
    :type amqp_host: str
    """
    logger = logging.getLogger('amphora.AmqpRpcServer')
    request_exchange_type = 'direct'

    def __init__(self, service_name, serializer=RpcJsonSerializer,
                 **kwargs):
        from gevent import socket as gevent_socket
        assert socket.socket == gevent_socket.socket, \
            "Program must be monkey-patched by gevent"

        super(AmqpRpcServer, self).__init__()
        self.service_name = service_name
        self.serializer = serializer

        self.functions = {}
        self.request_exchange = 'rpc_{0}_request'.format(
            self.service_name)
        self.request_queue = 'rpc_{0}_request'.format(
            self.service_name)
        self.response_exchange = 'rpc_{0}_response'.format(
            self.service_name)
        self.additional_queue_template = 'rpc_' + service_name + '_queue_{0}'

        self.publisher = FailsafeAmqpPublisher(**kwargs)
        self.publisher.before_start_cycle.add_handler(self._prepare_publisher)

        self.consumer = FailsafeAmqpConsumer(**kwargs)
        self.consumer.before_start_cycle.add_handler(self._prepare_consumer)
        self.consumer.on_message.add_handler(self._on_message)

        # {queue::basestring: QueueMaxCall}
        self._queue_limits = WeakValueDictionary()

        # Dict
        # {queue::basestring: count of listens::integer}
        self._immortal_queues = AutoCleaningCounter()

    @staticmethod
    def _add_function_decorator(func):
        """Change this function by class inheritance if you
        want to decorate every added function."""
        return func

    def add_function(self, func, name=None):
        """Add function for handling remote call. Can be used as
        common function or as decorator.

        :param func: Remote call handler.
        :type func: callable
        :param name: Remote call handler name.
            If omited then call names the same as handler name.
        :type name: str

        Example:

        .. code-block:: python

           # math_server.py
           from gevent import monkey; monkey.patch_socket()
           from amphora import AmqpRpcServer

           server = AmqpRpcServer('simplemath')

           def add(x, y):
               return x + y
           server.add_function(add)

           def substract(x, y):
               return x - y
           server.add_function(substract, name="sub")

           @server.add_function
           def multiply(x, y):
               return x * y

           @server.add_function('div')
           def divide(x, y):
               return x / y

           server.serve(nowait=False)


           # math_client.py
           from gevent import monkey; monkey.patch_socket()
           from amphora import AmqpRpcClient

           client = AmqpRpcClient('simplemath')
           # TODO: must work without __import__('gevent').sleep(1)
           print client.call.add(2, 3)  # 5
           print client.call.sub(10, 3)  # 7
           print client.call.multiply(5, 5)  # 25
           print client.call.div(64, 16)  # 4

        Added function can raise :py:class:`amphora.IgnoreRequest`
        for re-sending this request to another server.
        """
        if name is None:
            if not callable(func):
                name, func = func, None
            else:
                name = func.__name__
        else:
            name = str(name)

        def add_function_wrapper(func):
            self.functions[name] = self._add_function_decorator(func)
            self.logger.debug('Added function %s as %r', func, name)
            return func

        if func is None:
            return add_function_wrapper
        else:
            add_function_wrapper(func)
            return func

    def receive_from_queue(self, queue, max_calls=None,
                           timeout=None, block=True):
        """Receive new calls from specified queue.

        :py:class:`amphora.AmqpRpcServer` authomatically
        starts receiving from queue ``rpc_{service_name}_request``,
        but you may enable receiving calls from several queues.

        :param queue: AMQP queue name with requests.
        :type queue: str
        :param max_calls: Maximum call count. By default unlimited.
        :type max_calls: int
        :param timeout: Stop receiving from queue after
            ``timeout`` seconds.
        :type timeout: float
        :param block: Block current greenlet until
            maximum calls reached or timed out.
        :type block: bool
        :raises gevent.Timeout: When timed out and maximum calls
            was not reached.

        If you set ``max_calls`` then `AmqpRpcServer` handles only
        specified calls. After reaching maximum `AmqpRpcServer` cancel
        consuming from queue but does not close channel until all handling
        messages acked or rejected. Same rules applies for ``timeout``.
        You can specify both parameters at once.

        When requests delivered too frequently, AMQP server can send
        some request messages just after `basic_cancel` call. These
        messages will be rejected with requeuing. In order to avoid
        infinite resending messages that can cause denial of service,
        AmqpRpcServer can reject messages with one second delay.
        """
        queue = self.additional_queue_template.format(queue)
        if block:
            return self._receive_from_queue(queue, max_calls, timeout, True)
        else:
            gevent.spawn(self._receive_from_queue, queue, max_calls,
                         timeout, False)

    def _receive_from_queue(self, queue, max_calls, timeout, block_hint):
        self.consumer.start_consume(queue, nowait=True)
        self.logger.debug(
            "Start receiving from queue %s (max calls %s, timeout %s)",
            queue, max_calls, timeout)

        if max_calls is None:
            self._immortal_queues[queue] += 1
            if not block_hint and timeout is None:
                # nobody waits this call
                return

            if timeout is None:
                try:
                    while True:
                        gevent.sleep(60)
                except:
                    pass
            else:
                gevent.sleep(timeout)
                self._immortal_queues[queue] -= 1
                self.logger.debug("Stop receiving from %s due timeout", queue)
        else:
            limits = self._queue_limits.get(queue)  # WeakValueDictionary
            if limits is None:
                limits = self._queue_limits[queue] = QueueMaxCall()
            limits.count += max_calls

            if timeout is None:
                for _ in xrange(max_calls):
                    limits.wait_tick()
                self.logger.debug(
                    "Stop receiving from %s due max calls", queue)
            else:
                self.__receive_from_queue__limits(
                    queue, timeout, max_calls, limits)

    def __receive_from_queue__limits(self, queue, timeout, max_calls, limits):
        timer = gevent.Timeout(timeout)
        try:
            timer.start()
            last_count = limits.count
            for messages_remained in xrange(max_calls, 0, -1):
                limits.wait_tick()
                last_count = limits.count
            self.logger.debug("Stop receiving from %s due max calls, "
                              "before timeout", queue)
        except gevent.Timeout as e:
            if e is timer:
                self.logger.debug(
                    "Stop receiving from %s due timeout", queue)
                assert last_count >= messages_remained, \
                    (last_count, messages_remained)
                limits.count -= messages_remained
                if limits.count == 0:
                    self.logger.debug(
                        "No one consume from %s, stop consuming", queue)
                    try:
                        self.consumer.stop_consume(queue)
                    except KeyError:
                        pass
            raise
        finally:
            timer.cancel()

    def _prepare_publisher(self, publisher):
        publisher.new_exchange(self.response_exchange, 'direct', nowait=True)

    def _prepare_consumer(self, consumer):
        consumer.new_exchange(
            self.request_exchange, self.request_exchange_type, nowait=True)
        consumer.new_queue(
            self.request_queue, self.request_exchange, nowait=True)
        self._receive_from_queue(self.request_queue, None, None, False)

    def _on_message(self, message):
        if ('reply_to' not in message.properties or
                'message_id' not in message.properties):
            if self.logger.isEnabledFor(logging.DEBUG):
                self.logger.warning(
                    "Strange message without proper headers: %s. "
                    "Silently ignore.", safe_repr(message.body))
                message.ack()
                return

        limits = self._queue_limits.get(message.queue)  # WeakValueDictionary
        if limits is None and message.queue not in self._immortal_queues:
            self.logger.warning(
                "Got request %s from not listened queue %s. Rejecting.",
                safe_repr(message.body), message.queue)
            message.reject()
            return

        if self.logger.isEnabledFor(logging.DEBUG):
            self.logger.debug(
                "Got request message %s", safe_repr(message.body))

        serializer = self.serializer
        try:
            func_name, args, kwargs = serializer.deserialize_call(
                message.body)
            func = self.functions.get(func_name)
            if func is None:
                self.logger.warning("No function %r defined", func_name)
                raise WrongRequest("No function {0} defined".format(func_name))
        except Exception as e:
            # Wrong formatted messages aren't considered as executed calls
            self._send_result(message, serializer.serialize_result(e))
            message.ack()
        else:
            if limits is not None:
                try:
                    can_get_more = limits.tick()
                except ValueError:
                    if self.logger.isEnabledFor(logging.DEBUG):
                        self.logger.debug(
                            "Queue %s is already overlimited, rejecting %s",
                            message.queue, safe_repr(message.body))
                    message.reject()
                    return
                if not can_get_more:
                    self.logger.debug(
                        "Queue %s reached limits, stop consuming",
                        message.queue)
                    try:
                        self.consumer.stop_consume(message.queue)
                    except KeyError:
                        pass
            gevent.spawn(self._run_function, message, func, args, kwargs)

    def _run_function(self, message, func, args, kwargs):
        try:
            result = func(*args, **kwargs)
            body = self.serializer.serialize_result(result)
        except IgnoreRequest:
            self._on_ignore_request(message)
            return
        except Exception as e:
            self.logger.warning(
                "When executed %s(*%r, **%r)", func, args, kwargs,
                exc_info=1)
            body = self.serializer.serialize_result(e)
        self._send_result(message, body)
        message.ack()

    def _on_ignore_request(self, message):
        message.reject()

    def _send_result(self, message, body):
        message_id = message.properties['message_id']
        reply_to = message.properties['reply_to']

        response_msg = amqp.Message(
            body=body,
            message_id=message_id,
            delivery_mode=2)  # PERSISTENT
        self.publisher.publish_message(
            response_msg, self.response_exchange, routing_key=reply_to)


class AmqpRpcFanoutServer(AmqpRpcServer):
    """Fanout server class for AMQP RPC.

    Fanout exchanges in AMQP used for broadcasting. If you
    execute remote function via :py:class:`~amphora.AmqpRpcFanoutClient`
    then request will be handled by every connected
    :py:class:`~amphora.AmqpRpcFanoutServer`.

    One difference from :py:class:`~amphora.AmqpRpcServer` it that
    added functions can raise :py:class:`amphora.IgnoreRequest`.
    When function raises it, server sends "ack" to request message
    but does not send any result or exception back to client.
    """
    request_exchange_type = 'fanout'

    def _on_ignore_request(self, message):
        pass  # simply drop, do not send reject
