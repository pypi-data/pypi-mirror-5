# yay.lextab.py. This file automatically created by PLY (version 3.4). Don't edit!
_tabversion   = '3.4'
_lextokens    = {'DEDENT': 1, 'ELIF': 1, 'RSHIFT': 1, 'EXTEND': 1, 'HYPHEN': 1, 'WS': 1, 'LSHIFT': 1, 'NEW': 1, 'PROTOTYPE': 1, 'SELECT': 1, 'COMMENT': 1, 'SEARCH': 1, 'SET': 1, 'EMPTYLIST': 1, 'POW': 1, 'NEWLINE': 1, 'NE': 1, 'COLON': 1, 'INTEGER': 1, 'IDENTIFIER': 1, 'EXPRESSION_START': 1, 'DOCUMENT_START': 1, 'MULTILINE_END': 1, 'STRING': 1, 'FOR': 1, 'MACRO': 1, 'IS': 1, 'VALUE': 1, 'ELSE': 1, 'AS': 1, 'LE': 1, 'MULTILINE': 1, 'IN': 1, 'RDBRACE': 1, 'FLOOR_DIVIDE': 1, 'INCLUDE': 1, 'EQ': 1, 'IF': 1, 'AND': 1, 'INDENT': 1, 'FLOAT': 1, 'GE': 1, 'GTLT': 1, 'CALL': 1, 'EMPTYDICT': 1, 'NOT': 1, 'OR': 1, 'LDBRACE': 1, 'LAMBDA': 1}
_lexreflags   = 0
_lexliterals  = '+-*/%&|^~<>()[]{}@,:.`=;'
_lexstateinfo = {'TEMPLATE': 'exclusive', 'INITIAL': 'inclusive', 'VALUE': 'exclusive', 'COMMAND': 'exclusive', 'QVALUE': 'exclusive', 'CVALUE': 'exclusive', 'BLOCK': 'exclusive'}
_lexstatere   = {'TEMPLATE': [('(?P<t_INITIAL_VALUE_TEMPLATE_COMMAND_COMMENT>\\#[^\\n]*)|(?P<t_TEMPLATE_RDBRACE>}})|(?P<t_COMMAND_TEMPLATE_STRING>\n                         [uU]?[rR]?\n                         (?:              # Single-quote (\') strings\n                         \'\'\'(?:                 # Triple-quoted can contain...\n                         [^\']               | # a non-quote\n                         \\\\\'                | # a backslashed quote\n                         \'{1,2}(?!\')          # one or two quotes\n                         )*\'\'\' |\n                         \'(?:                   # Non-triple quoted can contain...\n                         [^\']                | # a non-quote\n                         \\\\\'                   # a backslashded quote\n                         )*\'(?!\') |                # Double-quote (") strings\n                                       """(?:                 # Triple-quoted can contain...\n                                       [^"]               | # a non-quote\n                                       \\\\"                | # a backslashed single\n                                       "{1,2}(?!")          # one or two quotes\n                                       )*""" |\n                                       "(?:                   # Non-triple quoted can contain...\n                                       [^"]                | # a non-quote\n                                       \\\\"                   # a backslashed quote\n                                       )*"(?!")\n                                       ))|(?P<t_COMMAND_TEMPLATE_INTEGER>\n        (?<![\\w.])               #Start of string or non-alpha non-decimal point\n            0[X][0-9A-F]+L?|     #Hexadecimal\n            0[O][0-7]+L?|        #Octal\n            0[B][01]+L?|         #Binary\n            [1-9]\\d*L?           #Decimal/Long Decimal, will not match 0____\n        (?![\\w.])                #End of string or non-alpha non-decimal point\n        )|(?P<t_COMMAND_TEMPLATE_FLOAT>(\\d+(?:\\.\\d+)?(?:[eE][+-]\\d+)?))|(?P<t_INITIAL_VALUE_TEMPLATE_COMMAND_WS>\\ +)|(?P<t_COMMAND_TEMPLATE_IDENTIFIER>[A-Za-z_][A-Za-z0-9_]*)|(?P<t_ANY_NEWLINE>\\n+)|(?P<t_COMMAND_TEMPLATE_POW>\\*\\*)|(?P<t_COMMAND_TEMPLATE_FLOOR_DIVIDE>//)|(?P<t_COMMAND_TEMPLATE_NE>!=)|(?P<t_COMMAND_TEMPLATE_LE><=)|(?P<t_COMMAND_TEMPLATE_EQ>==)|(?P<t_COMMAND_TEMPLATE_GTLT><>)|(?P<t_COMMAND_TEMPLATE_RSHIFT>>>)|(?P<t_COMMAND_TEMPLATE_GE>>=)|(?P<t_COMMAND_TEMPLATE_LSHIFT><<)', [None, ('t_INITIAL_VALUE_TEMPLATE_COMMAND_COMMENT', 'COMMENT'), ('t_TEMPLATE_RDBRACE', 'RDBRACE'), ('t_COMMAND_TEMPLATE_STRING', 'STRING'), ('t_COMMAND_TEMPLATE_INTEGER', 'INTEGER'), ('t_COMMAND_TEMPLATE_FLOAT', 'FLOAT'), None, ('t_INITIAL_VALUE_TEMPLATE_COMMAND_WS', 'WS'), ('t_COMMAND_TEMPLATE_IDENTIFIER', 'IDENTIFIER'), ('t_ANY_NEWLINE', 'NEWLINE'), (None, 'POW'), (None, 'FLOOR_DIVIDE'), (None, 'NE'), (None, 'LE'), (None, 'EQ'), (None, 'GTLT'), (None, 'RSHIFT'), (None, 'GE'), (None, 'LSHIFT')])], 'INITIAL': [('(?P<t_INITIAL_VALUE_TEMPLATE_COMMAND_COMMENT>\\#[^\\n]*)|(?P<t_INITIAL_HYPHEN>-[ \\t]*)|(?P<t_INITIAL_VALUE>([^:\\n ]|:(?!\\s))+)|(?P<t_INITIAL_VALUE_TEMPLATE_COMMAND_WS>\\ +)|(?P<t_ANY_NEWLINE>\\n+)|(?P<t_INITIAL_EXTEND>extend)', [None, ('t_INITIAL_VALUE_TEMPLATE_COMMAND_COMMENT', 'COMMENT'), ('t_INITIAL_HYPHEN', 'HYPHEN'), ('t_INITIAL_VALUE', 'VALUE'), None, ('t_INITIAL_VALUE_TEMPLATE_COMMAND_WS', 'WS'), ('t_ANY_NEWLINE', 'NEWLINE'), (None, 'EXTEND')])], 'VALUE': [('(?P<t_INITIAL_VALUE_TEMPLATE_COMMAND_COMMENT>\\#[^\\n]*)|(?P<t_VALUE_COLON>\\ *:\\ *((?:\n)| ))|(?P<t_VALUE_EMPTYDICT>[ ]*{})|(?P<t_VALUE_EMPTYLIST>\\ *\\[\\])|(?P<t_VALUE_QVALUE_CVALUE_BLOCK_LDBRACE>{{)|(?P<t_VALUE_MULTILINE>(>|\\|[+-]?)[ ]*[\\n]+)|(?P<t_VALUE_QUOTE>\\")|(?P<t_VALUE_WSVALUE>([^:\\{\\n]|{(?!{)|:(?!\\s))+(?=\\n))|(?P<t_VALUE_CVALUE_VALUE>([^:\\{\\n]|{(?!{)|:(?!\\s))+)|(?P<t_INITIAL_VALUE_TEMPLATE_COMMAND_WS>\\ +)|(?P<t_ANY_NEWLINE>\\n+)', [None, ('t_INITIAL_VALUE_TEMPLATE_COMMAND_COMMENT', 'COMMENT'), ('t_VALUE_COLON', 'COLON'), None, ('t_VALUE_EMPTYDICT', 'EMPTYDICT'), ('t_VALUE_EMPTYLIST', 'EMPTYLIST'), ('t_VALUE_QVALUE_CVALUE_BLOCK_LDBRACE', 'LDBRACE'), ('t_VALUE_MULTILINE', 'MULTILINE'), None, ('t_VALUE_QUOTE', 'QUOTE'), ('t_VALUE_WSVALUE', 'WSVALUE'), None, ('t_VALUE_CVALUE_VALUE', 'VALUE'), None, ('t_INITIAL_VALUE_TEMPLATE_COMMAND_WS', 'WS'), ('t_ANY_NEWLINE', 'NEWLINE')])], 'CVALUE': [('(?P<t_VALUE_QVALUE_CVALUE_BLOCK_LDBRACE>{{)|(?P<t_VALUE_CVALUE_VALUE>([^:\\{\\n]|{(?!{)|:(?!\\s))+)|(?P<t_ANY_NEWLINE>\\n+)', [None, ('t_VALUE_QVALUE_CVALUE_BLOCK_LDBRACE', 'LDBRACE'), ('t_VALUE_CVALUE_VALUE', 'VALUE'), None, ('t_ANY_NEWLINE', 'NEWLINE')])], 'QVALUE': [('(?P<t_VALUE_QVALUE_CVALUE_BLOCK_LDBRACE>{{)|(?P<t_QVALUE_QUOTE>\\")|(?P<t_QVALUE_VALUE>([^\\{\\n\\"]|{(?!{))+)|(?P<t_ANY_NEWLINE>\\n+)', [None, ('t_VALUE_QVALUE_CVALUE_BLOCK_LDBRACE', 'LDBRACE'), ('t_QVALUE_QUOTE', 'QUOTE'), ('t_QVALUE_VALUE', 'VALUE'), None, ('t_ANY_NEWLINE', 'NEWLINE')])], 'COMMAND': [('(?P<t_COMMAND_CONTINUATION>\\\\\\n)|(?P<t_INITIAL_VALUE_TEMPLATE_COMMAND_COMMENT>\\#[^\\n]*)|(?P<t_COMMAND_TEMPLATE_STRING>\n                         [uU]?[rR]?\n                         (?:              # Single-quote (\') strings\n                         \'\'\'(?:                 # Triple-quoted can contain...\n                         [^\']               | # a non-quote\n                         \\\\\'                | # a backslashed quote\n                         \'{1,2}(?!\')          # one or two quotes\n                         )*\'\'\' |\n                         \'(?:                   # Non-triple quoted can contain...\n                         [^\']                | # a non-quote\n                         \\\\\'                   # a backslashded quote\n                         )*\'(?!\') |                # Double-quote (") strings\n                                       """(?:                 # Triple-quoted can contain...\n                                       [^"]               | # a non-quote\n                                       \\\\"                | # a backslashed single\n                                       "{1,2}(?!")          # one or two quotes\n                                       )*""" |\n                                       "(?:                   # Non-triple quoted can contain...\n                                       [^"]                | # a non-quote\n                                       \\\\"                   # a backslashed quote\n                                       )*"(?!")\n                                       ))|(?P<t_COMMAND_TEMPLATE_INTEGER>\n        (?<![\\w.])               #Start of string or non-alpha non-decimal point\n            0[X][0-9A-F]+L?|     #Hexadecimal\n            0[O][0-7]+L?|        #Octal\n            0[B][01]+L?|         #Binary\n            [1-9]\\d*L?           #Decimal/Long Decimal, will not match 0____\n        (?![\\w.])                #End of string or non-alpha non-decimal point\n        )|(?P<t_COMMAND_TEMPLATE_FLOAT>(\\d+(?:\\.\\d+)?(?:[eE][+-]\\d+)?))|(?P<t_INITIAL_VALUE_TEMPLATE_COMMAND_WS>\\ +)|(?P<t_COMMAND_TEMPLATE_IDENTIFIER>[A-Za-z_][A-Za-z0-9_]*)|(?P<t_ANY_NEWLINE>\\n+)|(?P<t_COMMAND_TEMPLATE_POW>\\*\\*)|(?P<t_COMMAND_TEMPLATE_FLOOR_DIVIDE>//)|(?P<t_COMMAND_TEMPLATE_NE>!=)|(?P<t_COMMAND_TEMPLATE_LE><=)|(?P<t_COMMAND_TEMPLATE_EQ>==)|(?P<t_COMMAND_TEMPLATE_GTLT><>)|(?P<t_COMMAND_TEMPLATE_RSHIFT>>>)|(?P<t_COMMAND_TEMPLATE_GE>>=)|(?P<t_COMMAND_TEMPLATE_LSHIFT><<)', [None, ('t_COMMAND_CONTINUATION', 'CONTINUATION'), ('t_INITIAL_VALUE_TEMPLATE_COMMAND_COMMENT', 'COMMENT'), ('t_COMMAND_TEMPLATE_STRING', 'STRING'), ('t_COMMAND_TEMPLATE_INTEGER', 'INTEGER'), ('t_COMMAND_TEMPLATE_FLOAT', 'FLOAT'), None, ('t_INITIAL_VALUE_TEMPLATE_COMMAND_WS', 'WS'), ('t_COMMAND_TEMPLATE_IDENTIFIER', 'IDENTIFIER'), ('t_ANY_NEWLINE', 'NEWLINE'), (None, 'POW'), (None, 'FLOOR_DIVIDE'), (None, 'NE'), (None, 'LE'), (None, 'EQ'), (None, 'GTLT'), (None, 'RSHIFT'), (None, 'GE'), (None, 'LSHIFT')])], 'BLOCK': [('(?P<t_VALUE_QVALUE_CVALUE_BLOCK_LDBRACE>{{)|(?P<t_BLOCK_WS>\\ +)|(?P<t_BLOCK_VALUE>[^:\\{\\n]+)|(?P<t_ANY_NEWLINE>\\n+)', [None, ('t_VALUE_QVALUE_CVALUE_BLOCK_LDBRACE', 'LDBRACE'), ('t_BLOCK_WS', 'WS'), ('t_BLOCK_VALUE', 'VALUE'), ('t_ANY_NEWLINE', 'NEWLINE')])]}
_lexstateignore = {'INITIAL': ''}
_lexstateerrorf = {'TEMPLATE': 't_ANY_error', 'INITIAL': 't_ANY_error', 'VALUE': 't_ANY_error', 'COMMAND': 't_ANY_error', 'QVALUE': 't_ANY_error', 'CVALUE': 't_ANY_error', 'BLOCK': 't_ANY_error'}
