# Postgresql specific database
__doc__='''Celestial Software's configuration file processing.

This package parses an input file returning an object hash with
array references to an array of the highest level elements
parsed.  It assumes that logical elements are surrounded by
curley braces or parenthesis.

=head1 USAGE

import Csys.Parsebraces;

    config = Csys.Parsebraces("filename")
    rlines = obj.lines # lines
    rargs = obj.args;   # string arguments

=head1 EXAMPLES

This might be used to parse the DNS configuration files:

    import Csys.Parsebraces
    config = Csys.Parsebraces.Config("/etc/named.conf")
    To parse the lines, a general routine might be

    options = {}
    zones   = {}

    for line in config.get_lines(): #{
        args = line.split()
        keyword = args.pop(0)
        if(keyword == 'options'): #{{
            # process global options;
            options[keyword] = ' '.join(args)
        #}
        elif(keyword == 'zone'): #{
            name = args.pop(0)
            zones[name] = Zone(config, name, args)
        #}}
    #}
    class Zone: #{
        def __init__(self, config, name, args): #{
            ndx = args.pop() # last argument
            my $index = pop(@args); # get last argument
            self.name = name
            for line in config.get_text_array(ndx): #{
                args1 = line.split()
                keyword = args1.pop(0)
                if(keyword in ('type', 'file'): #{{ # simple arguments
                    self.__dict__[keyword] = args[-1]
                #}
                # these require further parsing of elements in braces.
                elif(keyword == 'masters'):# {
                    self.masters = Master(args1);
                #}
                elsf(keyword == 'transfer-allowed'): #{
                    self.transfer_allowed = Transfer(args1);
                #}}
                ...
            #}}
        #} __init__
    #} class Zone

$Id: Parsebraces.py,v 1.3 2009/11/25 02:22:40 csoftmgr Exp $'''

__version__='$Revision: 1.3 $'[11:-2]

import Csys, os, sys, re

_patBraces = re.compile(r'[{(]([^{}()]*)[)}]')
_patIndex = re.compile(r'^(.*)\s+(\d+);*$')

class  Config(Csys.CSClass): #{
	'''Configuration parsed from file'''
	_attributes = {
		'lines'		: [],
		'args'		: [],
	}
	def __init__(self, input): #{
		'''Parse configuration file'''
		Csys.CSClass.__init__(self)
		# get array of non-blank lines from input
		self.lines = Csys.rmComments(
			input, C=True, Cplusplus=True, wantarray=True, pattern='.'
		)
		input = '\n'.join(self.lines)
		while True: #{
			reg = _patBraces.search(input)
			if not reg: break
			n = len(self.args)
			self.args.append(reg.group(1))
			input = _patBraces.sub('%d' % n, input, 1)
		#}
		self.lines = [
			line.rstrip() for line in input.split('\n') if line.rstrip()
		]
	#} __init__

	def get_text_array(self, idx): #{
		'''get array by splitting the line from arg_strings'''
		if isinstance(idx, basestring): idx = int(idx.rstrip(';'))
		val = self.args[idx]
		lines = []
		for line in val.splitlines(): #{
			if line: lines.append(line)
		#}
		return(lines)
	#} get_text_array

	def split_line(self, ndx): #{
		'''Break line into key, options, and index'''
		parts = self.lines[ndx].rstrip(';').split()
		return((parts[0], parts[1:-1], int(parts[-1])))
	#} split_line

	def get_line_parts(self): #{
		'''return key, options, index from line'''
		output = []
		for line in self.lines: #{
			parts = line.rstrip(';').split()
			output.append((parts[0], parts[1:-1], int(parts[-1])))
		#}
		return output
	#} get_line_parts

	def get_lines(self): return self.lines

	def dumpall(self): #{
		'''Hopefully dump out original without comments'''
		outlines = []
		for line in self.lines: #{
			r = _patIndex.search(line)
			if r: #{{
				pre, idx = (r.group(1), int(r.group(2)))
				# print 'pre >%s< idx = %d' % (pre, idx)
				outlines.append(pre)
				outlines += ['{', self.get_text_array(idx), '}']
			#}
			else: outlines.append(line) #}
		#}
		return(outlines)
	#} dumpall
#}
if __name__ == '__main__': #{
	print 'OK'
	testinput = ('''
// generated by named-bootconf.pl

options {
	directory "/usr/local/lib/named";
	check-names master warn;
	check-names slave warn;
	pid-file "/etc/named.pid";
	/*
	 * If there is a firewall between you and nameservers you want
	 * to talk to, you might need to uncomment the query-source
	 * directive below.  Previous versions of BIND always asked
	 * questions using port 53, but BIND 8.1 uses an unprivileged
	 * port by default.
	 */
	// query-source address * port 53;
};

// 
// Celestial Software nameserver boot file
// 
// type		domain				source file or host
zone "." {
	type hint;
	file "named.ca";
};

zone "0.0.127.in-addr.arpa" {
	type master;
	file "primary/0.0.127.in-addr.arpa";
};
zone "111.136.192.in-addr.arpa" {
	type slave;
	file "secondary/111.136.192.in-addr.arpa";
	allow-update {
		127.0.0.1;
		192.136.111.1;
		192.136.111.3;
		192.136.111.7;
		192.136.111.40;
		192.136.111.59;
	};
	masters {
		192.136.111.40;
	};
};
zone "254.168.192.in-addr.arpa" {
	type slave;
	file "secondary/254.168.192.in-addr.arpa";
	allow-update {
		127.0.0.1;
		192.136.111.1;
		192.136.111.3;
		192.136.111.7;
		192.136.111.40;
		192.136.111.59;
	};
	allow-query {
		127.0.0.1;
		192.136.111.0/24;
		192.168.254.0/24;
	};
	allow-transfer {
		127.0.0.1;
		192.136.111.0/24;
		192.168.254.0/24;
	};
	masters {
		192.136.111.40;
	};
};
zone "celestial.com" {
	type slave;
	file "secondary/celestial.com";
	allow-update {
		127.0.0.1;
		192.136.111.1;
		192.136.111.3;
		192.136.111.7;
		192.136.111.40;
		192.136.111.59;
	};
	masters {
		192.136.111.3;
	};
	allow-transfer {
		127.0.0.1;
		204.57.191.163;
		204.57.191.242;
	};
};
zone "mi.celestial.com" {
	type slave;
	file "secondary/mi.celestial.com";
	allow-update {
		127.0.0.1;
		192.136.111.1;
		192.136.111.3;
		192.136.111.7;
		192.136.111.40;
		192.136.111.59;
	};
	allow-query {
		127.0.0.1;
		192.168.254.0/24;
		192.136.111.0/24;
	};
	allow-transfer {
		127.0.0.1;
		192.168.254.0/24;
		192.136.111.0/24;
	};
	masters {
		192.136.111.3;
	};
};
zone "celestial.net" {
	type slave;
	file "secondary/celestial.net";
	allow-update {
		127.0.0.1;
		192.136.111.1;
		192.136.111.3;
		192.136.111.7;
		192.136.111.40;
		192.136.111.59;
	};
	allow-transfer {
		127.0.0.1;
		192.136.111.0/24;
		192.168.254.0/24;
		204.57.191.1;
	};
	masters {
		192.136.111.40;
	};
};
zone "rbl.celestial.net" {
	type slave;
	file "secondary/rbl.celestial.net";
	allow-update {
		127.0.0.1;
		192.136.111.1;
		192.136.111.3;
		192.136.111.40;
		192.136.111.59;
		192.168.254.0/24;
	};
	allow-transfer {
		127.0.0.1;
		192.168.254.0/24;
		192.136.111.0/24;
	};
	masters {
		192.136.111.40;
	};
};
''')# .split('\n')
	fhout = open('/tmp/named.conf', 'w')
	fhout.write(testinput)
	fhout.close()
	# print testinput
	t = Config(open('/tmp/named.conf'))
#	for key, opts, ndx in t.get_line_parts(): #{
#		if opts: print key, eval(opts[0]), ndx
#		else: print key, '', ndx
#	#}
	for line in t.lines: #{
		print line;
		args = line.split()
		idx = int(args[len(args) - 1][:-1])
		txta = t.get_text_array(idx)
		print txta
	#}
	# print "\n".join(t.dumpall())
	print t.dumpall()
#}
