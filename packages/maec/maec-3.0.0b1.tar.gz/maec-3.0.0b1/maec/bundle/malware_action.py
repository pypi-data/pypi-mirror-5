#MAEC Malware Action Class

#Copyright (c) 2013, The MITRE Corporation
#All rights reserved.

#Compatible with MAEC v3.0
#Last updated 04/10/2013

import maec.bindings.maec_bundle_3_0 as bundle_binding
import cybox.utils as utils
from cybox.core.action import Action

class MalwareAction(Action):
    superclass = Action

    def __init__(self):
        super(MalwareAction, self).__init__()
        #if id is not None:
        #    self.id = id
        #elif generator is not None:
        #    self.generator = generator
        #    self.id = self.generator.generate_action_id()
        #else:
        #    raise Exception("Must specify id or generator for MalwareAction constructor")
        self.implementation = None

    def to_obj(self):
        action_obj = super(MalwareAction, self).to_obj(bundle_binding.MalwareActionType(id=self.id))
        if self.implementation is not None: action_obj.set_Implementation(self.implementation.to_obj())
        return action_obj

    def to_dict(self):
        pass

    #Build the Action from the input dictionary
    @staticmethod
    def from_dict(malware_action_dict):
        if not malware_action_dict:
            return None
        malware_action_ = Action.from_dict(malware_action_dict, MalwareAction())
        malware_action_.implementation = ActionImplementation.from_dict(malware_action_dict.get('implementation'))
        return malware_action_

    #Parse the action into a dictionary
    @classmethod
    def from_obj(action_obj):
        pass

class ActionImplementation(object):
    def __init__(self):
        self.id = None
        self.type = None
        self.compatible_platforms = []
        self.api_call = None
        self.code = []

    def to_obj(self):
        implementation_obj = bundle_binding.ActionImplementationType()
        if self.id is not None: implementation_obj.set_id(self.id)
        if self.type is not None: implementation_obj.set_type(self.type) 
        if self.compatible_platforms is not None: pass 
            #platform_list_obj = bundle_binding.PlatformListType()
            #for platform in self.compatible_platforms:
            #    platform_list_obj.add_Platform(platform.to_obj())
            #implementation_obj.set_Compatible_Platforms(platform_list_obj)
        if self.api_call is not None: implementation_obj.set_API_Call(self.api_call.to_obj())
        if self.code is not None: pass
        return implementation_obj

    def to_dict(self):
        pass

    @staticmethod
    def from_dict(implementation_dict):
        if not implementation_dict:
            return None
        implementation_ = ActionImplementation()
        implementation_.id = implementation_dict.get('id')
        implementation_.type = implementation_dict.get('type')
        #implementation_.compatible_platforms = implementation_dict.get('compatible_platforms')
        implementation_.api_call = APICall.from_dict(implementation_dict.get('api_call'))
        #implementation_.code = implementation_dict.get('code')

    @staticmethod
    def from_obj(implementation_obj):
        pass

class APICall(object):
    def __init__(self):
        self.function_name = None
        self.normalized_function_name = None
        self.address = None
        self.return_value = None
        self.parameters = []

    def to_obj(self):
        api_call_obj = bundle_binding.APICallType()
        if self.function_name is not None: api_call_obj.set_function_name(self.function_name)
        if self.normalized_function_name is not None: api_call_obj.set_normalized_function_name(self.normalized_function_name)
        if self.address is not None: api_call_obj.set_address(self.normalized_function_name)
        if self.return_value is not None: api_call_obj.set_return_value(self.return_value)
        if self.parameters is not None: 
            parameter_list_obj = bundle_binding.ParameterListType()
            for parameter in self.parameters:
                parameter_list_obj.add_Parameter(parameter.to_obj())
            api_call_obj.set_Parameters(parameter_list_obj)
        return api_call_obj

    def to_dict(self):
        pass

    @staticmethod
    def from_dict(api_call_dict):
        if not api_call_dict:
            return None
        api_call_ = APICall()
        api_call_.function_name = api_call_dict.get('function_name')
        api_call_.normalized_function_name = api_call_dict.get('normalized_function_name')
        api_call_.address = api_call_dict.get('address')
        api_call_.return_value = api_call_dict.get('return_value')
        api_call_.parameters = [Parameter.from_dict(x) for x in api_call_dict.get('parameters')]
        return api_call_

    @staticmethod
    def from_obj(api_call_obj):
        pass

class Parameter(object):
    def __init__(self):
        self.ordinal_position = None
        self.name = None
        self.value = None

    def to_obj(self):
        parameter_obj = bundle_binding.ParameterType()
        if self.ordinal_position is not None: parameter_obj.set_ordinal_position(self.ordinal_position)
        if self.name is not None: parameter_obj.set_name(self.name)
        if self.value is not None: parameter_obj.set_value(self.value)
        return parameter_obj

    def to_dict(self):
        pass

    @staticmethod
    def from_dict(parameter_dict):
        if not parameter_dict:
            return None
        parameter_ = Parameter()
        parameter_.ordinal_position = parameter_dict.get('ordinal_position')
        parameter_.name = parameter_dict.get('name')
        parameter_.value = parameter_dict.get('value')
        return parameter_

    @staticmethod
    def from_obj(parameter_obj):
        pass