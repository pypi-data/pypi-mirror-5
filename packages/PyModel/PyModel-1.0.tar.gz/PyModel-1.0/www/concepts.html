<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>PyModel concepts and vocabulary</title>
</head>
<body>

<h2>PyModel concepts and vocabulary</h2>

<p>
<a href="index.html">PyModel</a> is an open-source model-based testing
framework in Python.

<hr>

<p>
In model-based testing, you code a <em>model</em> that generates and checks as
many test cases as desired.

<p>
A model can generate behaviors in the form of <em>traces</em>: sequences of
<em>actions</em>.  <em>Controllable actions</em> represent function
calls that the <em>tester</em> <a href="pmt.html">pmt</a> can make to
cause the <em>implementation</em> under test do something (for
example, send a message). <em>Observable actions</em> represent events
that the tester can detect in the implementation (for example, receive
a message).  A trace can be used as a <em>test case</em>: the tester
uses the trace to execute and monitor the implementation during
a <em>test run</em>.  The actions in the trace contain all the
information (return values, message contents) that the tester needs to
check whether the implementation passes or fails the test case.
A <em>test suite</em> is a collection of related test cases (traces).

<p>
Each trace should end in an <em>accepting state</em> where no work is left
unfinished (for example, no open connections).  A model can identify
<em>cleanup actions</em> that make progress toward an accepting state (for
example, by closing connections).

<p>
The tester connects to the implementation through a <em>test harness</em>
called a <em>stepper</em>.

<p>
In <em>offline</em> testing, test suites are generated from the model in
advance, then executed later by the tester.  In <em>on-the-fly</em> testing,
test cases are generated by the tester while the test run is
executing.  On-the-fly testing can execute indefinitely long
nonrepeating test runs.  An offline test generator or on-the-fly test
runner can use an optional <em>strategy</em> to select among possible traces
in order to improve test coverage (the default strategy is random
selection).

<p>
PyModel supports three ways to write models: <em>model
programs</em>, <em>finite state machines</em> (FSMs), and test suites
(test suites can also act as models).  PyModel can
use <em>composition</em> to combine models into a new model called
the <em>product</em>.  A typical use of composition is to combine a model
program with an FSM that represents a scenario in order to generate a
test suite.

<p>
Before generating tests from a model, it is helpful to use an
<em>analyzer</em> to visualize the model's behaviors.  PyModel
provides an analyzer tool <a href="pma.html">pma</a> that generates an
FSM from a model, using a procedure called <em>exploration</em>.  Each
transition in the FSM represents an action, and each path through the
FSM represents a trace.

<p>
The same concepts are used
by <a href="http://www.codeplex.com/NModel/">NModel</a> (but PyModel
is not a translation or re-implementation of NModel).  The concepts
are explained in the book, 
<a href="http://www.cambridge.org/us/catalogue/catalogue.asp?isbn=9780521687614"><em>Model-based
Software Testing and Analysis with C#</em></a>.

<hr>

Revised January 2010

</body>
</html>
