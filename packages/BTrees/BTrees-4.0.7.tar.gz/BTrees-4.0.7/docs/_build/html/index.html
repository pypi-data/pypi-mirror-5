

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>BTrees Documentation &mdash; BTrees 4.0.2dev documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '4.0.2dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="BTrees 4.0.2dev documentation" href="#" />
    <link rel="next" title="BTrees API Reference" href="api.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api.html" title="BTrees API Reference"
             accesskey="N">next</a> |</li>
        <li><a href="#">BTrees 4.0.2dev documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="btrees-documentation">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">BTrees</span></tt> Documentation<a class="headerlink" href="#btrees-documentation" title="Permalink to this headline">¶</a></h1>
<p>This package contains a set of persistent object containers built around
a modified BTree data structure.  The trees are optimized for use inside
ZODB&#8217;s &#8220;optimistic concurrency&#8221; paradigm, and include explicit resolution
of conflicts detected by that mechannism.</p>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="api.html"><tt class="docutils literal"><span class="pre">BTrees</span></tt> API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-BTrees.Interfaces">Protocol APIs</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>When programming with the ZODB, Python dictionaries aren&#8217;t always what you
need.  The most important case is where you want to store a very large
mapping.  When a Python dictionary is accessed in a ZODB, the whole
dictionary has to be unpickled and brought into memory.  If you&#8217;re storing
something very large, such as a 100,000-entry user database, unpickling
such a large object will be slow.  BTrees are a balanced tree data
structure that behave like a mapping but distribute keys throughout a
number of tree nodes.  The nodes are stored in sorted order (this has
important consequences &#8211; see below).  Nodes are then only unpickled and
brought into memory as they&#8217;re accessed, so the entire tree doesn&#8217;t have to
occupy memory (unless you really are touching every single key).</p>
<p>The BTrees package provides a large collection of related data structures.
There are variants of the data structures specialized to integers, which
are faster and use less memory.  There are five modules that handle the
different variants.  The first two letters of the module name specify the
types of the keys and values in mappings &#8211; O for any object, I for 32-bit
signed integer, and (new in ZODB 3.4) F for 32-bit C float.  For example,
the <tt class="xref py py-mod docutils literal"><span class="pre">BTrees.IOBTree</span></tt> module provides a mapping with integer keys and
arbitrary objects as values.</p>
<p>The four data structures provide by each module are a BTree, a Bucket, a
TreeSet, and a Set.  The BTree and Bucket types are mappings and support
all the usual mapping methods, e.g. <tt class="xref py py-func docutils literal"><span class="pre">update()</span></tt> and <tt class="xref py py-func docutils literal"><span class="pre">keys()</span></tt>.  The
TreeSet and Set types are similar to mappings but they have no values; they
support the methods that make sense for a mapping with no keys, e.g.
<tt class="xref py py-func docutils literal"><span class="pre">keys()</span></tt> but not <tt class="xref py py-func docutils literal"><span class="pre">items()</span></tt>.  The Bucket and Set types are the
individual building blocks for BTrees and TreeSets, respectively.  A Bucket
or Set can be used when you are sure that it will have few elements.  If
the data structure will grow large, you should use a BTree or TreeSet. Like
Python lists, Buckets and Sets are allocated in one contiguous piece, and
insertions and deletions can take time proportional to the number of
existing elements.  Also like Python lists, a Bucket or Set is a single
object, and is pickled and unpickled in its entirety.  BTrees and TreeSets
are multi-level tree structures with much better (logarithmic) worst- case
time bounds, and the tree structure is built out of multiple objects, which
ZODB can load individually as needed.</p>
<p>The five modules are named <tt class="xref py py-mod docutils literal"><span class="pre">OOBTree</span></tt>, <tt class="xref py py-mod docutils literal"><span class="pre">IOBTree</span></tt>, <tt class="xref py py-mod docutils literal"><span class="pre">OIBTree</span></tt>,
<tt class="xref py py-mod docutils literal"><span class="pre">IIBTree</span></tt>, and (new in ZODB 3.4) <tt class="xref py py-mod docutils literal"><span class="pre">IFBTree</span></tt>.  The two letter
prefixes are repeated in the data types names.  The <tt class="xref py py-mod docutils literal"><span class="pre">BTrees.OOBTree</span></tt>
module defines the following types: <tt class="xref py py-class docutils literal"><span class="pre">OOBTree</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">OOBucket</span></tt>,
<tt class="xref py py-class docutils literal"><span class="pre">OOSet</span></tt>, and <tt class="xref py py-class docutils literal"><span class="pre">OOTreeSet</span></tt>. Similarly, the other four modules
each define their own variants of those four types.</p>
<p>The <tt class="xref py py-func docutils literal"><span class="pre">keys()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">values()</span></tt>, and <tt class="xref py py-func docutils literal"><span class="pre">items()</span></tt> methods on BTree and
TreeSet types do not materialize a list with all of the data.  Instead,
they return lazy sequences that fetch data from the BTree as needed.  They
also support optional arguments to specify the minimum and maximum values
to return, often called &#8220;range searching&#8221;.  Because all these types are
stored in sorted order, range searching is very efficient.</p>
<p>The <tt class="xref py py-func docutils literal"><span class="pre">keys()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">values()</span></tt>, and <tt class="xref py py-func docutils literal"><span class="pre">items()</span></tt> methods on Bucket and
Set types do return lists with all the data. Starting in ZODB 3.3, there
are also <tt class="xref py py-func docutils literal"><span class="pre">iterkeys()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">itervalues()</span></tt>, and <tt class="xref py py-func docutils literal"><span class="pre">iteritems()</span></tt>
methods that return iterators (in the Python 2.2 sense).  Those methods
also apply to BTree and TreeSet objects.</p>
<p>A BTree object supports all the methods you would expect of a mapping, with
a few extensions that exploit the fact that the keys are sorted. The
example below demonstrates how some of the methods work.  The extra methods
are <tt class="xref py py-func docutils literal"><span class="pre">minKey()</span></tt> and <tt class="xref py py-func docutils literal"><span class="pre">maxKey()</span></tt>, which find the minimum and maximum
key value subject to an optional bound argument, and <tt class="xref py py-func docutils literal"><span class="pre">byValue()</span></tt>, which
should probably be ignored (it&#8217;s hard to explain exactly what it does, and
as a result it&#8217;s almost never used &#8211; best to consider it deprecated).  The
various methods for enumerating keys, values and items also accept minimum
and maximum key arguments (&#8220;range search&#8221;), and (new in ZODB 3.3) optional
Boolean arguments to control whether a range search is inclusive or
exclusive of the range&#8217;s endpoints.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">BTrees.OOBTree</span> <span class="kn">import</span> <span class="n">OOBTree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">OOBTree</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="s">&quot;red&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s">&quot;green&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s">&quot;blue&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="s">&quot;spades&quot;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">&#39;green&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="c"># this is a &quot;lazy&quot; sequence object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;OOBTreeItems object at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c"># it acts like a Python list</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c"># materialize the full list</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="go">[&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;spades&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c"># values at keys in 1 to 2 inclusive</span>
<span class="go">[&#39;red&#39;, &#39;green&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>    <span class="c"># values at keys &gt;= 2</span>
<span class="go">[&#39;green&#39;, &#39;blue&#39;, &#39;spades&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>  <span class="c"># keyword args new in ZODB 3.3</span>
<span class="go">[&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;spades&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">excludemin</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">excludemax</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">[&#39;green&#39;, &#39;blue&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">minKey</span><span class="p">()</span>     <span class="c"># smallest key</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">minKey</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>  <span class="c"># smallest key &gt;= 1.5</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">k</span><span class="p">,</span>
<span class="go">1 2 3 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>    <span class="c"># new in ZODB 3.3</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">k</span><span class="p">,</span>
<span class="go">1 2 3 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>  <span class="c"># new in ZODB 3.3</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">pair</span><span class="p">,</span>
<span class="gp">...</span>
<span class="go">(1, &#39;red&#39;) (2, &#39;green&#39;) (3, &#39;blue&#39;) (4, &#39;spades&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c"># returns a true value, but exactly what undefined</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">4</span> <span class="ow">in</span> <span class="n">t</span>  <span class="c"># new in ZODB 3.3</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">5</span> <span class="ow">in</span> <span class="n">t</span>  <span class="c"># new in ZODB 3.3</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Each of the modules also defines some functions that operate on BTrees &#8211;
<tt class="xref py py-func docutils literal"><span class="pre">difference()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">union()</span></tt>, and <tt class="xref py py-func docutils literal"><span class="pre">intersection()</span></tt>.  The
<tt class="xref py py-func docutils literal"><span class="pre">difference()</span></tt> function returns a Bucket, while the other two methods return
a Set. If the keys are integers, then the module also defines
<tt class="xref py py-func docutils literal"><span class="pre">multiunion()</span></tt>.  If the values are integers or floats, then the module also
defines <tt class="xref py py-func docutils literal"><span class="pre">weightedIntersection()</span></tt> and <tt class="xref py py-func docutils literal"><span class="pre">weightedUnion()</span></tt>.  The function
doc strings describe each function briefly.</p>
<p><tt class="docutils literal"><span class="pre">BTrees/Interfaces.py</span></tt> defines the operations, and is the official
documentation.  Note that the interfaces don&#8217;t define the concrete types
returned by most operations, and you shouldn&#8217;t rely on the concrete types that
happen to be returned:  stick to operations guaranteed by the interface.  In
particular, note that the interfaces don&#8217;t specify anything about comparison
behavior, and so nothing about it is guaranteed.  In ZODB 3.3, for example, two
BTrees happen to use Python&#8217;s default object comparison, which amounts to
comparing the (arbitrary but fixed) memory addresses of the BTrees. This may or
may not be true in future releases. If the interfaces don&#8217;t specify a behavior,
then whether that behavior appears to work, and exactly happens if it does
appear to work, are undefined and should not be relied on.</p>
</div>
<div class="section" id="total-ordering-and-persistence">
<h2>Total Ordering and Persistence<a class="headerlink" href="#total-ordering-and-persistence" title="Permalink to this headline">¶</a></h2>
<p>The BTree-based data structures differ from Python dicts in several fundamental
ways.  One of the most important is that while dicts require that keys support
hash codes and equality comparison, the BTree-based structures don&#8217;t use hash
codes and require a total ordering on keys.</p>
<p>Total ordering means three things:</p>
<ol class="arabic simple">
<li>Reflexive.  For each <em>x</em>, <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">x</span></tt> is true.</li>
<li>Trichotomy.  For each <em>x</em> and <em>y</em>, exactly one of <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></tt>, <tt class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></tt>, and
<tt class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></tt> is true.</li>
<li>Transitivity.  Whenever <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></tt> and <tt class="docutils literal"><span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></tt>, it&#8217;s also true that <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span>
<span class="pre">z</span></tt>.</li>
</ol>
<p>The default comparison functions for most objects that come with Python satisfy
these rules, with some crucial cautions explained later.  Complex numbers are an
example of an object whose default comparison function does not satisfy these
rules:  complex numbers only support <tt class="docutils literal"><span class="pre">==</span></tt> and <tt class="docutils literal"><span class="pre">!=</span></tt> comparisons, and raise an
exception if you try to compare them in any other way.  They don&#8217;t satisfy the
trichotomy rule, and must not be used as keys in BTree-based data structures
(although note that complex numbers can be used as keys in Python dicts, which
do not require a total ordering).</p>
<p>Examples of objects that are wholly safe to use as keys in BTree-based
structures include ints, longs, floats, 8-bit strings, Unicode strings, and
tuples composed (possibly recursively) of objects of wholly safe types.</p>
<p>It&#8217;s important to realize that even if two types satisfy the rules on their own,
mixing objects of those types may not.  For example, 8-bit strings and Unicode
strings both supply total orderings, but mixing the two loses trichotomy; e.g.,
<tt class="docutils literal"><span class="pre">'x'</span> <span class="pre">&lt;</span> <span class="pre">chr(255)</span></tt> and <tt class="docutils literal"><span class="pre">u'x'</span> <span class="pre">==</span> <span class="pre">'x'</span></tt>, but trying to compare <tt class="docutils literal"><span class="pre">chr(255)</span></tt> to
<tt class="docutils literal"><span class="pre">u'x'</span></tt> raises an exception.  Partly for this reason (another is given later),
it can be dangerous to use keys with multiple types in a single BTree-based
structure.  Don&#8217;t try to do that, and you don&#8217;t have to worry about it.</p>
<p>Another potential problem is mutability:  when a key is inserted in a BTree-
based structure, it must retain the same order relative to the other keys over
time.  This is easy to run afoul of if you use mutable objects as keys.  For
example, lists supply a total ordering, and then</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">L1</span><span class="p">,</span> <span class="n">L2</span><span class="p">,</span> <span class="n">L3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">BTrees.OOBTree</span> <span class="kn">import</span> <span class="n">OOSet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">OOSet</span><span class="p">((</span><span class="n">L2</span><span class="p">,</span> <span class="n">L3</span><span class="p">,</span> <span class="n">L1</span><span class="p">))</span>  <span class="c"># this is fine, so far</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>           <span class="c"># note that the lists are in sorted order</span>
<span class="go">[[1], [2], [3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">has_key</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>           <span class="c"># and [3] is in the set</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>                <span class="c"># horrible -- the set is insane now</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">has_key</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>           <span class="c"># for example, it&#39;s insane this way</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">OOSet([[1], [5], [3]])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Key lookup relies on that the keys remain in sorted order (an efficient form of
binary search is used).  By mutating key L2 after inserting it, we destroyed the
invariant that the OOSet is sorted.  As a result, all future operations on this
set are unpredictable.</p>
<p>A subtler variant of this problem arises due to persistence:  by default, Python
does several kinds of comparison by comparing the memory addresses of two
objects.  Because Python never moves an object in memory, this does supply a
usable (albeit arbitrary) total ordering across the life of a program run (an
object&#8217;s memory address doesn&#8217;t change).  But if objects compared in this way
are used as keys of a BTree-based structure that&#8217;s stored in a database, when
the objects are loaded from the database again they will almost certainly wind
up at different memory addresses.  There&#8217;s no guarantee then that if key K1 had
a memory address smaller than the memory address of key K2 at the time K1 and K2
were inserted in a BTree, K1&#8217;s address will also be smaller than K2&#8217;s when that
BTree is loaded from a database later.  The result will be an insane BTree,
where various operations do and don&#8217;t work as expected, seemingly at random.</p>
<p>Now each of the types identified above as &#8220;wholly safe to use&#8221; never compares
two instances of that type by memory address, so there&#8217;s nothing to worry about
here if you use keys of those types.  The most common mistake is to use keys
that are instances of a user-defined class that doesn&#8217;t supply its own
<tt class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></tt> method.  Python compares such instances by memory address.  This
is fine if such instances are used as keys in temporary BTree-based structures
used only in a single program run.  It can be disastrous if that BTree-based
structure is stored to a database, though.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="p">(),</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>   <span class="c"># this may print 0 if you try it</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="p">(),</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>   <span class="c"># and this may print 0 or 1</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>That example illustrates that comparison of instances of classes that don&#8217;t
define <tt class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></tt> yields arbitrary results (but consistent results within a
single program run).</p>
<p>Another problem occurs with instances of classes that do define <tt class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></tt>,
but define it incorrectly.  It&#8217;s possible but rare for a custom <tt class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></tt>
implementation to violate one of the three required formal properties directly.
It&#8217;s more common for it to &#8220;fall back&#8221; to address-based comparison by mistake.
For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Mine</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">__class__</span> <span class="ow">is</span> <span class="n">Mine</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
</pre></div>
</div>
<p>It&#8217;s quite possible there that the <a class="reference external" href="http://docs.python.org/reference/compound_stmts.html#else" title="(in Python v2.7)"><tt class="xref std std-keyword docutils literal"><span class="pre">else</span></tt></a> clause allows a result to be
computed based on memory address.  The bug won&#8217;t show up until a BTree-based
structure uses objects of class <tt class="xref py py-class docutils literal"><span class="pre">Mine</span></tt> as keys, and also objects of other
types as keys, and the structure is loaded from a database, and a sequence of
comparisons happens to execute the <a class="reference external" href="http://docs.python.org/reference/compound_stmts.html#else" title="(in Python v2.7)"><tt class="xref std std-keyword docutils literal"><span class="pre">else</span></tt></a> clause in a case where the
relative order of object memory addresses happened to change.</p>
<p>This is as difficult to track down as it sounds, so best to stay far away from
the possibility.</p>
<p>You&#8217;ll stay out of trouble by follwing these rules, violating them only with
great care:</p>
<ol class="arabic">
<li><p class="first">Use objects of simple immutable types as keys in BTree-based data structures.</p>
</li>
<li><p class="first">Within a single BTree-based data structure, use objects of a single type as
keys.  Don&#8217;t use multiple key types in a single structure.</p>
</li>
<li><p class="first">If you want to use class instances as keys, and there&#8217;s any possibility that
the structure may be stored in a database, it&#8217;s crucial that the class define a
<tt class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></tt> method, and that the method is carefully implemented.</p>
<p>Any part of a comparison implementation that relies (explicitly or implicitly)
on an address-based comparison result will eventually cause serious failure.</p>
</li>
<li><p class="first">Do not use <tt class="xref py py-class docutils literal"><span class="pre">Persistent</span></tt> objects as keys, or objects of a subclass of
<tt class="xref py py-class docutils literal"><span class="pre">Persistent</span></tt>.</p>
</li>
</ol>
<p>That last item may be surprising.  It stems from details of how conflict
resolution is implemented:  the states passed to conflict resolution do not
materialize persistent subobjects (if a persistent object P is a key in a BTree,
then P is a subobject of the bucket containing P).  Instead, if an object O
references a persistent subobject P directly, and O is involved in a conflict,
the states passed to conflict resolution contain an instance of an internal
<tt class="xref py py-class docutils literal"><span class="pre">PersistentReference</span></tt> stub class everywhere O references P. Two
<tt class="xref py py-class docutils literal"><span class="pre">PersistentReference</span></tt> instances compare equal if and only if they
&#8220;represent&#8221; the same persistent object; when they&#8217;re not equal, they compare by
memory address, and, as explained before, memory-based comparison must never
happen in a sane persistent BTree.  Note that it doesn&#8217;t help in this case if
your <tt class="xref py py-class docutils literal"><span class="pre">Persistent</span></tt> subclass defines a sane <tt class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></tt> method:
conflict resolution doesn&#8217;t know about your class, and so also doesn&#8217;t know
about its <tt class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></tt> method.  It only sees instances of the internal
<tt class="xref py py-class docutils literal"><span class="pre">PersistentReference</span></tt> stub class.</p>
</div>
<div class="section" id="iteration-and-mutation">
<h2>Iteration and Mutation<a class="headerlink" href="#iteration-and-mutation" title="Permalink to this headline">¶</a></h2>
<p>As with a Python dictionary or list, you should not mutate a BTree-based data
structure while iterating over it, except that it&#8217;s fine to replace the value
associated with an existing key while iterating.  You won&#8217;t create internal
damage in the structure if you try to remove, or add new keys, while iterating,
but the results are undefined and unpredictable.  A weak attempt is made to
raise <tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt> if the size of a BTree-based structure changes while
iterating, but it doesn&#8217;t catch most such cases, and is also unreliable.
Example</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">BTrees.IIBTree</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">IISet</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>  <span class="c"># the output is undefined</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">i</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">s</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">0 2 4 6 8</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">RuntimeError</span>: <span class="n">the bucket being iterated changed size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>      <span class="c"># this output is also undefined</span>
<span class="go">[1, 3, 5, 7, 9]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Also as with Python dictionaries and lists, the safe and predictable way to
mutate a BTree-based structure while iterating over it is to iterate over a copy
of the keys.  Example</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">BTrees.IIBTree</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">IISet</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>  <span class="c"># this is well defined</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">i</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">s</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">0 1 2 3 4 5 6 7 8 9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="btree-diagnostic-tools">
<h2>BTree Diagnostic Tools<a class="headerlink" href="#btree-diagnostic-tools" title="Permalink to this headline">¶</a></h2>
<p>A BTree (or TreeSet) is a complex data structure, really a graph of variable-
size nodes, connected in multiple ways via three distinct kinds of C pointers.
There are some tools available to help check internal consistency of a BTree as
a whole.</p>
<p>Most generally useful is the <tt class="xref py py-mod docutils literal"><span class="pre">BTrees.check</span></tt> module.  The
<tt class="xref py py-func docutils literal"><span class="pre">check.check()</span></tt> function examines a BTree (or Bucket, Set, or TreeSet) for
value-based consistency, such as that the keys are in strictly increasing order.
See the function docstring for details. The <tt class="xref py py-func docutils literal"><span class="pre">check.display()</span></tt> function
displays the internal structure of a BTree.</p>
<p>BTrees and TreeSets also have a <tt class="xref py py-meth docutils literal"><span class="pre">_check()</span></tt> method.  This verifies that the
(possibly many) internal pointers in a BTree or TreeSet are mutually consistent,
and raises <tt class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></tt> if they&#8217;re not.</p>
<p>If a <tt class="xref py py-func docutils literal"><span class="pre">check.check()</span></tt> or <tt class="xref py py-meth docutils literal"><span class="pre">_check()</span></tt> call fails, it may point to a bug in
the implementation of BTrees or conflict resolution, or may point to database
corruption.</p>
<p>Repairing a damaged BTree is usually best done by making a copy of it. For
example, if <em>self.data</em> is bound to a corrupted IOBTree,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">IOBTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>usually suffices.  If object identity needs to be preserved,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">acopy</span> <span class="o">=</span> <span class="n">IOBTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">acopy</span><span class="p">)</span>
</pre></div>
</div>
<p>does the same, but leaves <em>self.data</em> bound to the same object.</p>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">BTrees</span></tt> Documentation</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#total-ordering-and-persistence">Total Ordering and Persistence</a></li>
<li><a class="reference internal" href="#iteration-and-mutation">Iteration and Mutation</a></li>
<li><a class="reference internal" href="#btree-diagnostic-tools">BTree Diagnostic Tools</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

  <h4>Next topic</h4>
  <p class="topless"><a href="api.html"
                        title="next chapter"><tt class="docutils literal docutils literal"><span class="pre">BTrees</span></tt> API Reference</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api.html" title="BTrees API Reference"
             >next</a> |</li>
        <li><a href="#">BTrees 4.0.2dev documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Zope Foundation Contributors.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>