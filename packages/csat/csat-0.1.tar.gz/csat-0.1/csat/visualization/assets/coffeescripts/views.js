// Generated by CoffeeScript 1.4.0
(function() {
  var MultipleViewportsRenderer, RotatingViewport, Viewport,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Viewport = (function() {
    /*
        An area of the renderer element which can be drawn independently. Uses
        the same global scene with independent cameras.
    */

    function Viewport(params) {
      this.x = params.x, this.y = params.y, this.width = params.width, this.height = params.height, this.camera = params.camera, this.controls = params.controls;
      this.camera.position.z = 90;
    }

    Viewport.prototype.prepareScene = function(scene) {
      return this.camera.lookAt(scene.position);
    };

    Viewport.prototype.prepareRenderer = function(renderer, width, height) {
      var h, w, x, y;
      x = Math.floor(width * this.x);
      y = Math.floor(height * this.y);
      w = Math.floor(width * this.width);
      h = Math.floor(height * this.height);
      this.camera.aspect = w / h;
      renderer.setViewport(x, y, w, h);
      renderer.setScissor(x, y, w, h);
      return renderer.enableScissorTest(true);
    };

    return Viewport;

  })();

  RotatingViewport = (function(_super) {

    __extends(RotatingViewport, _super);

    function RotatingViewport(params) {
      this.radius = params.radius, this.speed = params.speed, this.axis = params.axis;
      this.phi = 0;
      RotatingViewport.__super__.constructor.apply(this, arguments);
    }

    RotatingViewport.prototype.prepareRenderer = function(renderer) {
      return RotatingViewport.__super__.prepareRenderer.apply(this, arguments);
    };

    RotatingViewport.prototype.prepareScene = function(scene) {
      this.phi += this.speed;
      if (this.axis === 'x') {
        this.camera.position.x = this.radius * Math.sin(this.phi * Math.PI / 360);
        this.camera.position.z = this.radius * Math.cos(this.phi * Math.PI / 360);
      } else if (this.axis === 'z') {
        this.camera.position.y = this.radius * Math.sin(this.phi * Math.PI / 360);
        this.camera.position.z = this.radius * Math.cos(this.phi * Math.PI / 360);
      } else if (this.axis === 'y') {
        this.camera.rotation.x = this.phi;
      }
      return RotatingViewport.__super__.prepareScene.call(this, scene);
    };

    return RotatingViewport;

  })(Viewport);

  MultipleViewportsRenderer = (function() {

    function MultipleViewportsRenderer(container, scene, viewports) {
      this.container = container;
      this.scene = scene;
      this.viewports = viewports;
      this.renderer = new THREE.WebGLRenderer({
        antialias: true,
        preserveDrawingBuffer: true
      });
      this.renderer.setClearColor(0xffffff, 1);
      this.container.append(this.renderer.domElement);
      this.preparePositionIndicator();
      this.stats = new Stats();
      this.stats.setMode(1);
      this.stats.domElement.style.position = 'absolute';
      this.stats.domElement.style.left = '0px';
      this.stats.domElement.style.top = '0px';
      $(this.stats.domElement).appendTo(this.container);
    }

    MultipleViewportsRenderer.prototype.preparePositionIndicator = function() {
      var x, xg, xm, y, yg, ym, z, zg, zm;
      this.position = new THREE.Object3D();
      xg = new THREE.Geometry();
      xg.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(10, 0, 0));
      xm = new THREE.LineBasicMaterial({
        color: 0xff0000,
        linewidth: 10
      });
      x = new THREE.Line(xg, xm);
      x = new THREE.Mesh(new THREE.CylinderGeometry(.15, .15, 10, 5, 5, false), xm);
      z.position.z = 5;
      this.position.add(x);
      yg = new THREE.Geometry();
      yg.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 10, 0));
      ym = new THREE.LineBasicMaterial({
        color: 0x00ff00,
        linewidth: 10
      });
      y = new THREE.Line(yg, ym);
      y = new THREE.Mesh(new THREE.CylinderGeometry(.15, .15, 10, 5, 5, false), ym);
      y.rotation.z = Math.PI / 2;
      y.position.y = 5;
      this.position.add(y);
      zg = new THREE.Geometry();
      zg.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 10));
      zm = new THREE.LineBasicMaterial({
        color: 0x0000ff,
        linewidth: 10
      });
      z = new THREE.Line(zg, zm);
      z = new THREE.Mesh(new THREE.CylinderGeometry(.15, .15, 10, 5, 5, false), zm);
      z.rotation.x = Math.PI / 2;
      z.position.z = 5;
      this.position.add(z);
      return this.scene.add(this.position);
    };

    MultipleViewportsRenderer.prototype.render = function() {
      var height, viewport, width, _i, _len, _ref, _ref1, _results;
      _ref = [this.container.width(), this.container.height()], width = _ref[0], height = _ref[1];
      this.renderer.setSize(width, height);
      width *= window.devicePixelRatio;
      height *= window.devicePixelRatio;
      _ref1 = this.viewports;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        viewport = _ref1[_i];
        viewport.prepareScene(this.scene);
        viewport.prepareRenderer(this.renderer, width, height);
        viewport.camera.updateProjectionMatrix();
        this.renderer.render(this.scene, viewport.camera);
        if (viewport.controls != null) {
          _results.push(viewport.controls.update());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    MultipleViewportsRenderer.prototype.animate = function() {
      var animate,
        _this = this;
      animate = function() {
        requestAnimationFrame(animate);
        _this.render();
        return _this.stats.update();
      };
      return animate();
    };

    return MultipleViewportsRenderer;

  })();

}).call(this);
