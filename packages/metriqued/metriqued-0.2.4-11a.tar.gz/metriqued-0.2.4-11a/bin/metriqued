#!/usr/bin/env python
# vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
# Author: "Chris Ward <cward@redhat.com>

'''
metrique-server.py contains a CLI for metrique server.

    It is possible to start, stop, restart and request
    current running status for metriqued

    # ... ^^^ cube class definition above ^^^ ...
    if __name__ == '__main__':
        from metrique.argparsers import cube_cli
        obj, args = cube_cli(Bug)
        obj.extract(force=args.force)

'''

import os
import sys
import time
import traceback

from metriqued.config import metriqued_config
from metriqued.tornadohttp import TornadoHTTPServer
from metriqued.utils import get_pids


def stop(pid, sig=None):
    if not sig:
        sig = 15  # ie, SIGTERM
    code = 1  # not OK
    if pid and not status(pid):
        print "WARNING: pid file and pid found (%s)" % pid
        print "... but no process with that id is running"
    elif pid <= 0:
        print 'WARNING: invalid pid (%s)' % pid
    else:
        try:
            print "Sending signal (%s) to (%s)" % (sig, pid)
            os.kill(pid, sig)
            code = 0  # OK!
        except OSError as e:
            print 'STOP ERROR: %s' % e
            raise
    return code


def start(**kwargs):
    pid = kwargs.get('pid')
    if pid and status(pid):
        raise SystemExit("process already running... (%s)" % pid)

    metriqued = TornadoHTTPServer(**kwargs)
    try:
        metriqued.start()
    except RuntimeError as e:
        # already started...
        print 'START ERROR: metriqued already started; %s' % e
        print traceback.format_exc(e)
        # a pid file was possibly created; clean up
        stop(pid)
    except Exception as e:
        # a pid file was possibly created; clean up
        print 'START ERROR: %s' % e
        print traceback.format_exc(e)
        stop(pid)
    # after we've started, there's nothing left to do!
    sys.exit()


def restart(pid, signal=None, timeout=None, **kwargs):
    if timeout is None:
        timeout = -1
    if status(pid):
        stop(pid=pid, sig=sig)
    print "Waiting for process to stop..."
    while status(pid=pid):
        time.sleep(1)
        timeout -= 1
        if timeout == 0:
            print ('RESTART ERROR: timed out waiting for running '
                   'process to stop')
            break
    else:
        return start(**kwargs)


def status(pid, quiet=True):
    _pid = str(pid)
    pids = [p for p in os.listdir('/proc') if p.isdigit()]
    if pid and _pid in pids:
        if not quiet:
            print '[%s] Running' % pid
        return 1
    else:
        if not quiet:
            print '[%s] Not Running' % pid
        return 0


def pid_loop(pids, func, *args, **kwargs):
    return [func(pid=pid, *args, **kwargs) for pid in pids]


if __name__ == '__main__':
    import argparse

    _args = argparse.ArgumentParser(description='metrique server CLI')

    __cmds__ = ['start', 'stop', 'restart', 'status']
    _args.add_argument('command', type=str, choices=__cmds__)

    _args.add_argument('-d', '--debug',
                       type=int, default=True)
    _args.add_argument('--nofork', action='store_true')
    _args.add_argument('-c', '--server-config-file', type=str)
    _args.add_argument('-H', '--host', type=str)
    _args.add_argument('-P', '--port', type=str)
    _args.add_argument('-i', '--instances', type=int, default=1)
    _args.add_argument('-p', '--pid-dir', type=str, default='~/.metrique')
    _args.add_argument('-ps', '--pids', nargs='+', type=int)
    # 2 = SIGINT; 15 = SIGTERM
    _args.add_argument('-s', '--signal', type=int, choices=[2, 9])

    # parse sys.argv
    args = _args.parse_args()

    server_config_file = args.server_config_file
    mconf = metriqued_config(config_file=server_config_file)

    # shorten varnames
    cmd = args.command
    debug = args.debug

    host = args.host or mconf.host
    port = args.port or mconf.port
    nofork = args.nofork
    sig = args.signal

    kwargs = dict(host=host, port=port, debug=debug)

    pid_dir = os.path.expanduser(args.pid_dir)
    pids = args.pids or get_pids(pid_dir)

    if (len(pids) > 1 or args.instances > 1) and nofork:
        raise ValueError("must... fork!")

    if cmd == 'start':
        if nofork:
            start(**kwargs)
        else:
            pids = []
            for k in range(args.instances):
                pid = os.fork()
                if pid == 0:
                    start(**kwargs)
                else:
                    pids.append(pid)
                kwargs['port'] += 1
            print 'Started: %s' % ', '.join(map(str, pids))
    elif cmd == 'stop':
        pid_loop(pids, stop, sig=sig)
    elif cmd == 'restart':
        pid_loop(pids, restart, sig=sig, **kwargs)
    elif cmd == 'status':
        pid_loop(pids, status, quiet=False)
    else:
        raise SystemExit('bad command "%s"... Try --help' % cmd)
