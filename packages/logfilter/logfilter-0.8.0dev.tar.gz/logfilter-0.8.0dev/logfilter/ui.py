#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function

from .logfilter import StringVar
from ._compact import tkinter


class Filter(object):
    """
    Proxy of `Tkinter.Entry`, with an additional method to easily set the
    content of the text entry.
    """

    def __init__(self, parent, **options):
        """
        Constructor.

        @param options the list of options for the `Tkinter.Entry` constructor;
                       an additional 'value' option could be specified in order
                       to set the initial value of the filter.
        """
        # Store the variable, otherwise the callback won't be invoked;  it
        # is like tkinter makes use of weakrefs
        self._var = StringVar(options.pop('value', ''))

        options.update(textvariable=self._var)
        self._proxy = tkinter.Entry(parent, **options)

    def __getattr__(self, name):
        return getattr(self._proxy, name)

    def set(self, value):
        """
        Sets the value of the filter.

        @param value the new filter value.
        """
        self._proxy.delete(0, tkinter.END)
        self._proxy.insert(0, value)


class FilterWithPlaceholder(object):
    """
    Extension (by composition!) of the `Filter` class, enabling users to
    specify a _placeholder_ for the widget (i.e. text appearing within the 
    widget whenever the widget is empty).
    
    This widget also exposes two custom events, namely `<<TypingIn>>` and
    `<<TypingOut``, published when someone starts / finish to type into the
    widget.
    """

    def __init__(self, parent, **options):
        """
        Constructor.

        @param options the list of options of the `Tkinter.Frame` constructor;
                       an additional 'placeholder' option could be specified
                       in order to set the placeholder for the filter.
        """
        self._placeholder = options.pop('placeholder', '')

        if self._placeholder:
            options.update(value=self._placeholder)
        self._proxy = Filter(parent, **options)

        def _on_focus_in_event(evt):
            if self.get() == self._placeholder:
                self.set('')
            self.event_generate('<<TypingIn>>')
        self._proxy.bind('<FocusIn>', _on_focus_in_event)

        def _on_focus_out_event(evt):
            if self.get() == '':
                self.set(self._placeholder)
            self.event_generate('<<TypingOut>>')
        self._proxy.bind('<FocusOut>', _on_focus_out_event)

    def __getattr__(self, name):
        return getattr(self._proxy, name)


class FilterBar(object):
    """
    An horizontal frame of filters enabling users to add/remove filters
    dynamically (i.e. a filter is automatically removes whenever its content
    is an empty string;  a filter is pushed on the right of the frame whenever
    someone starts typing into the left-most filter).

    This widget also exposes a new custom event, `<<FiltersReady>>`, published
    when the `<Return>` event is generated by one of the managed filtes.
    """

    def __init__(self, parent, **kwargs):
        """
        Constructor.

        @param options the list of options for the `Tkinter.Frame` constructor;
                       an additional 'filter_values' option (list of strings)
                       could be specified in order to initialize the filter bar
                       with the specified set of filters.
        """
        filter_values = kwargs.pop('filter_values', [])

        self._proxy = tkinter.Frame(parent, **kwargs)

        last_filter = FilterWithPlaceholder(self._proxy,
                                            placeholder='<Add new>',
                                            foreground='#999')
        last_filter.grid(row=0, column=0, sticky='EW')
        last_filter.bind('<<TypingIn>>', lambda e: self.add_filter())

        self._filters = [last_filter]

        for value in filter_values:
            self.add_filter(value)

    def __getattr__(self, name):
        return getattr(self._proxy, name)

    def add_filter(self, value=''):
        """
        Adds a new filter with the specified value to the filter bar.

        @param value the filter value.
        @return the created filter
        """
        # Create the filter
        filter_ = FilterWithPlaceholder(self, value=value)
        filter_.focus_force()
        filter_.bind('<Return>',
                     lambda evt: self.event_generate('<<FiltersReady>>'))

        def _on_typing_out_event(evt):
            if filter_.get() == '':
                self._filters.remove(filter_)
                filter_.grid_forget()
                filter_.destroy()
        filter_.bind('<<TypingOut>>', _on_typing_out_event)

        # Push the filter in the list
        self._filters = self._filters[:-1] + [filter_] + [self._filters[-1]]

        # Refresh the grid
        for (i, curr) in enumerate(self._filters):
            curr.grid(row=0, column=i, sticky='EW')
            curr.lift()

        return filter_

    def get_filter_values(self):
        """
        Gets the values of the filters currently configured.

        @return the filter values.
        """
        return [f.get() for f in self._filters[:-1]] # Ignore placeholder
