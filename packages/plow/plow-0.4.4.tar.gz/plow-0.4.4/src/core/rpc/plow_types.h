/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef plow_TYPES_H
#define plow_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "common_types.h"


namespace Plow {

struct JobState {
  enum type {
    INITIALIZE = 0,
    RUNNING = 1,
    FINISHED = 2
  };
};

extern const std::map<int, const char*> _JobState_VALUES_TO_NAMES;

struct TaskState {
  enum type {
    INITIALIZE = 0,
    WAITING = 1,
    RUNNING = 2,
    DEAD = 3,
    EATEN = 4,
    DEPEND = 5,
    SUCCEEDED = 6
  };
};

extern const std::map<int, const char*> _TaskState_VALUES_TO_NAMES;

struct NodeState {
  enum type {
    UP = 0,
    DOWN = 1,
    REPAIR = 2
  };
};

extern const std::map<int, const char*> _NodeState_VALUES_TO_NAMES;

struct DependType {
  enum type {
    JOB_ON_JOB = 0,
    LAYER_ON_LAYER = 1,
    LAYER_ON_TASK = 2,
    TASK_ON_LAYER = 3,
    TASK_ON_TASK = 4,
    TASK_BY_TASK = 5
  };
};

extern const std::map<int, const char*> _DependType_VALUES_TO_NAMES;

struct MatcherType {
  enum type {
    CONTAINS = 0,
    NOT_CONTAINS = 1,
    IS = 2,
    IS_NOT = 3,
    BEGINS_WITH = 4,
    ENDS_WITH = 5
  };
};

extern const std::map<int, const char*> _MatcherType_VALUES_TO_NAMES;

struct MatcherField {
  enum type {
    JOB_NAME = 0,
    USER = 1,
    ATTR = 2
  };
};

extern const std::map<int, const char*> _MatcherField_VALUES_TO_NAMES;

struct ActionType {
  enum type {
    SET_FOLDER = 0,
    SET_MIN_CORES = 1,
    SET_MAX_CORES = 2,
    PAUSE = 3,
    STOP_PROCESSING = 4
  };
};

extern const std::map<int, const char*> _ActionType_VALUES_TO_NAMES;

typedef std::map<std::string, std::string>  Attrs;

typedef struct _PlowException__isset {
  _PlowException__isset() : what(false), why(false) {}
  bool what;
  bool why;
} _PlowException__isset;

class PlowException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "3F5FC93B338687BC7235B1AB103F47B3";
  static const uint8_t binary_fingerprint[16]; // = {0x3F,0x5F,0xC9,0x3B,0x33,0x86,0x87,0xBC,0x72,0x35,0xB1,0xAB,0x10,0x3F,0x47,0xB3};

  PlowException() : what(0), why() {
  }

  virtual ~PlowException() throw() {}

  int32_t what;
  std::string why;

  _PlowException__isset __isset;

  void __set_what(const int32_t val) {
    what = val;
  }

  void __set_why(const std::string& val) {
    why = val;
  }

  bool operator == (const PlowException & rhs) const
  {
    if (!(what == rhs.what))
      return false;
    if (!(why == rhs.why))
      return false;
    return true;
  }
  bool operator != (const PlowException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlowException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(PlowException &a, PlowException &b);

typedef struct _DependT__isset {
  _DependT__isset() : dependentLayerId(false), dependOnLayerId(false), dependentTaskId(false), dependOnTaskId(false), dependentLayerName(false), dependOnLayerName(false), dependentTaskName(false), dependOnTaskName(false) {}
  bool dependentLayerId;
  bool dependOnLayerId;
  bool dependentTaskId;
  bool dependOnTaskId;
  bool dependentLayerName;
  bool dependOnLayerName;
  bool dependentTaskName;
  bool dependOnTaskName;
} _DependT__isset;

class DependT {
 public:

  static const char* ascii_fingerprint; // = "42D5F222D6ED9D4192E5224B386908E6";
  static const uint8_t binary_fingerprint[16]; // = {0x42,0xD5,0xF2,0x22,0xD6,0xED,0x9D,0x41,0x92,0xE5,0x22,0x4B,0x38,0x69,0x08,0xE6};

  DependT() : id(), type((DependType::type)0), active(0), createdTime(0), satisfiedTime(0), dependentJobId(), dependOnJobId(), dependentLayerId(), dependOnLayerId(), dependentTaskId(), dependOnTaskId(), dependentJobName(), dependOnJobName(), dependentLayerName(), dependOnLayerName(), dependentTaskName(), dependOnTaskName() {
  }

  virtual ~DependT() throw() {}

   ::Plow::Guid id;
  DependType::type type;
  bool active;
   ::Plow::Timestamp createdTime;
   ::Plow::Timestamp satisfiedTime;
  std::string dependentJobId;
  std::string dependOnJobId;
  std::string dependentLayerId;
  std::string dependOnLayerId;
  std::string dependentTaskId;
  std::string dependOnTaskId;
  std::string dependentJobName;
  std::string dependOnJobName;
  std::string dependentLayerName;
  std::string dependOnLayerName;
  std::string dependentTaskName;
  std::string dependOnTaskName;

  _DependT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_type(const DependType::type val) {
    type = val;
  }

  void __set_active(const bool val) {
    active = val;
  }

  void __set_createdTime(const  ::Plow::Timestamp val) {
    createdTime = val;
  }

  void __set_satisfiedTime(const  ::Plow::Timestamp val) {
    satisfiedTime = val;
  }

  void __set_dependentJobId(const std::string& val) {
    dependentJobId = val;
  }

  void __set_dependOnJobId(const std::string& val) {
    dependOnJobId = val;
  }

  void __set_dependentLayerId(const std::string& val) {
    dependentLayerId = val;
    __isset.dependentLayerId = true;
  }

  void __set_dependOnLayerId(const std::string& val) {
    dependOnLayerId = val;
    __isset.dependOnLayerId = true;
  }

  void __set_dependentTaskId(const std::string& val) {
    dependentTaskId = val;
    __isset.dependentTaskId = true;
  }

  void __set_dependOnTaskId(const std::string& val) {
    dependOnTaskId = val;
    __isset.dependOnTaskId = true;
  }

  void __set_dependentJobName(const std::string& val) {
    dependentJobName = val;
  }

  void __set_dependOnJobName(const std::string& val) {
    dependOnJobName = val;
  }

  void __set_dependentLayerName(const std::string& val) {
    dependentLayerName = val;
    __isset.dependentLayerName = true;
  }

  void __set_dependOnLayerName(const std::string& val) {
    dependOnLayerName = val;
    __isset.dependOnLayerName = true;
  }

  void __set_dependentTaskName(const std::string& val) {
    dependentTaskName = val;
    __isset.dependentTaskName = true;
  }

  void __set_dependOnTaskName(const std::string& val) {
    dependOnTaskName = val;
    __isset.dependOnTaskName = true;
  }

  bool operator == (const DependT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(active == rhs.active))
      return false;
    if (!(createdTime == rhs.createdTime))
      return false;
    if (!(satisfiedTime == rhs.satisfiedTime))
      return false;
    if (!(dependentJobId == rhs.dependentJobId))
      return false;
    if (!(dependOnJobId == rhs.dependOnJobId))
      return false;
    if (__isset.dependentLayerId != rhs.__isset.dependentLayerId)
      return false;
    else if (__isset.dependentLayerId && !(dependentLayerId == rhs.dependentLayerId))
      return false;
    if (__isset.dependOnLayerId != rhs.__isset.dependOnLayerId)
      return false;
    else if (__isset.dependOnLayerId && !(dependOnLayerId == rhs.dependOnLayerId))
      return false;
    if (__isset.dependentTaskId != rhs.__isset.dependentTaskId)
      return false;
    else if (__isset.dependentTaskId && !(dependentTaskId == rhs.dependentTaskId))
      return false;
    if (__isset.dependOnTaskId != rhs.__isset.dependOnTaskId)
      return false;
    else if (__isset.dependOnTaskId && !(dependOnTaskId == rhs.dependOnTaskId))
      return false;
    if (!(dependentJobName == rhs.dependentJobName))
      return false;
    if (!(dependOnJobName == rhs.dependOnJobName))
      return false;
    if (__isset.dependentLayerName != rhs.__isset.dependentLayerName)
      return false;
    else if (__isset.dependentLayerName && !(dependentLayerName == rhs.dependentLayerName))
      return false;
    if (__isset.dependOnLayerName != rhs.__isset.dependOnLayerName)
      return false;
    else if (__isset.dependOnLayerName && !(dependOnLayerName == rhs.dependOnLayerName))
      return false;
    if (__isset.dependentTaskName != rhs.__isset.dependentTaskName)
      return false;
    else if (__isset.dependentTaskName && !(dependentTaskName == rhs.dependentTaskName))
      return false;
    if (__isset.dependOnTaskName != rhs.__isset.dependOnTaskName)
      return false;
    else if (__isset.dependOnTaskName && !(dependOnTaskName == rhs.dependOnTaskName))
      return false;
    return true;
  }
  bool operator != (const DependT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DependT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DependT &a, DependT &b);

typedef struct _TaskTotalsT__isset {
  _TaskTotalsT__isset() : totalTaskCount(true), succeededTaskCount(true), runningTaskCount(true), deadTaskCount(true), eatenTaskCount(true), waitingTaskCount(true), dependTaskCount(true) {}
  bool totalTaskCount;
  bool succeededTaskCount;
  bool runningTaskCount;
  bool deadTaskCount;
  bool eatenTaskCount;
  bool waitingTaskCount;
  bool dependTaskCount;
} _TaskTotalsT__isset;

class TaskTotalsT {
 public:

  static const char* ascii_fingerprint; // = "458493A9F4060F6499357D68C4F331E2";
  static const uint8_t binary_fingerprint[16]; // = {0x45,0x84,0x93,0xA9,0xF4,0x06,0x0F,0x64,0x99,0x35,0x7D,0x68,0xC4,0xF3,0x31,0xE2};

  TaskTotalsT() : totalTaskCount(0), succeededTaskCount(0), runningTaskCount(0), deadTaskCount(0), eatenTaskCount(0), waitingTaskCount(0), dependTaskCount(0) {
  }

  virtual ~TaskTotalsT() throw() {}

  int32_t totalTaskCount;
  int32_t succeededTaskCount;
  int32_t runningTaskCount;
  int32_t deadTaskCount;
  int32_t eatenTaskCount;
  int32_t waitingTaskCount;
  int32_t dependTaskCount;

  _TaskTotalsT__isset __isset;

  void __set_totalTaskCount(const int32_t val) {
    totalTaskCount = val;
  }

  void __set_succeededTaskCount(const int32_t val) {
    succeededTaskCount = val;
  }

  void __set_runningTaskCount(const int32_t val) {
    runningTaskCount = val;
  }

  void __set_deadTaskCount(const int32_t val) {
    deadTaskCount = val;
  }

  void __set_eatenTaskCount(const int32_t val) {
    eatenTaskCount = val;
  }

  void __set_waitingTaskCount(const int32_t val) {
    waitingTaskCount = val;
  }

  void __set_dependTaskCount(const int32_t val) {
    dependTaskCount = val;
  }

  bool operator == (const TaskTotalsT & rhs) const
  {
    if (!(totalTaskCount == rhs.totalTaskCount))
      return false;
    if (!(succeededTaskCount == rhs.succeededTaskCount))
      return false;
    if (!(runningTaskCount == rhs.runningTaskCount))
      return false;
    if (!(deadTaskCount == rhs.deadTaskCount))
      return false;
    if (!(eatenTaskCount == rhs.eatenTaskCount))
      return false;
    if (!(waitingTaskCount == rhs.waitingTaskCount))
      return false;
    if (!(dependTaskCount == rhs.dependTaskCount))
      return false;
    return true;
  }
  bool operator != (const TaskTotalsT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TaskTotalsT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TaskTotalsT &a, TaskTotalsT &b);

typedef struct _ProjectT__isset {
  _ProjectT__isset() : id(false), code(false), title(false), isActive(false) {}
  bool id;
  bool code;
  bool title;
  bool isActive;
} _ProjectT__isset;

class ProjectT {
 public:

  static const char* ascii_fingerprint; // = "557CE3E1F35DD5D74A3999FB1200CAB8";
  static const uint8_t binary_fingerprint[16]; // = {0x55,0x7C,0xE3,0xE1,0xF3,0x5D,0xD5,0xD7,0x4A,0x39,0x99,0xFB,0x12,0x00,0xCA,0xB8};

  ProjectT() : id(), code(), title(), isActive(0) {
  }

  virtual ~ProjectT() throw() {}

   ::Plow::Guid id;
  std::string code;
  std::string title;
  bool isActive;

  _ProjectT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_code(const std::string& val) {
    code = val;
  }

  void __set_title(const std::string& val) {
    title = val;
  }

  void __set_isActive(const bool val) {
    isActive = val;
  }

  bool operator == (const ProjectT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(code == rhs.code))
      return false;
    if (!(title == rhs.title))
      return false;
    if (!(isActive == rhs.isActive))
      return false;
    return true;
  }
  bool operator != (const ProjectT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProjectT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ProjectT &a, ProjectT &b);


class ClusterCountsT {
 public:

  static const char* ascii_fingerprint; // = "FB78EBC5FCC9B4E153E910DEF7648158";
  static const uint8_t binary_fingerprint[16]; // = {0xFB,0x78,0xEB,0xC5,0xFC,0xC9,0xB4,0xE1,0x53,0xE9,0x10,0xDE,0xF7,0x64,0x81,0x58};

  ClusterCountsT() : nodes(0), upNodes(0), downNodes(0), repairNodes(0), lockedNodes(0), unlockedNodes(0), cores(0), upCores(0), downCores(0), repairCores(0), lockedCores(0), unlockedCores(0), runCores(0), idleCores(0) {
  }

  virtual ~ClusterCountsT() throw() {}

  int32_t nodes;
  int32_t upNodes;
  int32_t downNodes;
  int32_t repairNodes;
  int32_t lockedNodes;
  int32_t unlockedNodes;
  int32_t cores;
  int32_t upCores;
  int32_t downCores;
  int32_t repairCores;
  int32_t lockedCores;
  int32_t unlockedCores;
  int32_t runCores;
  int32_t idleCores;

  void __set_nodes(const int32_t val) {
    nodes = val;
  }

  void __set_upNodes(const int32_t val) {
    upNodes = val;
  }

  void __set_downNodes(const int32_t val) {
    downNodes = val;
  }

  void __set_repairNodes(const int32_t val) {
    repairNodes = val;
  }

  void __set_lockedNodes(const int32_t val) {
    lockedNodes = val;
  }

  void __set_unlockedNodes(const int32_t val) {
    unlockedNodes = val;
  }

  void __set_cores(const int32_t val) {
    cores = val;
  }

  void __set_upCores(const int32_t val) {
    upCores = val;
  }

  void __set_downCores(const int32_t val) {
    downCores = val;
  }

  void __set_repairCores(const int32_t val) {
    repairCores = val;
  }

  void __set_lockedCores(const int32_t val) {
    lockedCores = val;
  }

  void __set_unlockedCores(const int32_t val) {
    unlockedCores = val;
  }

  void __set_runCores(const int32_t val) {
    runCores = val;
  }

  void __set_idleCores(const int32_t val) {
    idleCores = val;
  }

  bool operator == (const ClusterCountsT & rhs) const
  {
    if (!(nodes == rhs.nodes))
      return false;
    if (!(upNodes == rhs.upNodes))
      return false;
    if (!(downNodes == rhs.downNodes))
      return false;
    if (!(repairNodes == rhs.repairNodes))
      return false;
    if (!(lockedNodes == rhs.lockedNodes))
      return false;
    if (!(unlockedNodes == rhs.unlockedNodes))
      return false;
    if (!(cores == rhs.cores))
      return false;
    if (!(upCores == rhs.upCores))
      return false;
    if (!(downCores == rhs.downCores))
      return false;
    if (!(repairCores == rhs.repairCores))
      return false;
    if (!(lockedCores == rhs.lockedCores))
      return false;
    if (!(unlockedCores == rhs.unlockedCores))
      return false;
    if (!(runCores == rhs.runCores))
      return false;
    if (!(idleCores == rhs.idleCores))
      return false;
    return true;
  }
  bool operator != (const ClusterCountsT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterCountsT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ClusterCountsT &a, ClusterCountsT &b);

typedef struct _ClusterT__isset {
  _ClusterT__isset() : name(false), tags(false), isLocked(false), isDefault(false), total(false) {}
  bool name;
  bool tags;
  bool isLocked;
  bool isDefault;
  bool total;
} _ClusterT__isset;

class ClusterT {
 public:

  static const char* ascii_fingerprint; // = "44007FF02F852C1596154F7EE0B2C7C9";
  static const uint8_t binary_fingerprint[16]; // = {0x44,0x00,0x7F,0xF0,0x2F,0x85,0x2C,0x15,0x96,0x15,0x4F,0x7E,0xE0,0xB2,0xC7,0xC9};

  ClusterT() : id(), name(), isLocked(0), isDefault(0) {
  }

  virtual ~ClusterT() throw() {}

   ::Plow::Guid id;
  std::string name;
  std::set<std::string>  tags;
  bool isLocked;
  bool isDefault;
  ClusterCountsT total;

  _ClusterT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_tags(const std::set<std::string> & val) {
    tags = val;
  }

  void __set_isLocked(const bool val) {
    isLocked = val;
  }

  void __set_isDefault(const bool val) {
    isDefault = val;
  }

  void __set_total(const ClusterCountsT& val) {
    total = val;
  }

  bool operator == (const ClusterT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(tags == rhs.tags))
      return false;
    if (!(isLocked == rhs.isLocked))
      return false;
    if (!(isDefault == rhs.isDefault))
      return false;
    if (!(total == rhs.total))
      return false;
    return true;
  }
  bool operator != (const ClusterT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ClusterT &a, ClusterT &b);

typedef struct _QuotaT__isset {
  _QuotaT__isset() : id(false), clusterId(false), projectId(false), name(false), isLocked(false), size(false), burst(false), runCores(false) {}
  bool id;
  bool clusterId;
  bool projectId;
  bool name;
  bool isLocked;
  bool size;
  bool burst;
  bool runCores;
} _QuotaT__isset;

class QuotaT {
 public:

  static const char* ascii_fingerprint; // = "0168B2E7F15AD09D4D4CF27D6E2795E6";
  static const uint8_t binary_fingerprint[16]; // = {0x01,0x68,0xB2,0xE7,0xF1,0x5A,0xD0,0x9D,0x4D,0x4C,0xF2,0x7D,0x6E,0x27,0x95,0xE6};

  QuotaT() : id(), clusterId(), projectId(), name(), isLocked(0), size(0), burst(0), runCores(0) {
  }

  virtual ~QuotaT() throw() {}

   ::Plow::Guid id;
   ::Plow::Guid clusterId;
   ::Plow::Guid projectId;
  std::string name;
  bool isLocked;
  int32_t size;
  int32_t burst;
  int32_t runCores;

  _QuotaT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_clusterId(const  ::Plow::Guid& val) {
    clusterId = val;
  }

  void __set_projectId(const  ::Plow::Guid& val) {
    projectId = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_isLocked(const bool val) {
    isLocked = val;
  }

  void __set_size(const int32_t val) {
    size = val;
  }

  void __set_burst(const int32_t val) {
    burst = val;
  }

  void __set_runCores(const int32_t val) {
    runCores = val;
  }

  bool operator == (const QuotaT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(clusterId == rhs.clusterId))
      return false;
    if (!(projectId == rhs.projectId))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(isLocked == rhs.isLocked))
      return false;
    if (!(size == rhs.size))
      return false;
    if (!(burst == rhs.burst))
      return false;
    if (!(runCores == rhs.runCores))
      return false;
    return true;
  }
  bool operator != (const QuotaT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const QuotaT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(QuotaT &a, QuotaT &b);

typedef struct _NodeSystemT__isset {
  _NodeSystemT__isset() : physicalCores(false), logicalCores(false), totalRamMb(false), freeRamMb(false), totalSwapMb(false), freeSwapMb(false), cpuModel(false), platform(false), load(false) {}
  bool physicalCores;
  bool logicalCores;
  bool totalRamMb;
  bool freeRamMb;
  bool totalSwapMb;
  bool freeSwapMb;
  bool cpuModel;
  bool platform;
  bool load;
} _NodeSystemT__isset;

class NodeSystemT {
 public:

  static const char* ascii_fingerprint; // = "DA22BC03B87E362458B544686CD45AB6";
  static const uint8_t binary_fingerprint[16]; // = {0xDA,0x22,0xBC,0x03,0xB8,0x7E,0x36,0x24,0x58,0xB5,0x44,0x68,0x6C,0xD4,0x5A,0xB6};

  NodeSystemT() : physicalCores(0), logicalCores(0), totalRamMb(0), freeRamMb(0), totalSwapMb(0), freeSwapMb(0), cpuModel(), platform() {
  }

  virtual ~NodeSystemT() throw() {}

  int32_t physicalCores;
  int32_t logicalCores;
  int32_t totalRamMb;
  int32_t freeRamMb;
  int32_t totalSwapMb;
  int32_t freeSwapMb;
  std::string cpuModel;
  std::string platform;
  std::vector<int32_t>  load;

  _NodeSystemT__isset __isset;

  void __set_physicalCores(const int32_t val) {
    physicalCores = val;
  }

  void __set_logicalCores(const int32_t val) {
    logicalCores = val;
  }

  void __set_totalRamMb(const int32_t val) {
    totalRamMb = val;
  }

  void __set_freeRamMb(const int32_t val) {
    freeRamMb = val;
  }

  void __set_totalSwapMb(const int32_t val) {
    totalSwapMb = val;
  }

  void __set_freeSwapMb(const int32_t val) {
    freeSwapMb = val;
  }

  void __set_cpuModel(const std::string& val) {
    cpuModel = val;
  }

  void __set_platform(const std::string& val) {
    platform = val;
  }

  void __set_load(const std::vector<int32_t> & val) {
    load = val;
  }

  bool operator == (const NodeSystemT & rhs) const
  {
    if (!(physicalCores == rhs.physicalCores))
      return false;
    if (!(logicalCores == rhs.logicalCores))
      return false;
    if (!(totalRamMb == rhs.totalRamMb))
      return false;
    if (!(freeRamMb == rhs.freeRamMb))
      return false;
    if (!(totalSwapMb == rhs.totalSwapMb))
      return false;
    if (!(freeSwapMb == rhs.freeSwapMb))
      return false;
    if (!(cpuModel == rhs.cpuModel))
      return false;
    if (!(platform == rhs.platform))
      return false;
    if (!(load == rhs.load))
      return false;
    return true;
  }
  bool operator != (const NodeSystemT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NodeSystemT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(NodeSystemT &a, NodeSystemT &b);

typedef struct _NodeT__isset {
  _NodeT__isset() : id(false), clusterId(false), name(false), clusterName(false), ipaddr(false), tags(false), state(false), locked(false), createdTime(false), updatedTime(false), bootTime(false), totalCores(false), idleCores(false), totalRamMb(false), freeRamMb(false), system(false) {}
  bool id;
  bool clusterId;
  bool name;
  bool clusterName;
  bool ipaddr;
  bool tags;
  bool state;
  bool locked;
  bool createdTime;
  bool updatedTime;
  bool bootTime;
  bool totalCores;
  bool idleCores;
  bool totalRamMb;
  bool freeRamMb;
  bool system;
} _NodeT__isset;

class NodeT {
 public:

  static const char* ascii_fingerprint; // = "99788DF07D715CB5A00251BB21383B4B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x78,0x8D,0xF0,0x7D,0x71,0x5C,0xB5,0xA0,0x02,0x51,0xBB,0x21,0x38,0x3B,0x4B};

  NodeT() : id(), clusterId(), name(), clusterName(), ipaddr(), state((NodeState::type)0), locked(0), createdTime(0), updatedTime(0), bootTime(0), totalCores(0), idleCores(0), totalRamMb(0), freeRamMb(0) {
  }

  virtual ~NodeT() throw() {}

   ::Plow::Guid id;
   ::Plow::Guid clusterId;
  std::string name;
  std::string clusterName;
  std::string ipaddr;
  std::set<std::string>  tags;
  NodeState::type state;
  bool locked;
   ::Plow::Timestamp createdTime;
   ::Plow::Timestamp updatedTime;
   ::Plow::Timestamp bootTime;
  int32_t totalCores;
  int32_t idleCores;
  int32_t totalRamMb;
  int32_t freeRamMb;
  NodeSystemT system;

  _NodeT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_clusterId(const  ::Plow::Guid& val) {
    clusterId = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_clusterName(const std::string& val) {
    clusterName = val;
  }

  void __set_ipaddr(const std::string& val) {
    ipaddr = val;
  }

  void __set_tags(const std::set<std::string> & val) {
    tags = val;
  }

  void __set_state(const NodeState::type val) {
    state = val;
  }

  void __set_locked(const bool val) {
    locked = val;
  }

  void __set_createdTime(const  ::Plow::Timestamp val) {
    createdTime = val;
  }

  void __set_updatedTime(const  ::Plow::Timestamp val) {
    updatedTime = val;
  }

  void __set_bootTime(const  ::Plow::Timestamp val) {
    bootTime = val;
  }

  void __set_totalCores(const int32_t val) {
    totalCores = val;
  }

  void __set_idleCores(const int32_t val) {
    idleCores = val;
  }

  void __set_totalRamMb(const int32_t val) {
    totalRamMb = val;
  }

  void __set_freeRamMb(const int32_t val) {
    freeRamMb = val;
  }

  void __set_system(const NodeSystemT& val) {
    system = val;
  }

  bool operator == (const NodeT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(clusterId == rhs.clusterId))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(clusterName == rhs.clusterName))
      return false;
    if (!(ipaddr == rhs.ipaddr))
      return false;
    if (!(tags == rhs.tags))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(locked == rhs.locked))
      return false;
    if (!(createdTime == rhs.createdTime))
      return false;
    if (!(updatedTime == rhs.updatedTime))
      return false;
    if (!(bootTime == rhs.bootTime))
      return false;
    if (!(totalCores == rhs.totalCores))
      return false;
    if (!(idleCores == rhs.idleCores))
      return false;
    if (!(totalRamMb == rhs.totalRamMb))
      return false;
    if (!(freeRamMb == rhs.freeRamMb))
      return false;
    if (!(system == rhs.system))
      return false;
    return true;
  }
  bool operator != (const NodeT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NodeT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(NodeT &a, NodeT &b);

typedef struct _ProcT__isset {
  _ProcT__isset() : id(false), hostId(false), jobName(false), taskName(false), cores(false), ramMb(false), usedRamMb(false), highRamMb(false), unbooked(false) {}
  bool id;
  bool hostId;
  bool jobName;
  bool taskName;
  bool cores;
  bool ramMb;
  bool usedRamMb;
  bool highRamMb;
  bool unbooked;
} _ProcT__isset;

class ProcT {
 public:

  static const char* ascii_fingerprint; // = "DF2D0B05495D75DAEEDAB46A102BFEF1";
  static const uint8_t binary_fingerprint[16]; // = {0xDF,0x2D,0x0B,0x05,0x49,0x5D,0x75,0xDA,0xEE,0xDA,0xB4,0x6A,0x10,0x2B,0xFE,0xF1};

  ProcT() : id(), hostId(), jobName(), taskName(), cores(0), ramMb(0), usedRamMb(0), highRamMb(0), unbooked(0) {
  }

  virtual ~ProcT() throw() {}

   ::Plow::Guid id;
   ::Plow::Guid hostId;
  std::string jobName;
  std::string taskName;
  int32_t cores;
  int32_t ramMb;
  int32_t usedRamMb;
  int32_t highRamMb;
  bool unbooked;

  _ProcT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_hostId(const  ::Plow::Guid& val) {
    hostId = val;
  }

  void __set_jobName(const std::string& val) {
    jobName = val;
  }

  void __set_taskName(const std::string& val) {
    taskName = val;
  }

  void __set_cores(const int32_t val) {
    cores = val;
  }

  void __set_ramMb(const int32_t val) {
    ramMb = val;
  }

  void __set_usedRamMb(const int32_t val) {
    usedRamMb = val;
  }

  void __set_highRamMb(const int32_t val) {
    highRamMb = val;
  }

  void __set_unbooked(const bool val) {
    unbooked = val;
  }

  bool operator == (const ProcT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(hostId == rhs.hostId))
      return false;
    if (!(jobName == rhs.jobName))
      return false;
    if (!(taskName == rhs.taskName))
      return false;
    if (!(cores == rhs.cores))
      return false;
    if (!(ramMb == rhs.ramMb))
      return false;
    if (!(usedRamMb == rhs.usedRamMb))
      return false;
    if (!(highRamMb == rhs.highRamMb))
      return false;
    if (!(unbooked == rhs.unbooked))
      return false;
    return true;
  }
  bool operator != (const ProcT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProcT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ProcT &a, ProcT &b);


class JobStatsT {
 public:

  static const char* ascii_fingerprint; // = "55A5DDB37A30A7D48A6FAEDCA2981C34";
  static const uint8_t binary_fingerprint[16]; // = {0x55,0xA5,0xDD,0xB3,0x7A,0x30,0xA7,0xD4,0x8A,0x6F,0xAE,0xDC,0xA2,0x98,0x1C,0x34};

  JobStatsT() : highRam(0), highCores(0), highCoreTime(0), totalCoreTime(0), totalSuccessCoreTime(0), totalFailCoreTime(0) {
  }

  virtual ~JobStatsT() throw() {}

  int32_t highRam;
  double highCores;
  int32_t highCoreTime;
  int64_t totalCoreTime;
  int64_t totalSuccessCoreTime;
  int64_t totalFailCoreTime;

  void __set_highRam(const int32_t val) {
    highRam = val;
  }

  void __set_highCores(const double val) {
    highCores = val;
  }

  void __set_highCoreTime(const int32_t val) {
    highCoreTime = val;
  }

  void __set_totalCoreTime(const int64_t val) {
    totalCoreTime = val;
  }

  void __set_totalSuccessCoreTime(const int64_t val) {
    totalSuccessCoreTime = val;
  }

  void __set_totalFailCoreTime(const int64_t val) {
    totalFailCoreTime = val;
  }

  bool operator == (const JobStatsT & rhs) const
  {
    if (!(highRam == rhs.highRam))
      return false;
    if (!(highCores == rhs.highCores))
      return false;
    if (!(highCoreTime == rhs.highCoreTime))
      return false;
    if (!(totalCoreTime == rhs.totalCoreTime))
      return false;
    if (!(totalSuccessCoreTime == rhs.totalSuccessCoreTime))
      return false;
    if (!(totalFailCoreTime == rhs.totalFailCoreTime))
      return false;
    return true;
  }
  bool operator != (const JobStatsT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const JobStatsT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(JobStatsT &a, JobStatsT &b);

typedef struct _JobT__isset {
  _JobT__isset() : name(false), username(false), uid(false), state(false), paused(false), minCores(false), maxCores(false), runCores(false), startTime(false), stopTime(false), totals(false), stats(false), attrs(false) {}
  bool name;
  bool username;
  bool uid;
  bool state;
  bool paused;
  bool minCores;
  bool maxCores;
  bool runCores;
  bool startTime;
  bool stopTime;
  bool totals;
  bool stats;
  bool attrs;
} _JobT__isset;

class JobT {
 public:

  static const char* ascii_fingerprint; // = "820A0281ECA5002E35D1A2CFD48F6B6C";
  static const uint8_t binary_fingerprint[16]; // = {0x82,0x0A,0x02,0x81,0xEC,0xA5,0x00,0x2E,0x35,0xD1,0xA2,0xCF,0xD4,0x8F,0x6B,0x6C};

  JobT() : id(), folderId(), name(), username(), uid(0), state((JobState::type)0), paused(0), minCores(0), maxCores(0), runCores(0), startTime(0), stopTime(0) {
  }

  virtual ~JobT() throw() {}

   ::Plow::Guid id;
   ::Plow::Guid folderId;
  std::string name;
  std::string username;
  int32_t uid;
  JobState::type state;
  bool paused;
  int32_t minCores;
  int32_t maxCores;
  int32_t runCores;
   ::Plow::Timestamp startTime;
   ::Plow::Timestamp stopTime;
  TaskTotalsT totals;
  JobStatsT stats;
  Attrs attrs;

  _JobT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_folderId(const  ::Plow::Guid& val) {
    folderId = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_username(const std::string& val) {
    username = val;
  }

  void __set_uid(const int32_t val) {
    uid = val;
  }

  void __set_state(const JobState::type val) {
    state = val;
  }

  void __set_paused(const bool val) {
    paused = val;
  }

  void __set_minCores(const int32_t val) {
    minCores = val;
  }

  void __set_maxCores(const int32_t val) {
    maxCores = val;
  }

  void __set_runCores(const int32_t val) {
    runCores = val;
  }

  void __set_startTime(const  ::Plow::Timestamp val) {
    startTime = val;
  }

  void __set_stopTime(const  ::Plow::Timestamp val) {
    stopTime = val;
  }

  void __set_totals(const TaskTotalsT& val) {
    totals = val;
  }

  void __set_stats(const JobStatsT& val) {
    stats = val;
  }

  void __set_attrs(const Attrs& val) {
    attrs = val;
  }

  bool operator == (const JobT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(folderId == rhs.folderId))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(username == rhs.username))
      return false;
    if (!(uid == rhs.uid))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(paused == rhs.paused))
      return false;
    if (!(minCores == rhs.minCores))
      return false;
    if (!(maxCores == rhs.maxCores))
      return false;
    if (!(runCores == rhs.runCores))
      return false;
    if (!(startTime == rhs.startTime))
      return false;
    if (!(stopTime == rhs.stopTime))
      return false;
    if (!(totals == rhs.totals))
      return false;
    if (!(stats == rhs.stats))
      return false;
    if (!(attrs == rhs.attrs))
      return false;
    return true;
  }
  bool operator != (const JobT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const JobT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(JobT &a, JobT &b);

typedef struct _LayerStatsT__isset {
  _LayerStatsT__isset() : highRam(false), avgRam(false), stdDevRam(false), highCores(false), avgCores(false), stdDevCores(false), highCoreTime(false), avgCoreTime(false), lowCoreTime(false), stdDevCoreTime(false), totalCoreTime(false), totalSuccessCoreTime(false), totalFailCoreTime(false) {}
  bool highRam;
  bool avgRam;
  bool stdDevRam;
  bool highCores;
  bool avgCores;
  bool stdDevCores;
  bool highCoreTime;
  bool avgCoreTime;
  bool lowCoreTime;
  bool stdDevCoreTime;
  bool totalCoreTime;
  bool totalSuccessCoreTime;
  bool totalFailCoreTime;
} _LayerStatsT__isset;

class LayerStatsT {
 public:

  static const char* ascii_fingerprint; // = "FAD5043C1DCD0AF2985F30FE80EBF876";
  static const uint8_t binary_fingerprint[16]; // = {0xFA,0xD5,0x04,0x3C,0x1D,0xCD,0x0A,0xF2,0x98,0x5F,0x30,0xFE,0x80,0xEB,0xF8,0x76};

  LayerStatsT() : highRam(0), avgRam(0), stdDevRam(0), highCores(0), avgCores(0), stdDevCores(0), highCoreTime(0), avgCoreTime(0), lowCoreTime(0), stdDevCoreTime(0), totalCoreTime(0), totalSuccessCoreTime(0), totalFailCoreTime(0) {
  }

  virtual ~LayerStatsT() throw() {}

  int32_t highRam;
  int32_t avgRam;
  double stdDevRam;
  double highCores;
  double avgCores;
  double stdDevCores;
  int32_t highCoreTime;
  int32_t avgCoreTime;
  int32_t lowCoreTime;
  double stdDevCoreTime;
  int64_t totalCoreTime;
  int64_t totalSuccessCoreTime;
  int64_t totalFailCoreTime;

  _LayerStatsT__isset __isset;

  void __set_highRam(const int32_t val) {
    highRam = val;
  }

  void __set_avgRam(const int32_t val) {
    avgRam = val;
  }

  void __set_stdDevRam(const double val) {
    stdDevRam = val;
  }

  void __set_highCores(const double val) {
    highCores = val;
  }

  void __set_avgCores(const double val) {
    avgCores = val;
  }

  void __set_stdDevCores(const double val) {
    stdDevCores = val;
  }

  void __set_highCoreTime(const int32_t val) {
    highCoreTime = val;
  }

  void __set_avgCoreTime(const int32_t val) {
    avgCoreTime = val;
  }

  void __set_lowCoreTime(const int32_t val) {
    lowCoreTime = val;
  }

  void __set_stdDevCoreTime(const double val) {
    stdDevCoreTime = val;
  }

  void __set_totalCoreTime(const int64_t val) {
    totalCoreTime = val;
  }

  void __set_totalSuccessCoreTime(const int64_t val) {
    totalSuccessCoreTime = val;
  }

  void __set_totalFailCoreTime(const int64_t val) {
    totalFailCoreTime = val;
  }

  bool operator == (const LayerStatsT & rhs) const
  {
    if (!(highRam == rhs.highRam))
      return false;
    if (!(avgRam == rhs.avgRam))
      return false;
    if (!(stdDevRam == rhs.stdDevRam))
      return false;
    if (!(highCores == rhs.highCores))
      return false;
    if (!(avgCores == rhs.avgCores))
      return false;
    if (!(stdDevCores == rhs.stdDevCores))
      return false;
    if (!(highCoreTime == rhs.highCoreTime))
      return false;
    if (!(avgCoreTime == rhs.avgCoreTime))
      return false;
    if (!(lowCoreTime == rhs.lowCoreTime))
      return false;
    if (!(stdDevCoreTime == rhs.stdDevCoreTime))
      return false;
    if (!(totalCoreTime == rhs.totalCoreTime))
      return false;
    if (!(totalSuccessCoreTime == rhs.totalSuccessCoreTime))
      return false;
    if (!(totalFailCoreTime == rhs.totalFailCoreTime))
      return false;
    return true;
  }
  bool operator != (const LayerStatsT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LayerStatsT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LayerStatsT &a, LayerStatsT &b);

typedef struct _ServiceT__isset {
  _ServiceT__isset() : id(false), tags(false), minCores(false), maxCores(false), minRam(false), maxRam(false), maxRetries(false), threadable(false) {}
  bool id;
  bool tags;
  bool minCores;
  bool maxCores;
  bool minRam;
  bool maxRam;
  bool maxRetries;
  bool threadable;
} _ServiceT__isset;

class ServiceT {
 public:

  static const char* ascii_fingerprint; // = "E48E22A72EC7EABC72A475A01F0FFCFC";
  static const uint8_t binary_fingerprint[16]; // = {0xE4,0x8E,0x22,0xA7,0x2E,0xC7,0xEA,0xBC,0x72,0xA4,0x75,0xA0,0x1F,0x0F,0xFC,0xFC};

  ServiceT() : id(), name(), minCores(0), maxCores(0), minRam(0), maxRam(0), maxRetries(0), threadable(0) {
  }

  virtual ~ServiceT() throw() {}

   ::Plow::Guid id;
  std::string name;
  std::vector<std::string>  tags;
  int32_t minCores;
  int32_t maxCores;
  int32_t minRam;
  int32_t maxRam;
  int32_t maxRetries;
  bool threadable;

  _ServiceT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_tags(const std::vector<std::string> & val) {
    tags = val;
  }

  void __set_minCores(const int32_t val) {
    minCores = val;
  }

  void __set_maxCores(const int32_t val) {
    maxCores = val;
  }

  void __set_minRam(const int32_t val) {
    minRam = val;
  }

  void __set_maxRam(const int32_t val) {
    maxRam = val;
  }

  void __set_maxRetries(const int32_t val) {
    maxRetries = val;
  }

  void __set_threadable(const bool val) {
    threadable = val;
  }

  bool operator == (const ServiceT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(tags == rhs.tags))
      return false;
    if (!(minCores == rhs.minCores))
      return false;
    if (!(maxCores == rhs.maxCores))
      return false;
    if (!(minRam == rhs.minRam))
      return false;
    if (!(maxRam == rhs.maxRam))
      return false;
    if (!(maxRetries == rhs.maxRetries))
      return false;
    if (!(threadable == rhs.threadable))
      return false;
    return true;
  }
  bool operator != (const ServiceT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ServiceT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ServiceT &a, ServiceT &b);

typedef struct _LayerT__isset {
  _LayerT__isset() : name(false), range(false), serv(false), chunk(false), tags(false), threadable(false), minCores(false), maxCores(false), minRam(false), maxRam(false), runCores(false), maxRetries(false), totals(false), stats(false) {}
  bool name;
  bool range;
  bool serv;
  bool chunk;
  bool tags;
  bool threadable;
  bool minCores;
  bool maxCores;
  bool minRam;
  bool maxRam;
  bool runCores;
  bool maxRetries;
  bool totals;
  bool stats;
} _LayerT__isset;

class LayerT {
 public:

  static const char* ascii_fingerprint; // = "A14183C016B8125B3DBB065340EA046E";
  static const uint8_t binary_fingerprint[16]; // = {0xA1,0x41,0x83,0xC0,0x16,0xB8,0x12,0x5B,0x3D,0xBB,0x06,0x53,0x40,0xEA,0x04,0x6E};

  LayerT() : id(), name(), range(), serv(), chunk(0), threadable(0), minCores(0), maxCores(0), minRam(0), maxRam(0), runCores(0), maxRetries(0) {
  }

  virtual ~LayerT() throw() {}

   ::Plow::Guid id;
  std::string name;
  std::string range;
  std::string serv;
  int32_t chunk;
  std::vector<std::string>  tags;
  bool threadable;
  int32_t minCores;
  int32_t maxCores;
  int32_t minRam;
  int32_t maxRam;
  int32_t runCores;
  int32_t maxRetries;
  TaskTotalsT totals;
  LayerStatsT stats;

  _LayerT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_range(const std::string& val) {
    range = val;
  }

  void __set_serv(const std::string& val) {
    serv = val;
  }

  void __set_chunk(const int32_t val) {
    chunk = val;
  }

  void __set_tags(const std::vector<std::string> & val) {
    tags = val;
  }

  void __set_threadable(const bool val) {
    threadable = val;
  }

  void __set_minCores(const int32_t val) {
    minCores = val;
  }

  void __set_maxCores(const int32_t val) {
    maxCores = val;
  }

  void __set_minRam(const int32_t val) {
    minRam = val;
  }

  void __set_maxRam(const int32_t val) {
    maxRam = val;
  }

  void __set_runCores(const int32_t val) {
    runCores = val;
  }

  void __set_maxRetries(const int32_t val) {
    maxRetries = val;
  }

  void __set_totals(const TaskTotalsT& val) {
    totals = val;
  }

  void __set_stats(const LayerStatsT& val) {
    stats = val;
  }

  bool operator == (const LayerT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(range == rhs.range))
      return false;
    if (!(serv == rhs.serv))
      return false;
    if (!(chunk == rhs.chunk))
      return false;
    if (!(tags == rhs.tags))
      return false;
    if (!(threadable == rhs.threadable))
      return false;
    if (!(minCores == rhs.minCores))
      return false;
    if (!(maxCores == rhs.maxCores))
      return false;
    if (!(minRam == rhs.minRam))
      return false;
    if (!(maxRam == rhs.maxRam))
      return false;
    if (!(runCores == rhs.runCores))
      return false;
    if (!(maxRetries == rhs.maxRetries))
      return false;
    if (!(totals == rhs.totals))
      return false;
    if (!(stats == rhs.stats))
      return false;
    return true;
  }
  bool operator != (const LayerT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LayerT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LayerT &a, LayerT &b);

typedef struct _TaskStatsT__isset {
  _TaskStatsT__isset() : cores(false), usedCores(false), highCores(false), ram(false), usedRam(false), highRam(false), startTime(false), stopTime(false), retryNum(false), progress(false), lastLogLine(false), active(true), exitStatus(false), exitSignal(false) {}
  bool cores;
  bool usedCores;
  bool highCores;
  bool ram;
  bool usedRam;
  bool highRam;
  bool startTime;
  bool stopTime;
  bool retryNum;
  bool progress;
  bool lastLogLine;
  bool active;
  bool exitStatus;
  bool exitSignal;
} _TaskStatsT__isset;

class TaskStatsT {
 public:

  static const char* ascii_fingerprint; // = "99ED98DF5C3DAC17E0A5BC18F72D51A4";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0xED,0x98,0xDF,0x5C,0x3D,0xAC,0x17,0xE0,0xA5,0xBC,0x18,0xF7,0x2D,0x51,0xA4};

  TaskStatsT() : cores(0), usedCores(0), highCores(0), ram(0), usedRam(0), highRam(0), startTime(0), stopTime(0), retryNum(0), progress(0), lastLogLine(), active(false), exitStatus(0), exitSignal(0) {
  }

  virtual ~TaskStatsT() throw() {}

  int32_t cores;
  double usedCores;
  double highCores;
  int32_t ram;
  int32_t usedRam;
  int32_t highRam;
   ::Plow::Timestamp startTime;
   ::Plow::Timestamp stopTime;
  int32_t retryNum;
  int32_t progress;
  std::string lastLogLine;
  bool active;
  int32_t exitStatus;
  int32_t exitSignal;

  _TaskStatsT__isset __isset;

  void __set_cores(const int32_t val) {
    cores = val;
  }

  void __set_usedCores(const double val) {
    usedCores = val;
  }

  void __set_highCores(const double val) {
    highCores = val;
  }

  void __set_ram(const int32_t val) {
    ram = val;
  }

  void __set_usedRam(const int32_t val) {
    usedRam = val;
  }

  void __set_highRam(const int32_t val) {
    highRam = val;
  }

  void __set_startTime(const  ::Plow::Timestamp val) {
    startTime = val;
  }

  void __set_stopTime(const  ::Plow::Timestamp val) {
    stopTime = val;
  }

  void __set_retryNum(const int32_t val) {
    retryNum = val;
  }

  void __set_progress(const int32_t val) {
    progress = val;
  }

  void __set_lastLogLine(const std::string& val) {
    lastLogLine = val;
  }

  void __set_active(const bool val) {
    active = val;
  }

  void __set_exitStatus(const int32_t val) {
    exitStatus = val;
  }

  void __set_exitSignal(const int32_t val) {
    exitSignal = val;
  }

  bool operator == (const TaskStatsT & rhs) const
  {
    if (!(cores == rhs.cores))
      return false;
    if (!(usedCores == rhs.usedCores))
      return false;
    if (!(highCores == rhs.highCores))
      return false;
    if (!(ram == rhs.ram))
      return false;
    if (!(usedRam == rhs.usedRam))
      return false;
    if (!(highRam == rhs.highRam))
      return false;
    if (!(startTime == rhs.startTime))
      return false;
    if (!(stopTime == rhs.stopTime))
      return false;
    if (!(retryNum == rhs.retryNum))
      return false;
    if (!(progress == rhs.progress))
      return false;
    if (!(lastLogLine == rhs.lastLogLine))
      return false;
    if (!(active == rhs.active))
      return false;
    if (!(exitStatus == rhs.exitStatus))
      return false;
    if (!(exitSignal == rhs.exitSignal))
      return false;
    return true;
  }
  bool operator != (const TaskStatsT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TaskStatsT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TaskStatsT &a, TaskStatsT &b);

typedef struct _TaskT__isset {
  _TaskT__isset() : name(false), number(false), state(false), order(false), retries(false), minCores(false), minRam(false), lastResource(false), stats(false) {}
  bool name;
  bool number;
  bool state;
  bool order;
  bool retries;
  bool minCores;
  bool minRam;
  bool lastResource;
  bool stats;
} _TaskT__isset;

class TaskT {
 public:

  static const char* ascii_fingerprint; // = "5E299AB9000027F7AA4555C5C9A3E73C";
  static const uint8_t binary_fingerprint[16]; // = {0x5E,0x29,0x9A,0xB9,0x00,0x00,0x27,0xF7,0xAA,0x45,0x55,0xC5,0xC9,0xA3,0xE7,0x3C};

  TaskT() : id(), name(), number(0), state((TaskState::type)0), order(0), retries(0), minCores(0), minRam(0), lastResource() {
  }

  virtual ~TaskT() throw() {}

   ::Plow::Guid id;
  std::string name;
  int32_t number;
  TaskState::type state;
  int32_t order;
  int32_t retries;
  int32_t minCores;
  int32_t minRam;
  std::string lastResource;
  TaskStatsT stats;

  _TaskT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_number(const int32_t val) {
    number = val;
  }

  void __set_state(const TaskState::type val) {
    state = val;
  }

  void __set_order(const int32_t val) {
    order = val;
  }

  void __set_retries(const int32_t val) {
    retries = val;
  }

  void __set_minCores(const int32_t val) {
    minCores = val;
  }

  void __set_minRam(const int32_t val) {
    minRam = val;
  }

  void __set_lastResource(const std::string& val) {
    lastResource = val;
  }

  void __set_stats(const TaskStatsT& val) {
    stats = val;
  }

  bool operator == (const TaskT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(number == rhs.number))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(order == rhs.order))
      return false;
    if (!(retries == rhs.retries))
      return false;
    if (!(minCores == rhs.minCores))
      return false;
    if (!(minRam == rhs.minRam))
      return false;
    if (!(lastResource == rhs.lastResource))
      return false;
    if (!(stats == rhs.stats))
      return false;
    return true;
  }
  bool operator != (const TaskT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TaskT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TaskT &a, TaskT &b);

typedef struct _FolderT__isset {
  _FolderT__isset() : id(false), name(false), minCores(false), maxCores(false), runCores(false), order(false), totals(false), jobs(false) {}
  bool id;
  bool name;
  bool minCores;
  bool maxCores;
  bool runCores;
  bool order;
  bool totals;
  bool jobs;
} _FolderT__isset;

class FolderT {
 public:

  static const char* ascii_fingerprint; // = "3A080FDD1552A3DF29AC58BA914EBBCD";
  static const uint8_t binary_fingerprint[16]; // = {0x3A,0x08,0x0F,0xDD,0x15,0x52,0xA3,0xDF,0x29,0xAC,0x58,0xBA,0x91,0x4E,0xBB,0xCD};

  FolderT() : id(), name(), minCores(0), maxCores(0), runCores(0), order(0) {
  }

  virtual ~FolderT() throw() {}

   ::Plow::Guid id;
  std::string name;
  int32_t minCores;
  int32_t maxCores;
  int32_t runCores;
  int32_t order;
  TaskTotalsT totals;
  std::vector<JobT>  jobs;

  _FolderT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_minCores(const int32_t val) {
    minCores = val;
  }

  void __set_maxCores(const int32_t val) {
    maxCores = val;
  }

  void __set_runCores(const int32_t val) {
    runCores = val;
  }

  void __set_order(const int32_t val) {
    order = val;
  }

  void __set_totals(const TaskTotalsT& val) {
    totals = val;
  }

  void __set_jobs(const std::vector<JobT> & val) {
    jobs = val;
    __isset.jobs = true;
  }

  bool operator == (const FolderT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(minCores == rhs.minCores))
      return false;
    if (!(maxCores == rhs.maxCores))
      return false;
    if (!(runCores == rhs.runCores))
      return false;
    if (!(order == rhs.order))
      return false;
    if (!(totals == rhs.totals))
      return false;
    if (__isset.jobs != rhs.__isset.jobs)
      return false;
    else if (__isset.jobs && !(jobs == rhs.jobs))
      return false;
    return true;
  }
  bool operator != (const FolderT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FolderT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(FolderT &a, FolderT &b);

typedef struct _MatcherT__isset {
  _MatcherT__isset() : id(false), type(false), field(false), value(false), attr(false) {}
  bool id;
  bool type;
  bool field;
  bool value;
  bool attr;
} _MatcherT__isset;

class MatcherT {
 public:

  static const char* ascii_fingerprint; // = "97DC467FBBF7D1E3CE39BC21DB8631F9";
  static const uint8_t binary_fingerprint[16]; // = {0x97,0xDC,0x46,0x7F,0xBB,0xF7,0xD1,0xE3,0xCE,0x39,0xBC,0x21,0xDB,0x86,0x31,0xF9};

  MatcherT() : id(), type((MatcherType::type)0), field((MatcherField::type)0), value(), attr() {
  }

  virtual ~MatcherT() throw() {}

   ::Plow::Guid id;
  MatcherType::type type;
  MatcherField::type field;
  std::string value;
  std::string attr;

  _MatcherT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_type(const MatcherType::type val) {
    type = val;
  }

  void __set_field(const MatcherField::type val) {
    field = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  void __set_attr(const std::string& val) {
    attr = val;
    __isset.attr = true;
  }

  bool operator == (const MatcherT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(field == rhs.field))
      return false;
    if (!(value == rhs.value))
      return false;
    if (__isset.attr != rhs.__isset.attr)
      return false;
    else if (__isset.attr && !(attr == rhs.attr))
      return false;
    return true;
  }
  bool operator != (const MatcherT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(MatcherT &a, MatcherT &b);

typedef struct _ActionT__isset {
  _ActionT__isset() : id(false), type(false), value(false) {}
  bool id;
  bool type;
  bool value;
} _ActionT__isset;

class ActionT {
 public:

  static const char* ascii_fingerprint; // = "D635E8134E429A3CB23835FC5CC677D6";
  static const uint8_t binary_fingerprint[16]; // = {0xD6,0x35,0xE8,0x13,0x4E,0x42,0x9A,0x3C,0xB2,0x38,0x35,0xFC,0x5C,0xC6,0x77,0xD6};

  ActionT() : id(), type((ActionType::type)0), value() {
  }

  virtual ~ActionT() throw() {}

   ::Plow::Guid id;
  ActionType::type type;
  std::string value;

  _ActionT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_type(const ActionType::type val) {
    type = val;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const ActionT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(type == rhs.type))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const ActionT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ActionT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ActionT &a, ActionT &b);

typedef struct _FilterT__isset {
  _FilterT__isset() : id(false), name(false), order(false), enabled(false), matchers(false), actions(false) {}
  bool id;
  bool name;
  bool order;
  bool enabled;
  bool matchers;
  bool actions;
} _FilterT__isset;

class FilterT {
 public:

  static const char* ascii_fingerprint; // = "B72114DFC4A1A2E8CF1CBE22113832EF";
  static const uint8_t binary_fingerprint[16]; // = {0xB7,0x21,0x14,0xDF,0xC4,0xA1,0xA2,0xE8,0xCF,0x1C,0xBE,0x22,0x11,0x38,0x32,0xEF};

  FilterT() : id(), name(), order(0), enabled(0) {
  }

  virtual ~FilterT() throw() {}

   ::Plow::Guid id;
  std::string name;
  int32_t order;
  bool enabled;
  std::vector<MatcherT>  matchers;
  std::vector<ActionT>  actions;

  _FilterT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_order(const int32_t val) {
    order = val;
  }

  void __set_enabled(const bool val) {
    enabled = val;
  }

  void __set_matchers(const std::vector<MatcherT> & val) {
    matchers = val;
    __isset.matchers = true;
  }

  void __set_actions(const std::vector<ActionT> & val) {
    actions = val;
    __isset.actions = true;
  }

  bool operator == (const FilterT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(order == rhs.order))
      return false;
    if (!(enabled == rhs.enabled))
      return false;
    if (__isset.matchers != rhs.__isset.matchers)
      return false;
    else if (__isset.matchers && !(matchers == rhs.matchers))
      return false;
    if (__isset.actions != rhs.__isset.actions)
      return false;
    else if (__isset.actions && !(actions == rhs.actions))
      return false;
    return true;
  }
  bool operator != (const FilterT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FilterT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(FilterT &a, FilterT &b);

typedef struct _DependSpecT__isset {
  _DependSpecT__isset() : type(false), dependentJob(false), dependOnJob(false), dependentLayer(false), dependOnLayer(false), dependentTask(false), dependOnTask(false) {}
  bool type;
  bool dependentJob;
  bool dependOnJob;
  bool dependentLayer;
  bool dependOnLayer;
  bool dependentTask;
  bool dependOnTask;
} _DependSpecT__isset;

class DependSpecT {
 public:

  static const char* ascii_fingerprint; // = "C74CD2BA0D69BC506E09542F0DD5DA6B";
  static const uint8_t binary_fingerprint[16]; // = {0xC7,0x4C,0xD2,0xBA,0x0D,0x69,0xBC,0x50,0x6E,0x09,0x54,0x2F,0x0D,0xD5,0xDA,0x6B};

  DependSpecT() : type((DependType::type)0), dependentJob(), dependOnJob(), dependentLayer(), dependOnLayer(), dependentTask(), dependOnTask() {
  }

  virtual ~DependSpecT() throw() {}

  DependType::type type;
  std::string dependentJob;
  std::string dependOnJob;
  std::string dependentLayer;
  std::string dependOnLayer;
  std::string dependentTask;
  std::string dependOnTask;

  _DependSpecT__isset __isset;

  void __set_type(const DependType::type val) {
    type = val;
  }

  void __set_dependentJob(const std::string& val) {
    dependentJob = val;
  }

  void __set_dependOnJob(const std::string& val) {
    dependOnJob = val;
  }

  void __set_dependentLayer(const std::string& val) {
    dependentLayer = val;
  }

  void __set_dependOnLayer(const std::string& val) {
    dependOnLayer = val;
  }

  void __set_dependentTask(const std::string& val) {
    dependentTask = val;
  }

  void __set_dependOnTask(const std::string& val) {
    dependOnTask = val;
  }

  bool operator == (const DependSpecT & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(dependentJob == rhs.dependentJob))
      return false;
    if (!(dependOnJob == rhs.dependOnJob))
      return false;
    if (!(dependentLayer == rhs.dependentLayer))
      return false;
    if (!(dependOnLayer == rhs.dependOnLayer))
      return false;
    if (!(dependentTask == rhs.dependentTask))
      return false;
    if (!(dependOnTask == rhs.dependOnTask))
      return false;
    return true;
  }
  bool operator != (const DependSpecT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DependSpecT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DependSpecT &a, DependSpecT &b);

typedef struct _TaskSpecT__isset {
  _TaskSpecT__isset() : name(false), depends(false) {}
  bool name;
  bool depends;
} _TaskSpecT__isset;

class TaskSpecT {
 public:

  static const char* ascii_fingerprint; // = "1603170361566071292880A0F6D53016";
  static const uint8_t binary_fingerprint[16]; // = {0x16,0x03,0x17,0x03,0x61,0x56,0x60,0x71,0x29,0x28,0x80,0xA0,0xF6,0xD5,0x30,0x16};

  TaskSpecT() : name() {
  }

  virtual ~TaskSpecT() throw() {}

  std::string name;
  std::vector<DependSpecT>  depends;

  _TaskSpecT__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_depends(const std::vector<DependSpecT> & val) {
    depends = val;
  }

  bool operator == (const TaskSpecT & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(depends == rhs.depends))
      return false;
    return true;
  }
  bool operator != (const TaskSpecT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TaskSpecT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TaskSpecT &a, TaskSpecT &b);

typedef struct _LayerSpecT__isset {
  _LayerSpecT__isset() : range(false), tags(false), serv(false), minCores(false), maxCores(false), minRam(false), maxRam(false), threadable(false), maxRetries(false), chunk(true), depends(false), tasks(false), env(false) {}
  bool range;
  bool tags;
  bool serv;
  bool minCores;
  bool maxCores;
  bool minRam;
  bool maxRam;
  bool threadable;
  bool maxRetries;
  bool chunk;
  bool depends;
  bool tasks;
  bool env;
} _LayerSpecT__isset;

class LayerSpecT {
 public:

  static const char* ascii_fingerprint; // = "723CBC032BDE437FE77A7B90A3AFB3F8";
  static const uint8_t binary_fingerprint[16]; // = {0x72,0x3C,0xBC,0x03,0x2B,0xDE,0x43,0x7F,0xE7,0x7A,0x7B,0x90,0xA3,0xAF,0xB3,0xF8};

  LayerSpecT() : name(), range(), serv(), minCores(0), maxCores(0), minRam(0), maxRam(0), threadable(0), maxRetries(0), chunk(1) {
  }

  virtual ~LayerSpecT() throw() {}

  std::string name;
  std::vector<std::string>  command;
  std::string range;
  std::vector<std::string>  tags;
  std::string serv;
  int32_t minCores;
  int32_t maxCores;
  int32_t minRam;
  int32_t maxRam;
  bool threadable;
  int32_t maxRetries;
  int32_t chunk;
  std::vector<DependSpecT>  depends;
  std::vector<TaskSpecT>  tasks;
  Attrs env;

  _LayerSpecT__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_command(const std::vector<std::string> & val) {
    command = val;
  }

  void __set_range(const std::string& val) {
    range = val;
    __isset.range = true;
  }

  void __set_tags(const std::vector<std::string> & val) {
    tags = val;
    __isset.tags = true;
  }

  void __set_serv(const std::string& val) {
    serv = val;
    __isset.serv = true;
  }

  void __set_minCores(const int32_t val) {
    minCores = val;
    __isset.minCores = true;
  }

  void __set_maxCores(const int32_t val) {
    maxCores = val;
    __isset.maxCores = true;
  }

  void __set_minRam(const int32_t val) {
    minRam = val;
    __isset.minRam = true;
  }

  void __set_maxRam(const int32_t val) {
    maxRam = val;
    __isset.maxRam = true;
  }

  void __set_threadable(const bool val) {
    threadable = val;
    __isset.threadable = true;
  }

  void __set_maxRetries(const int32_t val) {
    maxRetries = val;
    __isset.maxRetries = true;
  }

  void __set_chunk(const int32_t val) {
    chunk = val;
  }

  void __set_depends(const std::vector<DependSpecT> & val) {
    depends = val;
  }

  void __set_tasks(const std::vector<TaskSpecT> & val) {
    tasks = val;
  }

  void __set_env(const Attrs& val) {
    env = val;
  }

  bool operator == (const LayerSpecT & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(command == rhs.command))
      return false;
    if (__isset.range != rhs.__isset.range)
      return false;
    else if (__isset.range && !(range == rhs.range))
      return false;
    if (__isset.tags != rhs.__isset.tags)
      return false;
    else if (__isset.tags && !(tags == rhs.tags))
      return false;
    if (__isset.serv != rhs.__isset.serv)
      return false;
    else if (__isset.serv && !(serv == rhs.serv))
      return false;
    if (__isset.minCores != rhs.__isset.minCores)
      return false;
    else if (__isset.minCores && !(minCores == rhs.minCores))
      return false;
    if (__isset.maxCores != rhs.__isset.maxCores)
      return false;
    else if (__isset.maxCores && !(maxCores == rhs.maxCores))
      return false;
    if (__isset.minRam != rhs.__isset.minRam)
      return false;
    else if (__isset.minRam && !(minRam == rhs.minRam))
      return false;
    if (__isset.maxRam != rhs.__isset.maxRam)
      return false;
    else if (__isset.maxRam && !(maxRam == rhs.maxRam))
      return false;
    if (__isset.threadable != rhs.__isset.threadable)
      return false;
    else if (__isset.threadable && !(threadable == rhs.threadable))
      return false;
    if (__isset.maxRetries != rhs.__isset.maxRetries)
      return false;
    else if (__isset.maxRetries && !(maxRetries == rhs.maxRetries))
      return false;
    if (!(chunk == rhs.chunk))
      return false;
    if (!(depends == rhs.depends))
      return false;
    if (!(tasks == rhs.tasks))
      return false;
    if (!(env == rhs.env))
      return false;
    return true;
  }
  bool operator != (const LayerSpecT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LayerSpecT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LayerSpecT &a, LayerSpecT &b);

typedef struct _JobSpecT__isset {
  _JobSpecT__isset() : name(false), project(false), paused(false), username(false), uid(false), logPath(false), layers(false), depends(false), attrs(false), env(false) {}
  bool name;
  bool project;
  bool paused;
  bool username;
  bool uid;
  bool logPath;
  bool layers;
  bool depends;
  bool attrs;
  bool env;
} _JobSpecT__isset;

class JobSpecT {
 public:

  static const char* ascii_fingerprint; // = "A23225E616BF3B5ADFAA8264A5C15638";
  static const uint8_t binary_fingerprint[16]; // = {0xA2,0x32,0x25,0xE6,0x16,0xBF,0x3B,0x5A,0xDF,0xAA,0x82,0x64,0xA5,0xC1,0x56,0x38};

  JobSpecT() : name(), project(), paused(0), username(), uid(0), logPath() {
  }

  virtual ~JobSpecT() throw() {}

  std::string name;
  std::string project;
  bool paused;
  std::string username;
  int32_t uid;
  std::string logPath;
  std::vector<LayerSpecT>  layers;
  std::vector<DependSpecT>  depends;
  Attrs attrs;
  Attrs env;

  _JobSpecT__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_project(const std::string& val) {
    project = val;
  }

  void __set_paused(const bool val) {
    paused = val;
  }

  void __set_username(const std::string& val) {
    username = val;
  }

  void __set_uid(const int32_t val) {
    uid = val;
  }

  void __set_logPath(const std::string& val) {
    logPath = val;
  }

  void __set_layers(const std::vector<LayerSpecT> & val) {
    layers = val;
  }

  void __set_depends(const std::vector<DependSpecT> & val) {
    depends = val;
  }

  void __set_attrs(const Attrs& val) {
    attrs = val;
  }

  void __set_env(const Attrs& val) {
    env = val;
  }

  bool operator == (const JobSpecT & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(project == rhs.project))
      return false;
    if (!(paused == rhs.paused))
      return false;
    if (!(username == rhs.username))
      return false;
    if (!(uid == rhs.uid))
      return false;
    if (!(logPath == rhs.logPath))
      return false;
    if (!(layers == rhs.layers))
      return false;
    if (!(depends == rhs.depends))
      return false;
    if (!(attrs == rhs.attrs))
      return false;
    if (!(env == rhs.env))
      return false;
    return true;
  }
  bool operator != (const JobSpecT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const JobSpecT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(JobSpecT &a, JobSpecT &b);

typedef struct _JobFilterT__isset {
  _JobFilterT__isset() : matchingOnly(true), project(false), user(false), regex(false), states(false), jobIds(false), name(false) {}
  bool matchingOnly;
  bool project;
  bool user;
  bool regex;
  bool states;
  bool jobIds;
  bool name;
} _JobFilterT__isset;

class JobFilterT {
 public:

  static const char* ascii_fingerprint; // = "F937E676F235563615B336A844347504";
  static const uint8_t binary_fingerprint[16]; // = {0xF9,0x37,0xE6,0x76,0xF2,0x35,0x56,0x36,0x15,0xB3,0x36,0xA8,0x44,0x34,0x75,0x04};

  JobFilterT() : matchingOnly(false), regex() {
  }

  virtual ~JobFilterT() throw() {}

  bool matchingOnly;
  std::vector<std::string>  project;
  std::vector<std::string>  user;
  std::string regex;
  std::vector<JobState::type>  states;
  std::vector< ::Plow::Guid>  jobIds;
  std::vector<std::string>  name;

  _JobFilterT__isset __isset;

  void __set_matchingOnly(const bool val) {
    matchingOnly = val;
  }

  void __set_project(const std::vector<std::string> & val) {
    project = val;
  }

  void __set_user(const std::vector<std::string> & val) {
    user = val;
  }

  void __set_regex(const std::string& val) {
    regex = val;
  }

  void __set_states(const std::vector<JobState::type> & val) {
    states = val;
  }

  void __set_jobIds(const std::vector< ::Plow::Guid> & val) {
    jobIds = val;
  }

  void __set_name(const std::vector<std::string> & val) {
    name = val;
  }

  bool operator == (const JobFilterT & rhs) const
  {
    if (!(matchingOnly == rhs.matchingOnly))
      return false;
    if (!(project == rhs.project))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(regex == rhs.regex))
      return false;
    if (!(states == rhs.states))
      return false;
    if (!(jobIds == rhs.jobIds))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const JobFilterT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const JobFilterT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(JobFilterT &a, JobFilterT &b);

typedef struct _TaskFilterT__isset {
  _TaskFilterT__isset() : jobId(false), layerIds(false), states(false), limit(true), offset(true), lastUpdateTime(true), taskIds(false), nodeIds(false) {}
  bool jobId;
  bool layerIds;
  bool states;
  bool limit;
  bool offset;
  bool lastUpdateTime;
  bool taskIds;
  bool nodeIds;
} _TaskFilterT__isset;

class TaskFilterT {
 public:

  static const char* ascii_fingerprint; // = "03A6BE121ED140806516419A5432A4AA";
  static const uint8_t binary_fingerprint[16]; // = {0x03,0xA6,0xBE,0x12,0x1E,0xD1,0x40,0x80,0x65,0x16,0x41,0x9A,0x54,0x32,0xA4,0xAA};

  TaskFilterT() : jobId(), limit(0), offset(0), lastUpdateTime(0LL) {
  }

  virtual ~TaskFilterT() throw() {}

   ::Plow::Guid jobId;
  std::vector< ::Plow::Guid>  layerIds;
  std::vector<TaskState::type>  states;
  int32_t limit;
  int32_t offset;
  int64_t lastUpdateTime;
  std::vector< ::Plow::Guid>  taskIds;
  std::vector< ::Plow::Guid>  nodeIds;

  _TaskFilterT__isset __isset;

  void __set_jobId(const  ::Plow::Guid& val) {
    jobId = val;
  }

  void __set_layerIds(const std::vector< ::Plow::Guid> & val) {
    layerIds = val;
  }

  void __set_states(const std::vector<TaskState::type> & val) {
    states = val;
  }

  void __set_limit(const int32_t val) {
    limit = val;
  }

  void __set_offset(const int32_t val) {
    offset = val;
  }

  void __set_lastUpdateTime(const int64_t val) {
    lastUpdateTime = val;
  }

  void __set_taskIds(const std::vector< ::Plow::Guid> & val) {
    taskIds = val;
  }

  void __set_nodeIds(const std::vector< ::Plow::Guid> & val) {
    nodeIds = val;
  }

  bool operator == (const TaskFilterT & rhs) const
  {
    if (!(jobId == rhs.jobId))
      return false;
    if (!(layerIds == rhs.layerIds))
      return false;
    if (!(states == rhs.states))
      return false;
    if (!(limit == rhs.limit))
      return false;
    if (!(offset == rhs.offset))
      return false;
    if (!(lastUpdateTime == rhs.lastUpdateTime))
      return false;
    if (!(taskIds == rhs.taskIds))
      return false;
    if (!(nodeIds == rhs.nodeIds))
      return false;
    return true;
  }
  bool operator != (const TaskFilterT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TaskFilterT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TaskFilterT &a, TaskFilterT &b);

typedef struct _NodeFilterT__isset {
  _NodeFilterT__isset() : hostIds(false), clusterIds(false), regex(false), hostnames(false), states(false), locked(false) {}
  bool hostIds;
  bool clusterIds;
  bool regex;
  bool hostnames;
  bool states;
  bool locked;
} _NodeFilterT__isset;

class NodeFilterT {
 public:

  static const char* ascii_fingerprint; // = "A5FBE94ED5EBC0E091C6D957CD35627C";
  static const uint8_t binary_fingerprint[16]; // = {0xA5,0xFB,0xE9,0x4E,0xD5,0xEB,0xC0,0xE0,0x91,0xC6,0xD9,0x57,0xCD,0x35,0x62,0x7C};

  NodeFilterT() : regex(), locked(0) {
  }

  virtual ~NodeFilterT() throw() {}

  std::vector< ::Plow::Guid>  hostIds;
  std::vector< ::Plow::Guid>  clusterIds;
  std::string regex;
  std::vector<std::string>  hostnames;
  std::vector<NodeState::type>  states;
  bool locked;

  _NodeFilterT__isset __isset;

  void __set_hostIds(const std::vector< ::Plow::Guid> & val) {
    hostIds = val;
  }

  void __set_clusterIds(const std::vector< ::Plow::Guid> & val) {
    clusterIds = val;
  }

  void __set_regex(const std::string& val) {
    regex = val;
  }

  void __set_hostnames(const std::vector<std::string> & val) {
    hostnames = val;
  }

  void __set_states(const std::vector<NodeState::type> & val) {
    states = val;
  }

  void __set_locked(const bool val) {
    locked = val;
    __isset.locked = true;
  }

  bool operator == (const NodeFilterT & rhs) const
  {
    if (!(hostIds == rhs.hostIds))
      return false;
    if (!(clusterIds == rhs.clusterIds))
      return false;
    if (!(regex == rhs.regex))
      return false;
    if (!(hostnames == rhs.hostnames))
      return false;
    if (!(states == rhs.states))
      return false;
    if (__isset.locked != rhs.__isset.locked)
      return false;
    else if (__isset.locked && !(locked == rhs.locked))
      return false;
    return true;
  }
  bool operator != (const NodeFilterT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NodeFilterT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(NodeFilterT &a, NodeFilterT &b);

typedef struct _QuotaFilterT__isset {
  _QuotaFilterT__isset() : project(false), cluster(false) {}
  bool project;
  bool cluster;
} _QuotaFilterT__isset;

class QuotaFilterT {
 public:

  static const char* ascii_fingerprint; // = "92AA23526EDCB0628C830C8758ED7059";
  static const uint8_t binary_fingerprint[16]; // = {0x92,0xAA,0x23,0x52,0x6E,0xDC,0xB0,0x62,0x8C,0x83,0x0C,0x87,0x58,0xED,0x70,0x59};

  QuotaFilterT() {
  }

  virtual ~QuotaFilterT() throw() {}

  std::vector< ::Plow::Guid>  project;
  std::vector< ::Plow::Guid>  cluster;

  _QuotaFilterT__isset __isset;

  void __set_project(const std::vector< ::Plow::Guid> & val) {
    project = val;
    __isset.project = true;
  }

  void __set_cluster(const std::vector< ::Plow::Guid> & val) {
    cluster = val;
    __isset.cluster = true;
  }

  bool operator == (const QuotaFilterT & rhs) const
  {
    if (__isset.project != rhs.__isset.project)
      return false;
    else if (__isset.project && !(project == rhs.project))
      return false;
    if (__isset.cluster != rhs.__isset.cluster)
      return false;
    else if (__isset.cluster && !(cluster == rhs.cluster))
      return false;
    return true;
  }
  bool operator != (const QuotaFilterT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const QuotaFilterT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(QuotaFilterT &a, QuotaFilterT &b);

typedef struct _OutputT__isset {
  _OutputT__isset() : path(false), attrs(false) {}
  bool path;
  bool attrs;
} _OutputT__isset;

class OutputT {
 public:

  static const char* ascii_fingerprint; // = "F7C641917C22B35AE581CCD54910B00D";
  static const uint8_t binary_fingerprint[16]; // = {0xF7,0xC6,0x41,0x91,0x7C,0x22,0xB3,0x5A,0xE5,0x81,0xCC,0xD5,0x49,0x10,0xB0,0x0D};

  OutputT() : path() {
  }

  virtual ~OutputT() throw() {}

  std::string path;
   ::Plow::Attrs attrs;

  _OutputT__isset __isset;

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_attrs(const  ::Plow::Attrs& val) {
    attrs = val;
  }

  bool operator == (const OutputT & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(attrs == rhs.attrs))
      return false;
    return true;
  }
  bool operator != (const OutputT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OutputT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(OutputT &a, OutputT &b);

} // namespace

#endif
