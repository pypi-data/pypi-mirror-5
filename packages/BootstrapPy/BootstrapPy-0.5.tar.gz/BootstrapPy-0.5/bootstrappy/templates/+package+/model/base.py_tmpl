from ${package}.model import db
from sqlalchemy.types import DateTime

__all__=['DBBase']


class DBBase(object):
    """Base class for DB Model"""

    query = db.query_property()

    # Comparison conveniences
    def __eq__(self, other):
        if isinstance(other, self):
            return self.__class__.__name__
        return False

    def __ne__(self, other):
        return not self.__eq__(other)

    @property
    def __str__(self):
        try:
            return str("<{0}".format(self.__class__.__name__)) + \
                   str("({0})>".format(self.name))
        except AttributeError:
            return str("<{0}".format(self.__class__.__name__)) + \
                   str("({0})>".format(self.id))

    def create(self, obj):
        if type(obj) is not dict:
            raise TypeError("You need to pass a dictionary for create.")

        for k in obj:
            if hasattr(self, k):
                setattr(self, k, obj[k])

        # Use this to get record ID.
        db.flush()

        return self.id

    @classmethod
    def delete(cls, id=None):
        return cls.get(id).delete()

    @classmethod
    def all(cls):
        cls.query.all()

    @classmethod
    def first(cls):
        cls.query.first()

    def todict(self):
        """ JSON PG Date object serializer, and whatever else is
        needed for convenience...
        """
        def convert_datetime(val):
            return val.strftime("%Y-%m-%d")

        d = {}
        for c in self.__table__.columns:
            if isinstance(c.type, DateTime):
                value = convert_datetime(getattr(self, c.name))
            else:
                value = getattr(self, c.name)
            d[c.name] = value
        return d

    def iterfunc(self):
        """Returns an iterable that supports .next()
        so we can do dict(cls_instance)
        """
        return self.todict()