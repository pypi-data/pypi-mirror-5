<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <title>Test coverage report: django.contrib.contenttypes.generic</title>
    <style type="text/css" media="screen">
      a
      {
        color: #3d707a;
      }
      
      a:hover, a:active
      {
        color: #bf7d18;
      }
    
      body 
      {
        font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        font-size: 13px;
      }
      
      .nav 
      {
        font-size: 12px;
        margin-left: 50px;
      }

      .ignored
      {
        color: #707070;
      }

      .executed 
      {
        color: #3d9900;
      }

      .missed 
      {
        color: red;
        font-weight: bold;
      }

      .excluded 
      {
        color: #6090f0;
        font-weight: lighter;
      }
    
      #content-header 
      {
        font-size: 12px;
        padding: 18px 0 18px 50px;
      }

      #content-header h1 
      {
        font-size: 16px;
        margin: 10px 0 0 0;
        color: #909090;
      }
      
      #module-name
      {
        color: #583707;
      }
    
      #content-header p
      {
        font-size: 13px;
        margin: 0;
        color: #909090;
      }

      #content-header .normal 
      {
        color: #609030;
      }

      #content-header .warning 
      {
        color: #d0a000;
      }

      #content-header .critical 
      {
        color: red;
      }
      
      #source-listing 
      {
        margin-bottom: 24px;
      }

      #source-listing ol 
      {
        padding: 0 0 0 50px;
        width: 90%;
        font-family: monospace;
        list-style-position: outside;
      }

      #source-listing ol li 
      {
        line-height: 18px;
        font-size: small;
      }
        
      #source-listing ol code 
      {
        padding:  0 .001em 0 0; /* Firefox doesn't render empty li's properly */
        font-size: medium;
        white-space: pre;
      }
   </style>
  </head>

  <body>

<div class="nav">
  <a href="django.contrib.auth.views.html">django.contrib.auth.views</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="django.contrib.contenttypes.management.html">django.contrib.contenttypes.management</a>
</div>

<div id="content-header">
  <h1>
    <span id="module-name">django.contrib.contenttypes.generic</span>:
    276 total statements,
    <span class="critical">0.0% covered</span>
  </h1>
  <p>Generated: Wed 2013-03-13 10:33 CET</p>
  <p>Source file: /media/Envs/Envs/filer-gallery/lib/python2.7/site-packages/django/contrib/contenttypes/generic.py</p>
  <p>
    Stats:
    <span class="executed">0 executed</span>,
    <span class="missed">256 missed</span>,
    <span class="excluded">20 excluded</span>,
    <span class="ignored">222 ignored</span> 
  </p> 
</div>

<div id="source-listing">
  <ol>
    <li class="ignored"><code>"""</code></li>
<li class="ignored"><code>Classes allowing "generic" relations through ContentType and object-id fields.</code></li>
<li class="ignored"><code>"""</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>from collections import defaultdict</code></li>
<li class="excluded"><code>from functools import partial</code></li>
<li class="excluded"><code>from operator import attrgetter</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>from django.core.exceptions import ObjectDoesNotExist</code></li>
<li class="excluded"><code>from django.db import connection</code></li>
<li class="excluded"><code>from django.db.models import signals</code></li>
<li class="excluded"><code>from django.db import models, router, DEFAULT_DB_ALIAS</code></li>
<li class="excluded"><code>from django.db.models.fields.related import RelatedField, Field, ManyToManyRel</code></li>
<li class="excluded"><code>from django.db.models.loading import get_model</code></li>
<li class="excluded"><code>from django.forms import ModelForm</code></li>
<li class="excluded"><code>from django.forms.models import BaseModelFormSet, modelformset_factory, save_instance</code></li>
<li class="excluded"><code>from django.contrib.admin.options import InlineModelAdmin, flatten_fieldsets</code></li>
<li class="excluded"><code>from django.contrib.contenttypes.models import ContentType</code></li>
<li class="excluded"><code>from django.utils.encoding import smart_unicode</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class GenericForeignKey(object):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Provides a generic relation to any object through content-type/object-id</code></li>
<li class="ignored"><code>    fields.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def __init__(self, ct_field="content_type", fk_field="object_id"):</code></li>
<li class="missed"><code>        self.ct_field = ct_field</code></li>
<li class="missed"><code>        self.fk_field = fk_field</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def contribute_to_class(self, cls, name):</code></li>
<li class="missed"><code>        self.name = name</code></li>
<li class="missed"><code>        self.model = cls</code></li>
<li class="missed"><code>        self.cache_attr = "_%s_cache" % name</code></li>
<li class="missed"><code>        cls._meta.add_virtual_field(self)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # For some reason I don't totally understand, using weakrefs here doesn't work.</code></li>
<li class="missed"><code>        signals.pre_init.connect(self.instance_pre_init, sender=cls, weak=False)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Connect myself as the descriptor for this field</code></li>
<li class="missed"><code>        setattr(cls, name, self)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def instance_pre_init(self, signal, sender, args, kwargs, **_kwargs):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Handles initializing an object with the generic FK instaed of</code></li>
<li class="ignored"><code>        content-type/object-id fields.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if self.name in kwargs:</code></li>
<li class="missed"><code>            value = kwargs.pop(self.name)</code></li>
<li class="missed"><code>            kwargs[self.ct_field] = self.get_content_type(obj=value)</code></li>
<li class="missed"><code>            kwargs[self.fk_field] = value._get_pk_val()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_content_type(self, obj=None, id=None, using=None):</code></li>
<li class="excluded"><code>        # Convenience function using get_model avoids a circular import when</code></li>
<li class="ignored"><code>        # using this model</code></li>
<li class="missed"><code>        ContentType = get_model("contenttypes", "contenttype")</code></li>
<li class="missed"><code>        if obj:</code></li>
<li class="missed"><code>            return ContentType.objects.db_manager(obj._state.db).get_for_model(obj)</code></li>
<li class="missed"><code>        elif id:</code></li>
<li class="missed"><code>            return ContentType.objects.db_manager(using).get_for_id(id)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="ignored"><code>            # This should never happen. I love comments like this, don't you?</code></li>
<li class="missed"><code>            raise Exception("Impossible arguments to GFK.get_content_type!")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_prefetch_query_set(self, instances):</code></li>
<li class="ignored"><code>        # For efficiency, group the instances by content type and then do one</code></li>
<li class="ignored"><code>        # query per model</code></li>
<li class="missed"><code>        fk_dict = defaultdict(set)</code></li>
<li class="ignored"><code>        # We need one instance for each group in order to get the right db:</code></li>
<li class="missed"><code>        instance_dict = {}</code></li>
<li class="missed"><code>        ct_attname = self.model._meta.get_field(self.ct_field).get_attname()</code></li>
<li class="missed"><code>        for instance in instances:</code></li>
<li class="ignored"><code>            # We avoid looking for values if either ct_id or fkey value is None</code></li>
<li class="missed"><code>            ct_id = getattr(instance, ct_attname)</code></li>
<li class="missed"><code>            if ct_id is not None:</code></li>
<li class="missed"><code>                fk_val = getattr(instance, self.fk_field)</code></li>
<li class="missed"><code>                if fk_val is not None:</code></li>
<li class="missed"><code>                    fk_dict[ct_id].add(fk_val)</code></li>
<li class="missed"><code>                    instance_dict[ct_id] = instance</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        ret_val = []</code></li>
<li class="missed"><code>        for ct_id, fkeys in fk_dict.items():</code></li>
<li class="missed"><code>            instance = instance_dict[ct_id]</code></li>
<li class="missed"><code>            ct = self.get_content_type(id=ct_id, using=instance._state.db)</code></li>
<li class="missed"><code>            ret_val.extend(ct.get_all_objects_for_this_type(pk__in=fkeys))</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # For doing the join in Python, we have to match both the FK val and the</code></li>
<li class="ignored"><code>        # content type, so we use a callable that returns a (fk, class) pair.</code></li>
<li class="missed"><code>        def gfk_key(obj):</code></li>
<li class="missed"><code>            ct_id = getattr(obj, ct_attname)</code></li>
<li class="missed"><code>            if ct_id is None:</code></li>
<li class="missed"><code>                return None</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                model = self.get_content_type(id=ct_id,</code></li>
<li class="ignored"><code>                                              using=obj._state.db).model_class()</code></li>
<li class="missed"><code>                return (model._meta.pk.get_prep_value(getattr(obj, self.fk_field)),</code></li>
<li class="ignored"><code>                        model)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        return (ret_val,</code></li>
<li class="ignored"><code>                lambda obj: (obj._get_pk_val(), obj.__class__),</code></li>
<li class="ignored"><code>                gfk_key,</code></li>
<li class="ignored"><code>                True,</code></li>
<li class="ignored"><code>                self.cache_attr)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def is_cached(self, instance):</code></li>
<li class="missed"><code>        return hasattr(instance, self.cache_attr)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def __get__(self, instance, instance_type=None):</code></li>
<li class="missed"><code>        if instance is None:</code></li>
<li class="missed"><code>            return self</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        try:</code></li>
<li class="missed"><code>            return getattr(instance, self.cache_attr)</code></li>
<li class="missed"><code>        except AttributeError:</code></li>
<li class="missed"><code>            rel_obj = None</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # Make sure to use ContentType.objects.get_for_id() to ensure that</code></li>
<li class="ignored"><code>            # lookups are cached (see ticket #5570). This takes more code than</code></li>
<li class="ignored"><code>            # the naive ``getattr(instance, self.ct_field)``, but has better</code></li>
<li class="ignored"><code>            # performance when dealing with GFKs in loops and such.</code></li>
<li class="missed"><code>            f = self.model._meta.get_field(self.ct_field)</code></li>
<li class="missed"><code>            ct_id = getattr(instance, f.get_attname(), None)</code></li>
<li class="missed"><code>            if ct_id:</code></li>
<li class="missed"><code>                ct = self.get_content_type(id=ct_id, using=instance._state.db)</code></li>
<li class="missed"><code>                try:</code></li>
<li class="missed"><code>                    rel_obj = ct.get_object_for_this_type(pk=getattr(instance, self.fk_field))</code></li>
<li class="missed"><code>                except ObjectDoesNotExist:</code></li>
<li class="missed"><code>                    pass</code></li>
<li class="missed"><code>            setattr(instance, self.cache_attr, rel_obj)</code></li>
<li class="missed"><code>            return rel_obj</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def __set__(self, instance, value):</code></li>
<li class="missed"><code>        if instance is None:</code></li>
<li class="missed"><code>            raise AttributeError(u"%s must be accessed via instance" % self.related.opts.object_name)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        ct = None</code></li>
<li class="missed"><code>        fk = None</code></li>
<li class="missed"><code>        if value is not None:</code></li>
<li class="missed"><code>            ct = self.get_content_type(obj=value)</code></li>
<li class="missed"><code>            fk = value._get_pk_val()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        setattr(instance, self.ct_field, ct)</code></li>
<li class="missed"><code>        setattr(instance, self.fk_field, fk)</code></li>
<li class="missed"><code>        setattr(instance, self.cache_attr, value)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class GenericRelation(RelatedField, Field):</code></li>
<li class="ignored"><code>    """Provides an accessor to generic related objects (e.g. comments)"""</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def __init__(self, to, **kwargs):</code></li>
<li class="missed"><code>        kwargs['verbose_name'] = kwargs.get('verbose_name', None)</code></li>
<li class="missed"><code>        kwargs['rel'] = GenericRel(to,</code></li>
<li class="ignored"><code>                            related_name=kwargs.pop('related_name', None),</code></li>
<li class="ignored"><code>                            limit_choices_to=kwargs.pop('limit_choices_to', None),</code></li>
<li class="ignored"><code>                            symmetrical=kwargs.pop('symmetrical', True))</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Override content-type/object-id field names on the related class</code></li>
<li class="missed"><code>        self.object_id_field_name = kwargs.pop("object_id_field", "object_id")</code></li>
<li class="missed"><code>        self.content_type_field_name = kwargs.pop("content_type_field", "content_type")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        kwargs['blank'] = True</code></li>
<li class="missed"><code>        kwargs['editable'] = False</code></li>
<li class="missed"><code>        kwargs['serialize'] = False</code></li>
<li class="missed"><code>        Field.__init__(self, **kwargs)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_choices_default(self):</code></li>
<li class="missed"><code>        return Field.get_choices(self, include_blank=False)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def value_to_string(self, obj):</code></li>
<li class="missed"><code>        qs = getattr(obj, self.name).all()</code></li>
<li class="missed"><code>        return smart_unicode([instance._get_pk_val() for instance in qs])</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def m2m_db_table(self):</code></li>
<li class="missed"><code>        return self.rel.to._meta.db_table</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def m2m_column_name(self):</code></li>
<li class="missed"><code>        return self.object_id_field_name</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def m2m_reverse_name(self):</code></li>
<li class="missed"><code>        return self.rel.to._meta.pk.column</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def m2m_target_field_name(self):</code></li>
<li class="missed"><code>        return self.model._meta.pk.name</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def m2m_reverse_target_field_name(self):</code></li>
<li class="missed"><code>        return self.rel.to._meta.pk.name</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def contribute_to_class(self, cls, name):</code></li>
<li class="missed"><code>        super(GenericRelation, self).contribute_to_class(cls, name)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Save a reference to which model this class is on for future use</code></li>
<li class="missed"><code>        self.model = cls</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Add the descriptor for the m2m relation</code></li>
<li class="missed"><code>        setattr(cls, self.name, ReverseGenericRelatedObjectsDescriptor(self))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def contribute_to_related_class(self, cls, related):</code></li>
<li class="missed"><code>        pass</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def set_attributes_from_rel(self):</code></li>
<li class="missed"><code>        pass</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_internal_type(self):</code></li>
<li class="missed"><code>        return "ManyToManyField"</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def db_type(self, connection):</code></li>
<li class="ignored"><code>        # Since we're simulating a ManyToManyField, in effect, best return the</code></li>
<li class="ignored"><code>        # same db_type as well.</code></li>
<li class="missed"><code>        return None</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def extra_filters(self, pieces, pos, negate):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Return an extra filter to the queryset so that the results are filtered</code></li>
<li class="ignored"><code>        on the appropriate content type.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if negate:</code></li>
<li class="missed"><code>            return []</code></li>
<li class="missed"><code>        ContentType = get_model("contenttypes", "contenttype")</code></li>
<li class="missed"><code>        content_type = ContentType.objects.get_for_model(self.model)</code></li>
<li class="missed"><code>        prefix = "__".join(pieces[:pos + 1])</code></li>
<li class="missed"><code>        return [("%s__%s" % (prefix, self.content_type_field_name),</code></li>
<li class="ignored"><code>            content_type)]</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def bulk_related_objects(self, objs, using=DEFAULT_DB_ALIAS):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Return all objects related to ``objs`` via this ``GenericRelation``.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.rel.to._base_manager.db_manager(using).filter(**{</code></li>
<li class="ignored"><code>                "%s__pk" % self.content_type_field_name:</code></li>
<li class="ignored"><code>                    ContentType.objects.db_manager(using).get_for_model(self.model).pk,</code></li>
<li class="ignored"><code>                "%s__in" % self.object_id_field_name:</code></li>
<li class="ignored"><code>                    [obj.pk for obj in objs]</code></li>
<li class="ignored"><code>                })</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class ReverseGenericRelatedObjectsDescriptor(object):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    This class provides the functionality that makes the related-object</code></li>
<li class="ignored"><code>    managers available as attributes on a model class, for fields that have</code></li>
<li class="ignored"><code>    multiple "remote" values and have a GenericRelation defined in their model</code></li>
<li class="ignored"><code>    (rather than having another model pointed *at* them). In the example</code></li>
<li class="ignored"><code>    "article.publications", the publications attribute is a</code></li>
<li class="ignored"><code>    ReverseGenericRelatedObjectsDescriptor instance.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="missed"><code>    def __init__(self, field):</code></li>
<li class="missed"><code>        self.field = field</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def __get__(self, instance, instance_type=None):</code></li>
<li class="missed"><code>        if instance is None:</code></li>
<li class="missed"><code>            return self</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>        # This import is done here to avoid circular import importing this module</code></li>
<li class="excluded"><code>        from django.contrib.contenttypes.models import ContentType</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Dynamically create a class that subclasses the related model's</code></li>
<li class="ignored"><code>        # default manager.</code></li>
<li class="missed"><code>        rel_model = self.field.rel.to</code></li>
<li class="missed"><code>        superclass = rel_model._default_manager.__class__</code></li>
<li class="missed"><code>        RelatedManager = create_generic_related_manager(superclass)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        qn = connection.ops.quote_name</code></li>
<li class="missed"><code>        content_type = ContentType.objects.db_manager(instance._state.db).get_for_model(instance)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        manager = RelatedManager(</code></li>
<li class="ignored"><code>            model = rel_model,</code></li>
<li class="ignored"><code>            instance = instance,</code></li>
<li class="ignored"><code>            symmetrical = (self.field.rel.symmetrical and instance.__class__ == rel_model),</code></li>
<li class="ignored"><code>            source_col_name = qn(self.field.m2m_column_name()),</code></li>
<li class="ignored"><code>            target_col_name = qn(self.field.m2m_reverse_name()),</code></li>
<li class="ignored"><code>            content_type = content_type,</code></li>
<li class="ignored"><code>            content_type_field_name = self.field.content_type_field_name,</code></li>
<li class="ignored"><code>            object_id_field_name = self.field.object_id_field_name,</code></li>
<li class="ignored"><code>            prefetch_cache_name = self.field.attname,</code></li>
<li class="ignored"><code>        )</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        return manager</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def __set__(self, instance, value):</code></li>
<li class="missed"><code>        if instance is None:</code></li>
<li class="missed"><code>            raise AttributeError("Manager must be accessed via instance")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        manager = self.__get__(instance)</code></li>
<li class="missed"><code>        manager.clear()</code></li>
<li class="missed"><code>        for obj in value:</code></li>
<li class="missed"><code>            manager.add(obj)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def create_generic_related_manager(superclass):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Factory function for a manager that subclasses 'superclass' (which is a</code></li>
<li class="ignored"><code>    Manager) and adds behavior for generic related objects.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    class GenericRelatedObjectManager(superclass):</code></li>
<li class="missed"><code>        def __init__(self, model=None, instance=None, symmetrical=None,</code></li>
<li class="ignored"><code>                     source_col_name=None, target_col_name=None, content_type=None,</code></li>
<li class="ignored"><code>                     content_type_field_name=None, object_id_field_name=None,</code></li>
<li class="ignored"><code>                     prefetch_cache_name=None):</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            super(GenericRelatedObjectManager, self).__init__()</code></li>
<li class="missed"><code>            self.model = model</code></li>
<li class="missed"><code>            self.content_type = content_type</code></li>
<li class="missed"><code>            self.symmetrical = symmetrical</code></li>
<li class="missed"><code>            self.instance = instance</code></li>
<li class="missed"><code>            self.source_col_name = source_col_name</code></li>
<li class="missed"><code>            self.target_col_name = target_col_name</code></li>
<li class="missed"><code>            self.content_type_field_name = content_type_field_name</code></li>
<li class="missed"><code>            self.object_id_field_name = object_id_field_name</code></li>
<li class="missed"><code>            self.prefetch_cache_name = prefetch_cache_name</code></li>
<li class="missed"><code>            self.pk_val = self.instance._get_pk_val()</code></li>
<li class="missed"><code>            self.core_filters = {</code></li>
<li class="ignored"><code>                '%s__pk' % content_type_field_name: content_type.id,</code></li>
<li class="ignored"><code>                '%s__exact' % object_id_field_name: instance._get_pk_val(),</code></li>
<li class="ignored"><code>            }</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        def get_query_set(self):</code></li>
<li class="missed"><code>            try:</code></li>
<li class="missed"><code>                return self.instance._prefetched_objects_cache[self.prefetch_cache_name]</code></li>
<li class="missed"><code>            except (AttributeError, KeyError):</code></li>
<li class="missed"><code>                db = self._db or router.db_for_read(self.model, instance=self.instance)</code></li>
<li class="missed"><code>                return super(GenericRelatedObjectManager, self).get_query_set().using(db).filter(**self.core_filters)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        def get_prefetch_query_set(self, instances):</code></li>
<li class="missed"><code>            db = self._db or router.db_for_read(self.model, instance=instances[0])</code></li>
<li class="missed"><code>            query = {</code></li>
<li class="ignored"><code>                '%s__pk' % self.content_type_field_name: self.content_type.id,</code></li>
<li class="ignored"><code>                '%s__in' % self.object_id_field_name:</code></li>
<li class="ignored"><code>                    set(obj._get_pk_val() for obj in instances)</code></li>
<li class="ignored"><code>                }</code></li>
<li class="missed"><code>            qs = super(GenericRelatedObjectManager, self).get_query_set().using(db).filter(**query)</code></li>
<li class="missed"><code>            return (qs,</code></li>
<li class="ignored"><code>                    attrgetter(self.object_id_field_name),</code></li>
<li class="ignored"><code>                    lambda obj: obj._get_pk_val(),</code></li>
<li class="ignored"><code>                    False,</code></li>
<li class="ignored"><code>                    self.prefetch_cache_name)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        def add(self, *objs):</code></li>
<li class="missed"><code>            for obj in objs:</code></li>
<li class="missed"><code>                if not isinstance(obj, self.model):</code></li>
<li class="missed"><code>                    raise TypeError("'%s' instance expected" % self.model._meta.object_name)</code></li>
<li class="missed"><code>                setattr(obj, self.content_type_field_name, self.content_type)</code></li>
<li class="missed"><code>                setattr(obj, self.object_id_field_name, self.pk_val)</code></li>
<li class="missed"><code>                obj.save()</code></li>
<li class="missed"><code>        add.alters_data = True</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        def remove(self, *objs):</code></li>
<li class="missed"><code>            db = router.db_for_write(self.model, instance=self.instance)</code></li>
<li class="missed"><code>            for obj in objs:</code></li>
<li class="missed"><code>                obj.delete(using=db)</code></li>
<li class="missed"><code>        remove.alters_data = True</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        def clear(self):</code></li>
<li class="missed"><code>            db = router.db_for_write(self.model, instance=self.instance)</code></li>
<li class="missed"><code>            for obj in self.all():</code></li>
<li class="missed"><code>                obj.delete(using=db)</code></li>
<li class="missed"><code>        clear.alters_data = True</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        def create(self, **kwargs):</code></li>
<li class="missed"><code>            kwargs[self.content_type_field_name] = self.content_type</code></li>
<li class="missed"><code>            kwargs[self.object_id_field_name] = self.pk_val</code></li>
<li class="missed"><code>            db = router.db_for_write(self.model, instance=self.instance)</code></li>
<li class="missed"><code>            return super(GenericRelatedObjectManager, self).using(db).create(**kwargs)</code></li>
<li class="missed"><code>        create.alters_data = True</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    return GenericRelatedObjectManager</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class GenericRel(ManyToManyRel):</code></li>
<li class="missed"><code>    def __init__(self, to, related_name=None, limit_choices_to=None, symmetrical=True):</code></li>
<li class="missed"><code>        self.to = to</code></li>
<li class="missed"><code>        self.related_name = related_name</code></li>
<li class="missed"><code>        self.limit_choices_to = limit_choices_to or {}</code></li>
<li class="missed"><code>        self.symmetrical = symmetrical</code></li>
<li class="missed"><code>        self.multiple = True</code></li>
<li class="missed"><code>        self.through = None</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class BaseGenericInlineFormSet(BaseModelFormSet):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    A formset for generic inline objects to a parent.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def __init__(self, data=None, files=None, instance=None, save_as_new=None,</code></li>
<li class="ignored"><code>                 prefix=None, queryset=None):</code></li>
<li class="ignored"><code>        # Avoid a circular import.</code></li>
<li class="excluded"><code>        from django.contrib.contenttypes.models import ContentType</code></li>
<li class="missed"><code>        opts = self.model._meta</code></li>
<li class="missed"><code>        self.instance = instance</code></li>
<li class="missed"><code>        self.rel_name = '-'.join((</code></li>
<li class="ignored"><code>            opts.app_label, opts.object_name.lower(),</code></li>
<li class="ignored"><code>            self.ct_field.name, self.ct_fk_field.name,</code></li>
<li class="ignored"><code>        ))</code></li>
<li class="missed"><code>        if self.instance is None or self.instance.pk is None:</code></li>
<li class="missed"><code>            qs = self.model._default_manager.none()</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            if queryset is None:</code></li>
<li class="missed"><code>                queryset = self.model._default_manager</code></li>
<li class="missed"><code>            qs = queryset.filter(**{</code></li>
<li class="ignored"><code>                self.ct_field.name: ContentType.objects.get_for_model(self.instance),</code></li>
<li class="ignored"><code>                self.ct_fk_field.name: self.instance.pk,</code></li>
<li class="ignored"><code>            })</code></li>
<li class="missed"><code>        super(BaseGenericInlineFormSet, self).__init__(</code></li>
<li class="ignored"><code>            queryset=qs, data=data, files=files,</code></li>
<li class="ignored"><code>            prefix=prefix</code></li>
<li class="ignored"><code>        )</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @classmethod</code></li>
<li class="ignored"><code>    def get_default_prefix(cls):</code></li>
<li class="missed"><code>        opts = cls.model._meta</code></li>
<li class="missed"><code>        return '-'.join((opts.app_label, opts.object_name.lower(),</code></li>
<li class="ignored"><code>                        cls.ct_field.name, cls.ct_fk_field.name,</code></li>
<li class="ignored"><code>        ))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def save_new(self, form, commit=True):</code></li>
<li class="ignored"><code>        # Avoid a circular import.</code></li>
<li class="excluded"><code>        from django.contrib.contenttypes.models import ContentType</code></li>
<li class="missed"><code>        kwargs = {</code></li>
<li class="ignored"><code>            self.ct_field.get_attname(): ContentType.objects.get_for_model(self.instance).pk,</code></li>
<li class="ignored"><code>            self.ct_fk_field.get_attname(): self.instance.pk,</code></li>
<li class="ignored"><code>        }</code></li>
<li class="missed"><code>        new_obj = self.model(**kwargs)</code></li>
<li class="missed"><code>        return save_instance(form, new_obj, commit=commit)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def generic_inlineformset_factory(model, form=ModelForm,</code></li>
<li class="ignored"><code>                                  formset=BaseGenericInlineFormSet,</code></li>
<li class="ignored"><code>                                  ct_field="content_type", fk_field="object_id",</code></li>
<li class="ignored"><code>                                  fields=None, exclude=None,</code></li>
<li class="ignored"><code>                                  extra=3, can_order=False, can_delete=True,</code></li>
<li class="ignored"><code>                                  max_num=None,</code></li>
<li class="ignored"><code>                                  formfield_callback=None):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Returns an ``GenericInlineFormSet`` for the given kwargs.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    You must provide ``ct_field`` and ``object_id`` if they different from the</code></li>
<li class="ignored"><code>    defaults ``content_type`` and ``object_id`` respectively.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="missed"><code>    opts = model._meta</code></li>
<li class="ignored"><code>    # Avoid a circular import.</code></li>
<li class="excluded"><code>    from django.contrib.contenttypes.models import ContentType</code></li>
<li class="ignored"><code>    # if there is no field called `ct_field` let the exception propagate</code></li>
<li class="missed"><code>    ct_field = opts.get_field(ct_field)</code></li>
<li class="missed"><code>    if not isinstance(ct_field, models.ForeignKey) or ct_field.rel.to != ContentType:</code></li>
<li class="missed"><code>        raise Exception("fk_name '%s' is not a ForeignKey to ContentType" % ct_field)</code></li>
<li class="missed"><code>    fk_field = opts.get_field(fk_field) # let the exception propagate</code></li>
<li class="missed"><code>    if exclude is not None:</code></li>
<li class="missed"><code>        exclude = list(exclude)</code></li>
<li class="missed"><code>        exclude.extend([ct_field.name, fk_field.name])</code></li>
<li class="ignored"><code>    else:</code></li>
<li class="missed"><code>        exclude = [ct_field.name, fk_field.name]</code></li>
<li class="missed"><code>    FormSet = modelformset_factory(model, form=form,</code></li>
<li class="ignored"><code>                                   formfield_callback=formfield_callback,</code></li>
<li class="ignored"><code>                                   formset=formset,</code></li>
<li class="ignored"><code>                                   extra=extra, can_delete=can_delete, can_order=can_order,</code></li>
<li class="ignored"><code>                                   fields=fields, exclude=exclude, max_num=max_num)</code></li>
<li class="missed"><code>    FormSet.ct_field = ct_field</code></li>
<li class="missed"><code>    FormSet.ct_fk_field = fk_field</code></li>
<li class="missed"><code>    return FormSet</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class GenericInlineModelAdmin(InlineModelAdmin):</code></li>
<li class="missed"><code>    ct_field = "content_type"</code></li>
<li class="missed"><code>    ct_fk_field = "object_id"</code></li>
<li class="missed"><code>    formset = BaseGenericInlineFormSet</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_formset(self, request, obj=None, **kwargs):</code></li>
<li class="missed"><code>        if self.declared_fieldsets:</code></li>
<li class="missed"><code>            fields = flatten_fieldsets(self.declared_fieldsets)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            fields = None</code></li>
<li class="missed"><code>        if self.exclude is None:</code></li>
<li class="missed"><code>            exclude = []</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            exclude = list(self.exclude)</code></li>
<li class="missed"><code>        exclude.extend(self.get_readonly_fields(request, obj))</code></li>
<li class="missed"><code>        if self.exclude is None and hasattr(self.form, '_meta') and self.form._meta.exclude:</code></li>
<li class="ignored"><code>            # Take the custom ModelForm's Meta.exclude into account only if the</code></li>
<li class="ignored"><code>            # GenericInlineModelAdmin doesn't define its own.</code></li>
<li class="missed"><code>            exclude.extend(self.form._meta.exclude)</code></li>
<li class="missed"><code>        exclude = exclude or None</code></li>
<li class="missed"><code>        can_delete = self.can_delete and self.has_delete_permission(request, obj)</code></li>
<li class="missed"><code>        defaults = {</code></li>
<li class="ignored"><code>            "ct_field": self.ct_field,</code></li>
<li class="ignored"><code>            "fk_field": self.ct_fk_field,</code></li>
<li class="ignored"><code>            "form": self.form,</code></li>
<li class="ignored"><code>            "formfield_callback": partial(self.formfield_for_dbfield, request=request),</code></li>
<li class="ignored"><code>            "formset": self.formset,</code></li>
<li class="ignored"><code>            "extra": self.extra,</code></li>
<li class="ignored"><code>            "can_delete": can_delete,</code></li>
<li class="ignored"><code>            "can_order": False,</code></li>
<li class="ignored"><code>            "fields": fields,</code></li>
<li class="ignored"><code>            "max_num": self.max_num,</code></li>
<li class="ignored"><code>            "exclude": exclude</code></li>
<li class="ignored"><code>        }</code></li>
<li class="missed"><code>        defaults.update(kwargs)</code></li>
<li class="missed"><code>        return generic_inlineformset_factory(self.model, **defaults)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class GenericStackedInline(GenericInlineModelAdmin):</code></li>
<li class="missed"><code>    template = 'admin/edit_inline/stacked.html'</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class GenericTabularInline(GenericInlineModelAdmin):</code></li>
<li class="missed"><code>    template = 'admin/edit_inline/tabular.html'</code></li>
  </ol>
</div>

<div class="nav">
  <a href="django.contrib.auth.views.html">django.contrib.auth.views</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="django.contrib.contenttypes.management.html">django.contrib.contenttypes.management</a>
</div>

  </body>
</html>

