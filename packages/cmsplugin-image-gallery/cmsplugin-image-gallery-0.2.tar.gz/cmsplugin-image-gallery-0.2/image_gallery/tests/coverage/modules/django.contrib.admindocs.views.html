<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <title>Test coverage report: django.contrib.admindocs.views</title>
    <style type="text/css" media="screen">
      a
      {
        color: #3d707a;
      }
      
      a:hover, a:active
      {
        color: #bf7d18;
      }
    
      body 
      {
        font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        font-size: 13px;
      }
      
      .nav 
      {
        font-size: 12px;
        margin-left: 50px;
      }

      .ignored
      {
        color: #707070;
      }

      .executed 
      {
        color: #3d9900;
      }

      .missed 
      {
        color: red;
        font-weight: bold;
      }

      .excluded 
      {
        color: #6090f0;
        font-weight: lighter;
      }
    
      #content-header 
      {
        font-size: 12px;
        padding: 18px 0 18px 50px;
      }

      #content-header h1 
      {
        font-size: 16px;
        margin: 10px 0 0 0;
        color: #909090;
      }
      
      #module-name
      {
        color: #583707;
      }
    
      #content-header p
      {
        font-size: 13px;
        margin: 0;
        color: #909090;
      }

      #content-header .normal 
      {
        color: #609030;
      }

      #content-header .warning 
      {
        color: #d0a000;
      }

      #content-header .critical 
      {
        color: red;
      }
      
      #source-listing 
      {
        margin-bottom: 24px;
      }

      #source-listing ol 
      {
        padding: 0 0 0 50px;
        width: 90%;
        font-family: monospace;
        list-style-position: outside;
      }

      #source-listing ol li 
      {
        line-height: 18px;
        font-size: small;
      }
        
      #source-listing ol code 
      {
        padding:  0 .001em 0 0; /* Firefox doesn't render empty li's properly */
        font-size: medium;
        white-space: pre;
      }
   </style>
  </head>

  <body>

<div class="nav">
  <a href="django.contrib.admindocs.utils.html">django.contrib.admindocs.utils</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="django.contrib.auth.__init__.html">django.contrib.auth.__init__</a>
</div>

<div id="content-header">
  <h1>
    <span id="module-name">django.contrib.admindocs.views</span>:
    214 total statements,
    <span class="critical">0.0% covered</span>
  </h1>
  <p>Generated: Wed 2013-03-13 10:33 CET</p>
  <p>Source file: /media/Envs/Envs/filer-gallery/lib/python2.7/site-packages/django/contrib/admindocs/views.py</p>
  <p>
    Stats:
    <span class="executed">0 executed</span>,
    <span class="missed">197 missed</span>,
    <span class="excluded">17 excluded</span>,
    <span class="ignored">168 ignored</span> 
  </p> 
</div>

<div id="source-listing">
  <ol>
    <li class="excluded"><code>import inspect</code></li>
<li class="excluded"><code>import os</code></li>
<li class="excluded"><code>import re</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>from django import template</code></li>
<li class="excluded"><code>from django.template import RequestContext</code></li>
<li class="excluded"><code>from django.conf import settings</code></li>
<li class="excluded"><code>from django.contrib.admin.views.decorators import staff_member_required</code></li>
<li class="excluded"><code>from django.db import models</code></li>
<li class="excluded"><code>from django.shortcuts import render_to_response</code></li>
<li class="excluded"><code>from django.core.exceptions import ImproperlyConfigured, ViewDoesNotExist</code></li>
<li class="excluded"><code>from django.http import Http404</code></li>
<li class="excluded"><code>from django.core import urlresolvers</code></li>
<li class="excluded"><code>from django.contrib.admindocs import utils</code></li>
<li class="excluded"><code>from django.contrib.sites.models import Site</code></li>
<li class="excluded"><code>from django.utils.importlib import import_module</code></li>
<li class="excluded"><code>from django.utils.translation import ugettext as _</code></li>
<li class="excluded"><code>from django.utils.safestring import mark_safe</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code># Exclude methods starting with these strings from documentation</code></li>
<li class="missed"><code>MODEL_METHODS_EXCLUDE = ('_', 'add_', 'delete', 'save', 'set_')</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class GenericSite(object):</code></li>
<li class="missed"><code>    domain = 'example.com'</code></li>
<li class="missed"><code>    name = 'my site'</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>@staff_member_required</code></li>
<li class="ignored"><code>def doc_index(request):</code></li>
<li class="missed"><code>    if not utils.docutils_is_available:</code></li>
<li class="missed"><code>        return missing_docutils_page(request)</code></li>
<li class="missed"><code>    return render_to_response('admin_doc/index.html', {</code></li>
<li class="ignored"><code>        'root_path': urlresolvers.reverse('admin:index'),</code></li>
<li class="ignored"><code>    }, context_instance=RequestContext(request))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>@staff_member_required</code></li>
<li class="ignored"><code>def bookmarklets(request):</code></li>
<li class="missed"><code>    admin_root = urlresolvers.reverse('admin:index')</code></li>
<li class="missed"><code>    return render_to_response('admin_doc/bookmarklets.html', {</code></li>
<li class="ignored"><code>        'root_path': admin_root,</code></li>
<li class="ignored"><code>        'admin_url': mark_safe("%s://%s%s" % (request.is_secure() and 'https' or 'http', request.get_host(), admin_root)),</code></li>
<li class="ignored"><code>    }, context_instance=RequestContext(request))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>@staff_member_required</code></li>
<li class="ignored"><code>def template_tag_index(request):</code></li>
<li class="missed"><code>    if not utils.docutils_is_available:</code></li>
<li class="missed"><code>        return missing_docutils_page(request)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    load_all_installed_template_libraries()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    tags = []</code></li>
<li class="missed"><code>    app_libs = template.libraries.items()</code></li>
<li class="missed"><code>    builtin_libs = [(None, lib) for lib in template.builtins]</code></li>
<li class="missed"><code>    for module_name, library in builtin_libs + app_libs:</code></li>
<li class="missed"><code>        for tag_name, tag_func in library.tags.items():</code></li>
<li class="missed"><code>            title, body, metadata = utils.parse_docstring(tag_func.__doc__)</code></li>
<li class="missed"><code>            if title:</code></li>
<li class="missed"><code>                title = utils.parse_rst(title, 'tag', _('tag:') + tag_name)</code></li>
<li class="missed"><code>            if body:</code></li>
<li class="missed"><code>                body = utils.parse_rst(body, 'tag', _('tag:') + tag_name)</code></li>
<li class="missed"><code>            for key in metadata:</code></li>
<li class="missed"><code>                metadata[key] = utils.parse_rst(metadata[key], 'tag', _('tag:') + tag_name)</code></li>
<li class="missed"><code>            if library in template.builtins:</code></li>
<li class="missed"><code>                tag_library = None</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                tag_library = module_name.split('.')[-1]</code></li>
<li class="missed"><code>            tags.append({</code></li>
<li class="ignored"><code>                'name': tag_name,</code></li>
<li class="ignored"><code>                'title': title,</code></li>
<li class="ignored"><code>                'body': body,</code></li>
<li class="ignored"><code>                'meta': metadata,</code></li>
<li class="ignored"><code>                'library': tag_library,</code></li>
<li class="ignored"><code>            })</code></li>
<li class="missed"><code>    return render_to_response('admin_doc/template_tag_index.html', {</code></li>
<li class="ignored"><code>        'root_path': urlresolvers.reverse('admin:index'),</code></li>
<li class="ignored"><code>        'tags': tags</code></li>
<li class="ignored"><code>    }, context_instance=RequestContext(request))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>@staff_member_required</code></li>
<li class="ignored"><code>def template_filter_index(request):</code></li>
<li class="missed"><code>    if not utils.docutils_is_available:</code></li>
<li class="missed"><code>        return missing_docutils_page(request)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    load_all_installed_template_libraries()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    filters = []</code></li>
<li class="missed"><code>    app_libs = template.libraries.items()</code></li>
<li class="missed"><code>    builtin_libs = [(None, lib) for lib in template.builtins]</code></li>
<li class="missed"><code>    for module_name, library in builtin_libs + app_libs:</code></li>
<li class="missed"><code>        for filter_name, filter_func in library.filters.items():</code></li>
<li class="missed"><code>            title, body, metadata = utils.parse_docstring(filter_func.__doc__)</code></li>
<li class="missed"><code>            if title:</code></li>
<li class="missed"><code>                title = utils.parse_rst(title, 'filter', _('filter:') + filter_name)</code></li>
<li class="missed"><code>            if body:</code></li>
<li class="missed"><code>                body = utils.parse_rst(body, 'filter', _('filter:') + filter_name)</code></li>
<li class="missed"><code>            for key in metadata:</code></li>
<li class="missed"><code>                metadata[key] = utils.parse_rst(metadata[key], 'filter', _('filter:') + filter_name)</code></li>
<li class="missed"><code>            if library in template.builtins:</code></li>
<li class="missed"><code>                tag_library = None</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                tag_library = module_name.split('.')[-1]</code></li>
<li class="missed"><code>            filters.append({</code></li>
<li class="ignored"><code>                'name': filter_name,</code></li>
<li class="ignored"><code>                'title': title,</code></li>
<li class="ignored"><code>                'body': body,</code></li>
<li class="ignored"><code>                'meta': metadata,</code></li>
<li class="ignored"><code>                'library': tag_library,</code></li>
<li class="ignored"><code>            })</code></li>
<li class="missed"><code>    return render_to_response('admin_doc/template_filter_index.html', {</code></li>
<li class="ignored"><code>        'root_path': urlresolvers.reverse('admin:index'),</code></li>
<li class="ignored"><code>        'filters': filters</code></li>
<li class="ignored"><code>    }, context_instance=RequestContext(request))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>@staff_member_required</code></li>
<li class="ignored"><code>def view_index(request):</code></li>
<li class="missed"><code>    if not utils.docutils_is_available:</code></li>
<li class="missed"><code>        return missing_docutils_page(request)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    if settings.ADMIN_FOR:</code></li>
<li class="missed"><code>        settings_modules = [import_module(m) for m in settings.ADMIN_FOR]</code></li>
<li class="ignored"><code>    else:</code></li>
<li class="missed"><code>        settings_modules = [settings]</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    views = []</code></li>
<li class="missed"><code>    for settings_mod in settings_modules:</code></li>
<li class="missed"><code>        urlconf = import_module(settings_mod.ROOT_URLCONF)</code></li>
<li class="missed"><code>        view_functions = extract_views_from_urlpatterns(urlconf.urlpatterns)</code></li>
<li class="missed"><code>        if Site._meta.installed:</code></li>
<li class="missed"><code>            site_obj = Site.objects.get(pk=settings_mod.SITE_ID)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            site_obj = GenericSite()</code></li>
<li class="missed"><code>        for (func, regex) in view_functions:</code></li>
<li class="missed"><code>            views.append({</code></li>
<li class="ignored"><code>                'full_name': '%s.%s' % (func.__module__, getattr(func, '__name__', func.__class__.__name__)),</code></li>
<li class="ignored"><code>                'site_id': settings_mod.SITE_ID,</code></li>
<li class="ignored"><code>                'site': site_obj,</code></li>
<li class="ignored"><code>                'url': simplify_regex(regex),</code></li>
<li class="ignored"><code>            })</code></li>
<li class="missed"><code>    return render_to_response('admin_doc/view_index.html', {</code></li>
<li class="ignored"><code>        'root_path': urlresolvers.reverse('admin:index'),</code></li>
<li class="ignored"><code>        'views': views</code></li>
<li class="ignored"><code>    }, context_instance=RequestContext(request))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>@staff_member_required</code></li>
<li class="ignored"><code>def view_detail(request, view):</code></li>
<li class="missed"><code>    if not utils.docutils_is_available:</code></li>
<li class="missed"><code>        return missing_docutils_page(request)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    mod, func = urlresolvers.get_mod_func(view)</code></li>
<li class="missed"><code>    try:</code></li>
<li class="missed"><code>        view_func = getattr(import_module(mod), func)</code></li>
<li class="missed"><code>    except (ImportError, AttributeError):</code></li>
<li class="missed"><code>        raise Http404</code></li>
<li class="missed"><code>    title, body, metadata = utils.parse_docstring(view_func.__doc__)</code></li>
<li class="missed"><code>    if title:</code></li>
<li class="missed"><code>        title = utils.parse_rst(title, 'view', _('view:') + view)</code></li>
<li class="missed"><code>    if body:</code></li>
<li class="missed"><code>        body = utils.parse_rst(body, 'view', _('view:') + view)</code></li>
<li class="missed"><code>    for key in metadata:</code></li>
<li class="missed"><code>        metadata[key] = utils.parse_rst(metadata[key], 'model', _('view:') + view)</code></li>
<li class="missed"><code>    return render_to_response('admin_doc/view_detail.html', {</code></li>
<li class="ignored"><code>        'root_path': urlresolvers.reverse('admin:index'),</code></li>
<li class="ignored"><code>        'name': view,</code></li>
<li class="ignored"><code>        'summary': title,</code></li>
<li class="ignored"><code>        'body': body,</code></li>
<li class="ignored"><code>        'meta': metadata,</code></li>
<li class="ignored"><code>    }, context_instance=RequestContext(request))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>@staff_member_required</code></li>
<li class="ignored"><code>def model_index(request):</code></li>
<li class="missed"><code>    if not utils.docutils_is_available:</code></li>
<li class="missed"><code>        return missing_docutils_page(request)</code></li>
<li class="missed"><code>    m_list = [m._meta for m in models.get_models()]</code></li>
<li class="missed"><code>    return render_to_response('admin_doc/model_index.html', {</code></li>
<li class="ignored"><code>        'root_path': urlresolvers.reverse('admin:index'),</code></li>
<li class="ignored"><code>        'models': m_list</code></li>
<li class="ignored"><code>    }, context_instance=RequestContext(request))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>@staff_member_required</code></li>
<li class="ignored"><code>def model_detail(request, app_label, model_name):</code></li>
<li class="missed"><code>    if not utils.docutils_is_available:</code></li>
<li class="missed"><code>        return missing_docutils_page(request)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # Get the model class.</code></li>
<li class="missed"><code>    try:</code></li>
<li class="missed"><code>        app_mod = models.get_app(app_label)</code></li>
<li class="missed"><code>    except ImproperlyConfigured:</code></li>
<li class="missed"><code>        raise Http404(_("App %r not found") % app_label)</code></li>
<li class="missed"><code>    model = None</code></li>
<li class="missed"><code>    for m in models.get_models(app_mod):</code></li>
<li class="missed"><code>        if m._meta.object_name.lower() == model_name:</code></li>
<li class="missed"><code>            model = m</code></li>
<li class="missed"><code>            break</code></li>
<li class="missed"><code>    if model is None:</code></li>
<li class="missed"><code>        raise Http404(_("Model %(model_name)r not found in app %(app_label)r") % {'model_name': model_name, 'app_label': app_label})</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    opts = model._meta</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # Gather fields/field descriptions.</code></li>
<li class="missed"><code>    fields = []</code></li>
<li class="missed"><code>    for field in opts.fields:</code></li>
<li class="ignored"><code>        # ForeignKey is a special case since the field will actually be a</code></li>
<li class="ignored"><code>        # descriptor that returns the other object</code></li>
<li class="missed"><code>        if isinstance(field, models.ForeignKey):</code></li>
<li class="missed"><code>            data_type = field.rel.to.__name__</code></li>
<li class="missed"><code>            app_label = field.rel.to._meta.app_label</code></li>
<li class="missed"><code>            verbose = utils.parse_rst((_("the related `%(app_label)s.%(data_type)s` object")  % {'app_label': app_label, 'data_type': data_type}), 'model', _('model:') + data_type)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            data_type = get_readable_field_data_type(field)</code></li>
<li class="missed"><code>            verbose = field.verbose_name</code></li>
<li class="missed"><code>        fields.append({</code></li>
<li class="ignored"><code>            'name': field.name,</code></li>
<li class="ignored"><code>            'data_type': data_type,</code></li>
<li class="ignored"><code>            'verbose': verbose,</code></li>
<li class="ignored"><code>            'help_text': field.help_text,</code></li>
<li class="ignored"><code>        })</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # Gather many-to-many fields.</code></li>
<li class="missed"><code>    for field in opts.many_to_many:</code></li>
<li class="missed"><code>        data_type = field.rel.to.__name__</code></li>
<li class="missed"><code>        app_label = field.rel.to._meta.app_label</code></li>
<li class="missed"><code>        verbose = _("related `%(app_label)s.%(object_name)s` objects") % {'app_label': app_label, 'object_name': data_type}</code></li>
<li class="missed"><code>        fields.append({</code></li>
<li class="ignored"><code>            'name': "%s.all" % field.name,</code></li>
<li class="ignored"><code>            "data_type": 'List',</code></li>
<li class="ignored"><code>            'verbose': utils.parse_rst(_("all %s") % verbose , 'model', _('model:') + opts.module_name),</code></li>
<li class="ignored"><code>        })</code></li>
<li class="missed"><code>        fields.append({</code></li>
<li class="ignored"><code>            'name'      : "%s.count" % field.name,</code></li>
<li class="ignored"><code>            'data_type' : 'Integer',</code></li>
<li class="ignored"><code>            'verbose'   : utils.parse_rst(_("number of %s") % verbose , 'model', _('model:') + opts.module_name),</code></li>
<li class="ignored"><code>        })</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # Gather model methods.</code></li>
<li class="missed"><code>    for func_name, func in model.__dict__.items():</code></li>
<li class="missed"><code>        if (inspect.isfunction(func) and len(inspect.getargspec(func)[0]) == 1):</code></li>
<li class="missed"><code>            try:</code></li>
<li class="missed"><code>                for exclude in MODEL_METHODS_EXCLUDE:</code></li>
<li class="missed"><code>                    if func_name.startswith(exclude):</code></li>
<li class="missed"><code>                        raise StopIteration</code></li>
<li class="missed"><code>            except StopIteration:</code></li>
<li class="missed"><code>                continue</code></li>
<li class="missed"><code>            verbose = func.__doc__</code></li>
<li class="missed"><code>            if verbose:</code></li>
<li class="missed"><code>                verbose = utils.parse_rst(utils.trim_docstring(verbose), 'model', _('model:') + opts.module_name)</code></li>
<li class="missed"><code>            fields.append({</code></li>
<li class="ignored"><code>                'name': func_name,</code></li>
<li class="ignored"><code>                'data_type': get_return_data_type(func_name),</code></li>
<li class="ignored"><code>                'verbose': verbose,</code></li>
<li class="ignored"><code>            })</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # Gather related objects</code></li>
<li class="missed"><code>    for rel in opts.get_all_related_objects() + opts.get_all_related_many_to_many_objects():</code></li>
<li class="missed"><code>        verbose = _("related `%(app_label)s.%(object_name)s` objects") % {'app_label': rel.opts.app_label, 'object_name': rel.opts.object_name}</code></li>
<li class="missed"><code>        accessor = rel.get_accessor_name()</code></li>
<li class="missed"><code>        fields.append({</code></li>
<li class="ignored"><code>            'name'      : "%s.all" % accessor,</code></li>
<li class="ignored"><code>            'data_type' : 'List',</code></li>
<li class="ignored"><code>            'verbose'   : utils.parse_rst(_("all %s") % verbose , 'model', _('model:') + opts.module_name),</code></li>
<li class="ignored"><code>        })</code></li>
<li class="missed"><code>        fields.append({</code></li>
<li class="ignored"><code>            'name'      : "%s.count" % accessor,</code></li>
<li class="ignored"><code>            'data_type' : 'Integer',</code></li>
<li class="ignored"><code>            'verbose'   : utils.parse_rst(_("number of %s") % verbose , 'model', _('model:') + opts.module_name),</code></li>
<li class="ignored"><code>        })</code></li>
<li class="missed"><code>    return render_to_response('admin_doc/model_detail.html', {</code></li>
<li class="ignored"><code>        'root_path': urlresolvers.reverse('admin:index'),</code></li>
<li class="ignored"><code>        'name': '%s.%s' % (opts.app_label, opts.object_name),</code></li>
<li class="ignored"><code>        'summary': _("Fields on %s objects") % opts.object_name,</code></li>
<li class="ignored"><code>        'description': model.__doc__,</code></li>
<li class="ignored"><code>        'fields': fields,</code></li>
<li class="ignored"><code>    }, context_instance=RequestContext(request))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>@staff_member_required</code></li>
<li class="ignored"><code>def template_detail(request, template):</code></li>
<li class="missed"><code>    templates = []</code></li>
<li class="missed"><code>    for site_settings_module in settings.ADMIN_FOR:</code></li>
<li class="missed"><code>        settings_mod = import_module(site_settings_module)</code></li>
<li class="missed"><code>        if Site._meta.installed:</code></li>
<li class="missed"><code>            site_obj = Site.objects.get(pk=settings_mod.SITE_ID)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            site_obj = GenericSite()</code></li>
<li class="missed"><code>        for dir in settings_mod.TEMPLATE_DIRS:</code></li>
<li class="missed"><code>            template_file = os.path.join(dir, template)</code></li>
<li class="missed"><code>            templates.append({</code></li>
<li class="ignored"><code>                'file': template_file,</code></li>
<li class="ignored"><code>                'exists': os.path.exists(template_file),</code></li>
<li class="ignored"><code>                'contents': lambda: os.path.exists(template_file) and open(template_file).read() or '',</code></li>
<li class="ignored"><code>                'site_id': settings_mod.SITE_ID,</code></li>
<li class="ignored"><code>                'site': site_obj,</code></li>
<li class="ignored"><code>                'order': list(settings_mod.TEMPLATE_DIRS).index(dir),</code></li>
<li class="ignored"><code>            })</code></li>
<li class="missed"><code>    return render_to_response('admin_doc/template_detail.html', {</code></li>
<li class="ignored"><code>        'root_path': urlresolvers.reverse('admin:index'),</code></li>
<li class="ignored"><code>        'name': template,</code></li>
<li class="ignored"><code>        'templates': templates,</code></li>
<li class="ignored"><code>    }, context_instance=RequestContext(request))</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>####################</code></li>
<li class="ignored"><code># Helper functions #</code></li>
<li class="ignored"><code>####################</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def missing_docutils_page(request):</code></li>
<li class="ignored"><code>    """Display an error message for people without docutils"""</code></li>
<li class="missed"><code>    return render_to_response('admin_doc/missing_docutils.html')</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def load_all_installed_template_libraries():</code></li>
<li class="ignored"><code>    # Load/register all template tag libraries from installed apps.</code></li>
<li class="missed"><code>    for module_name in template.get_templatetags_modules():</code></li>
<li class="missed"><code>        mod = import_module(module_name)</code></li>
<li class="missed"><code>        try:</code></li>
<li class="missed"><code>            libraries = [</code></li>
<li class="ignored"><code>                os.path.splitext(p)[0]</code></li>
<li class="ignored"><code>                for p in os.listdir(os.path.dirname(mod.__file__))</code></li>
<li class="ignored"><code>                if p.endswith('.py') and p[0].isalpha()</code></li>
<li class="ignored"><code>            ]</code></li>
<li class="missed"><code>        except OSError:</code></li>
<li class="missed"><code>            libraries = []</code></li>
<li class="missed"><code>        for library_name in libraries:</code></li>
<li class="missed"><code>            try:</code></li>
<li class="missed"><code>                lib = template.get_library(library_name)</code></li>
<li class="missed"><code>            except template.InvalidTemplateLibrary, e:</code></li>
<li class="missed"><code>                pass</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def get_return_data_type(func_name):</code></li>
<li class="ignored"><code>    """Return a somewhat-helpful data type given a function name"""</code></li>
<li class="missed"><code>    if func_name.startswith('get_'):</code></li>
<li class="missed"><code>        if func_name.endswith('_list'):</code></li>
<li class="missed"><code>            return 'List'</code></li>
<li class="missed"><code>        elif func_name.endswith('_count'):</code></li>
<li class="missed"><code>            return 'Integer'</code></li>
<li class="missed"><code>    return ''</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def get_readable_field_data_type(field):</code></li>
<li class="ignored"><code>    """Returns the description for a given field type, if it exists,</code></li>
<li class="ignored"><code>    Fields' descriptions can contain format strings, which will be interpolated</code></li>
<li class="ignored"><code>    against the values of field.__dict__ before being output."""</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    return field.description % field.__dict__</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def extract_views_from_urlpatterns(urlpatterns, base=''):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Return a list of views from a list of urlpatterns.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    Each object in the returned list is a two-tuple: (view_func, regex)</code></li>
<li class="ignored"><code>    """</code></li>
<li class="missed"><code>    views = []</code></li>
<li class="missed"><code>    for p in urlpatterns:</code></li>
<li class="missed"><code>        if hasattr(p, 'url_patterns'):</code></li>
<li class="missed"><code>            try:</code></li>
<li class="missed"><code>                patterns = p.url_patterns</code></li>
<li class="missed"><code>            except ImportError:</code></li>
<li class="missed"><code>                continue</code></li>
<li class="missed"><code>            views.extend(extract_views_from_urlpatterns(patterns, base + p.regex.pattern))</code></li>
<li class="missed"><code>        elif hasattr(p, 'callback'):</code></li>
<li class="missed"><code>            try:</code></li>
<li class="missed"><code>                views.append((p.callback, base + p.regex.pattern))</code></li>
<li class="missed"><code>            except ViewDoesNotExist:</code></li>
<li class="missed"><code>                continue</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            raise TypeError(_("%s does not appear to be a urlpattern object") % p)</code></li>
<li class="missed"><code>    return views</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>named_group_matcher = re.compile(r'\(\?P(&lt;\w+&gt;).+?\)')</code></li>
<li class="missed"><code>non_named_group_matcher = re.compile(r'\(.*?\)')</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def simplify_regex(pattern):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Clean up urlpattern regexes into something somewhat readable by Mere Humans:</code></li>
<li class="ignored"><code>    turns something like "^(?P&lt;sport_slug&gt;\w+)/athletes/(?P&lt;athlete_slug&gt;\w+)/$"</code></li>
<li class="ignored"><code>    into "&lt;sport_slug&gt;/athletes/&lt;athlete_slug&gt;/"</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    # handle named groups first</code></li>
<li class="missed"><code>    pattern = named_group_matcher.sub(lambda m: m.group(1), pattern)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # handle non-named groups</code></li>
<li class="missed"><code>    pattern = non_named_group_matcher.sub("&lt;var&gt;", pattern)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # clean up any outstanding regex-y characters.</code></li>
<li class="missed"><code>    pattern = pattern.replace('^', '').replace('$', '').replace('?', '').replace('//', '/').replace('\\', '')</code></li>
<li class="missed"><code>    if not pattern.startswith('/'):</code></li>
<li class="missed"><code>        pattern = '/' + pattern</code></li>
<li class="missed"><code>    return pattern</code></li>
  </ol>
</div>

<div class="nav">
  <a href="django.contrib.admindocs.utils.html">django.contrib.admindocs.utils</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="django.contrib.auth.__init__.html">django.contrib.auth.__init__</a>
</div>

  </body>
</html>

