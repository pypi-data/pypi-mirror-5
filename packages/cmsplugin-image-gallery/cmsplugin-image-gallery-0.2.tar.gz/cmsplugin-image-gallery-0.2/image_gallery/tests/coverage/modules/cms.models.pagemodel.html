<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <title>Test coverage report: cms.models.pagemodel</title>
    <style type="text/css" media="screen">
      a
      {
        color: #3d707a;
      }
      
      a:hover, a:active
      {
        color: #bf7d18;
      }
    
      body 
      {
        font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        font-size: 13px;
      }
      
      .nav 
      {
        font-size: 12px;
        margin-left: 50px;
      }

      .ignored
      {
        color: #707070;
      }

      .executed 
      {
        color: #3d9900;
      }

      .missed 
      {
        color: red;
        font-weight: bold;
      }

      .excluded 
      {
        color: #6090f0;
        font-weight: lighter;
      }
    
      #content-header 
      {
        font-size: 12px;
        padding: 18px 0 18px 50px;
      }

      #content-header h1 
      {
        font-size: 16px;
        margin: 10px 0 0 0;
        color: #909090;
      }
      
      #module-name
      {
        color: #583707;
      }
    
      #content-header p
      {
        font-size: 13px;
        margin: 0;
        color: #909090;
      }

      #content-header .normal 
      {
        color: #609030;
      }

      #content-header .warning 
      {
        color: #d0a000;
      }

      #content-header .critical 
      {
        color: red;
      }
      
      #source-listing 
      {
        margin-bottom: 24px;
      }

      #source-listing ol 
      {
        padding: 0 0 0 50px;
        width: 90%;
        font-family: monospace;
        list-style-position: outside;
      }

      #source-listing ol li 
      {
        line-height: 18px;
        font-size: small;
      }
        
      #source-listing ol code 
      {
        padding:  0 .001em 0 0; /* Firefox doesn't render empty li's properly */
        font-size: medium;
        white-space: pre;
      }
   </style>
  </head>

  <body>

<div class="nav">
  <a href="cms.models.moderatormodels.html">cms.models.moderatormodels</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="cms.models.permissionmodels.html">cms.models.permissionmodels</a>
</div>

<div id="content-header">
  <h1>
    <span id="module-name">cms.models.pagemodel</span>:
    613 total statements,
    <span class="critical">0.0% covered</span>
  </h1>
  <p>Generated: Wed 2013-03-13 10:33 CET</p>
  <p>Source file: /media/Envs/Envs/filer-gallery/lib/python2.7/site-packages/cms/models/pagemodel.py</p>
  <p>
    Stats:
    <span class="executed">0 executed</span>,
    <span class="missed">569 missed</span>,
    <span class="excluded">44 excluded</span>,
    <span class="ignored">479 ignored</span> 
  </p> 
</div>

<div id="source-listing">
  <ol>
    <li class="ignored"><code># -*- coding: utf-8 -*-</code></li>
<li class="excluded"><code>from cms.exceptions import NoHomeFound</code></li>
<li class="excluded"><code>from cms.models.managers import PageManager, PagePermissionsPermissionManager</code></li>
<li class="excluded"><code>from cms.models.metaclasses import PageMetaClass</code></li>
<li class="excluded"><code>from cms.models.placeholdermodel import Placeholder</code></li>
<li class="excluded"><code>from cms.models.pluginmodel import CMSPlugin</code></li>
<li class="excluded"><code>from cms.publisher.errors import MpttPublisherCantPublish</code></li>
<li class="excluded"><code>from cms.utils import i18n, urlutils, page as page_utils</code></li>
<li class="excluded"><code>from cms.utils import timezone</code></li>
<li class="excluded"><code>from cms.utils.copy_plugins import copy_plugins_to</code></li>
<li class="excluded"><code>from cms.utils.helpers import reversion_register</code></li>
<li class="excluded"><code>from django.conf import settings</code></li>
<li class="excluded"><code>from django.contrib.sites.models import Site</code></li>
<li class="excluded"><code>from django.core.exceptions import ObjectDoesNotExist</code></li>
<li class="excluded"><code>from django.core.urlresolvers import reverse</code></li>
<li class="excluded"><code>from django.db import models</code></li>
<li class="excluded"><code>from django.db.models import Q</code></li>
<li class="excluded"><code>from django.shortcuts import get_object_or_404</code></li>
<li class="excluded"><code>from django.utils.translation import get_language, ugettext_lazy as _</code></li>
<li class="excluded"><code>from menus.menu_pool import menu_pool</code></li>
<li class="excluded"><code>from mptt.models import MPTTModel</code></li>
<li class="excluded"><code>from os.path import join</code></li>
<li class="excluded"><code>import copy</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class Page(MPTTModel):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    A simple hierarchical page model</code></li>
<li class="ignored"><code>    """</code></li>
<li class="missed"><code>    __metaclass__ = PageMetaClass</code></li>
<li class="missed"><code>    MODERATOR_CHANGED = 0</code></li>
<li class="missed"><code>    MODERATOR_NEED_APPROVEMENT = 1</code></li>
<li class="missed"><code>    MODERATOR_NEED_DELETE_APPROVEMENT = 2</code></li>
<li class="missed"><code>    MODERATOR_APPROVED = 10</code></li>
<li class="ignored"><code>    # special case - page was approved, but some of page parents are not approved yet</code></li>
<li class="missed"><code>    MODERATOR_APPROVED_WAITING_FOR_PARENTS = 11</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    moderator_state_choices = (</code></li>
<li class="ignored"><code>        (MODERATOR_CHANGED, _('changed')),</code></li>
<li class="ignored"><code>        (MODERATOR_NEED_APPROVEMENT, _('req. app.')),</code></li>
<li class="ignored"><code>        (MODERATOR_NEED_DELETE_APPROVEMENT, _('delete')),</code></li>
<li class="ignored"><code>        (MODERATOR_APPROVED, _('approved')),</code></li>
<li class="ignored"><code>        (MODERATOR_APPROVED_WAITING_FOR_PARENTS, _('app. par.')),</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    LIMIT_VISIBILITY_IN_MENU_CHOICES = (</code></li>
<li class="ignored"><code>        (1, _('for logged in users only')),</code></li>
<li class="ignored"><code>        (2, _('for anonymous users only')),</code></li>
<li class="ignored"><code>    )</code></li>
<li class="missed"><code>    PUBLISHER_STATE_DEFAULT = 0</code></li>
<li class="missed"><code>    PUBLISHER_STATE_DIRTY = 1</code></li>
<li class="missed"><code>    PUBLISHER_STATE_DELETE = 2</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    template_choices = [(x, _(y)) for x, y in settings.CMS_TEMPLATES]</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    created_by = models.CharField(_("created by"), max_length=70, editable=False)</code></li>
<li class="missed"><code>    changed_by = models.CharField(_("changed by"), max_length=70, editable=False)</code></li>
<li class="missed"><code>    parent = models.ForeignKey('self', null=True, blank=True, related_name='children', db_index=True)</code></li>
<li class="missed"><code>    creation_date = models.DateTimeField(auto_now_add=True)</code></li>
<li class="missed"><code>    changed_date = models.DateTimeField(auto_now=True)</code></li>
<li class="missed"><code>    publication_date = models.DateTimeField(_("publication date"), null=True, blank=True, help_text=_('When the page should go live. Status must be "Published" for page to go live.'), db_index=True)</code></li>
<li class="missed"><code>    publication_end_date = models.DateTimeField(_("publication end date"), null=True, blank=True, help_text=_('When to expire the page. Leave empty to never expire.'), db_index=True)</code></li>
<li class="missed"><code>    in_navigation = models.BooleanField(_("in navigation"), default=True, db_index=True)</code></li>
<li class="missed"><code>    soft_root = models.BooleanField(_("soft root"), db_index=True, default=False, help_text=_("All ancestors will not be displayed in the navigation"))</code></li>
<li class="missed"><code>    reverse_id = models.CharField(_("id"), max_length=40, db_index=True, blank=True, null=True, help_text=_("An unique identifier that is used with the page_url templatetag for linking to this page"))</code></li>
<li class="missed"><code>    navigation_extenders = models.CharField(_("attached menu"), max_length=80, db_index=True, blank=True, null=True)</code></li>
<li class="missed"><code>    published = models.BooleanField(_("is published"), blank=True)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    template = models.CharField(_("template"), max_length=100, choices=template_choices, help_text=_('The template used to render the content.'))</code></li>
<li class="missed"><code>    site = models.ForeignKey(Site, help_text=_('The site the page is accessible at.'), verbose_name=_("site"))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    moderator_state = models.SmallIntegerField(_('moderator state'), choices=moderator_state_choices, default=MODERATOR_NEED_APPROVEMENT, blank=True)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    level = models.PositiveIntegerField(db_index=True, editable=False)</code></li>
<li class="missed"><code>    lft = models.PositiveIntegerField(db_index=True, editable=False)</code></li>
<li class="missed"><code>    rght = models.PositiveIntegerField(db_index=True, editable=False)</code></li>
<li class="missed"><code>    tree_id = models.PositiveIntegerField(db_index=True, editable=False)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    login_required = models.BooleanField(_("login required"), default=False)</code></li>
<li class="missed"><code>    limit_visibility_in_menu = models.SmallIntegerField(_("menu visibility"), default=None, null=True, blank=True, choices=LIMIT_VISIBILITY_IN_MENU_CHOICES, db_index=True, help_text=_("limit when this page is visible in the menu"))</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # Placeholders (plugins)</code></li>
<li class="missed"><code>    placeholders = models.ManyToManyField(Placeholder, editable=False)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # Publisher fields</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    publisher_is_draft = models.BooleanField(default=1, editable=False, db_index=True)</code></li>
<li class="missed"><code>    publisher_public = models.OneToOneField('self', related_name='publisher_draft',  null=True, editable=False)</code></li>
<li class="missed"><code>    publisher_state = models.SmallIntegerField(default=0, editable=False, db_index=True)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # Managers</code></li>
<li class="missed"><code>    objects = PageManager()</code></li>
<li class="missed"><code>    permissions = PagePermissionsPermissionManager()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    class Meta:</code></li>
<li class="missed"><code>        permissions = (</code></li>
<li class="ignored"><code>            ('view_page', 'Can view page'),</code></li>
<li class="ignored"><code>        )</code></li>
<li class="missed"><code>        verbose_name = _('page')</code></li>
<li class="missed"><code>        verbose_name_plural = _('pages')</code></li>
<li class="missed"><code>        ordering = ('site', 'tree_id', 'lft')</code></li>
<li class="missed"><code>        app_label = 'cms'</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    class PublisherMeta:</code></li>
<li class="missed"><code>        exclude_fields_append = ['id', 'publisher_is_draft', 'publisher_public',</code></li>
<li class="ignored"><code>                                 'publisher_state', 'moderator_state',</code></li>
<li class="ignored"><code>                                 'placeholders', 'lft', 'rght', 'tree_id',</code></li>
<li class="ignored"><code>                                 'parent']</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>    def __unicode__(self):</code></li>
<li class="excluded"><code>        title = self.get_menu_title(fallback=True)</code></li>
<li class="excluded"><code>        if title is None:</code></li>
<li class="excluded"><code>            title = u""</code></li>
<li class="excluded"><code>        return u'%s' % (title,)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_absolute_url(self, language=None, fallback=True):</code></li>
<li class="missed"><code>        if self.is_home():</code></li>
<li class="missed"><code>            return reverse('pages-root')</code></li>
<li class="missed"><code>        if settings.CMS_FLAT_URLS:</code></li>
<li class="missed"><code>            path = self.get_slug(language, fallback)</code></li>
<li class="missed"><code>            return urlutils.urljoin(reverse('pages-root'), path)</code></li>
<li class="ignored"><code>        # else</code></li>
<li class="missed"><code>        path = self.get_path(language, fallback)</code></li>
<li class="missed"><code>        return urlutils.urljoin(reverse('pages-root'), path)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def move_page(self, target, position='first-child'):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Called from admin interface when page is moved. Should be used on</code></li>
<li class="ignored"><code>        all the places which are changing page position. Used like an interface</code></li>
<li class="ignored"><code>        to mptt, but after move is done page_moved signal is fired.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Note for issue #1166: url conflicts are handled by updated</code></li>
<li class="ignored"><code>        check_title_slugs, overwrite_url on the moved page don't need any check</code></li>
<li class="ignored"><code>        as it remains the same regardless of the page position in the tree</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        # make sure move_page does not break when using INHERIT template</code></li>
<li class="missed"><code>        if (position in ('left', 'right')</code></li>
<li class="ignored"><code>            and not target.parent</code></li>
<li class="ignored"><code>            and self.template == settings.CMS_TEMPLATE_INHERITANCE_MAGIC):</code></li>
<li class="missed"><code>            self.template = self.get_template()</code></li>
<li class="missed"><code>        self.move_to(target, position)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # fire signal</code></li>
<li class="excluded"><code>        from cms.models.moderatormodels import PageModeratorState</code></li>
<li class="missed"><code>        self.force_moderation_action = PageModeratorState.ACTION_MOVE</code></li>
<li class="excluded"><code>        import cms.signals as cms_signals</code></li>
<li class="missed"><code>        cms_signals.page_moved.send(sender=Page, instance=self)  # titles get saved before moderation</code></li>
<li class="missed"><code>        self.save(change_state=True)  # always save the page after move, because of publisher</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # check the slugs</code></li>
<li class="missed"><code>        page_utils.check_title_slugs(self)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def copy_page(self, target, site, position='first-child',</code></li>
<li class="ignored"><code>                  copy_permissions=True, copy_moderation=True,</code></li>
<li class="ignored"><code>                  public_copy=False):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        copy a page [ and all its descendants to a new location ]</code></li>
<li class="ignored"><code>        Doesn't checks for add page permissions anymore, this is done in PageAdmin.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Note: public_copy was added in order to enable the creation of a copy for creating the public page during</code></li>
<li class="ignored"><code>        the publish operation as it sets the publisher_is_draft=False.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Note for issue #1166: when copying pages there is no need to check for conflicting</code></li>
<li class="ignored"><code>        URLs as pages as copied unplublished.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="excluded"><code>        from cms.utils.moderator import update_moderation_message</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        page_copy = None</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if public_copy:</code></li>
<li class="ignored"><code>            # create a copy of the draft page - existing code loops through pages so added it to a list</code></li>
<li class="missed"><code>            pages = [copy.copy(self)]</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            pages = [self] + list(self.get_descendants().order_by('-rght'))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if not public_copy:</code></li>
<li class="missed"><code>            site_reverse_ids = Page.objects.filter(site=site, reverse_id__isnull=False).values_list('reverse_id', flat=True)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            if target:</code></li>
<li class="missed"><code>                target.old_pk = -1</code></li>
<li class="missed"><code>                if position == "first-child":</code></li>
<li class="missed"><code>                    tree = [target]</code></li>
<li class="missed"><code>                elif target.parent_id:</code></li>
<li class="missed"><code>                    tree = [target.parent]</code></li>
<li class="ignored"><code>                else:</code></li>
<li class="missed"><code>                    tree = []</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                tree = []</code></li>
<li class="missed"><code>            if tree:</code></li>
<li class="missed"><code>                tree[0].old_pk = tree[0].pk</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        first = True</code></li>
<li class="ignored"><code>        # loop over all affected pages (self is included in descendants)</code></li>
<li class="missed"><code>        for page in pages:</code></li>
<li class="missed"><code>            titles = list(page.title_set.all())</code></li>
<li class="ignored"><code>            # get all current placeholders (-&gt;plugins)</code></li>
<li class="missed"><code>            placeholders = list(page.placeholders.all())</code></li>
<li class="missed"><code>            origin_id = page.id</code></li>
<li class="ignored"><code>            # create a copy of this page by setting pk = None (=new instance)</code></li>
<li class="missed"><code>            page.old_pk = page.pk</code></li>
<li class="missed"><code>            page.pk = None</code></li>
<li class="missed"><code>            page.level = None</code></li>
<li class="missed"><code>            page.rght = None</code></li>
<li class="missed"><code>            page.lft = None</code></li>
<li class="missed"><code>            page.tree_id = None</code></li>
<li class="missed"><code>            page.published = False</code></li>
<li class="missed"><code>            page.moderator_state = Page.MODERATOR_CHANGED</code></li>
<li class="missed"><code>            page.publisher_public_id = None</code></li>
<li class="ignored"><code>            # only set reverse_id on standard copy</code></li>
<li class="missed"><code>            if not public_copy:</code></li>
<li class="missed"><code>                if page.reverse_id in site_reverse_ids:</code></li>
<li class="missed"><code>                    page.reverse_id = None</code></li>
<li class="missed"><code>                if first:</code></li>
<li class="missed"><code>                    first = False</code></li>
<li class="missed"><code>                    if tree:</code></li>
<li class="missed"><code>                        page.parent = tree[0]</code></li>
<li class="ignored"><code>                    else:</code></li>
<li class="missed"><code>                        page.parent = None</code></li>
<li class="missed"><code>                    page.insert_at(target, position)</code></li>
<li class="ignored"><code>                else:</code></li>
<li class="missed"><code>                    count = 1</code></li>
<li class="missed"><code>                    found = False</code></li>
<li class="missed"><code>                    for prnt in tree:</code></li>
<li class="missed"><code>                        if prnt.old_pk == page.parent_id:</code></li>
<li class="missed"><code>                            page.parent = prnt</code></li>
<li class="missed"><code>                            tree = tree[0:count]</code></li>
<li class="missed"><code>                            found = True</code></li>
<li class="missed"><code>                            break</code></li>
<li class="missed"><code>                        count += 1</code></li>
<li class="missed"><code>                    if not found:</code></li>
<li class="missed"><code>                        page.parent = None</code></li>
<li class="missed"><code>                tree.append(page)</code></li>
<li class="missed"><code>            page.site = site</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # override default page settings specific for public copy</code></li>
<li class="missed"><code>            if public_copy:</code></li>
<li class="missed"><code>                page.published = True</code></li>
<li class="missed"><code>                page.publisher_is_draft = False</code></li>
<li class="missed"><code>                page.moderator_state = Page.MODERATOR_APPROVED</code></li>
<li class="ignored"><code>                # we need to set relate this new public copy to its draft page (self)</code></li>
<li class="missed"><code>                page.publisher_public = self</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>                # code taken from Publisher publish() overridden here as we need to save the page</code></li>
<li class="ignored"><code>                # before we are able to use the page object for titles, placeholders etc.. below</code></li>
<li class="ignored"><code>                # the method has been modified to return the object after saving the instance variable</code></li>
<li class="missed"><code>                page = self._publisher_save_public(page)</code></li>
<li class="missed"><code>                page_copy = page    # create a copy used in the return</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="ignored"><code>                # only need to save the page if it isn't public since it is saved above otherwise</code></li>
<li class="missed"><code>                page.save()</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # copy moderation, permissions if necessary</code></li>
<li class="missed"><code>            if settings.CMS_PERMISSION and copy_permissions:</code></li>
<li class="excluded"><code>                from cms.models.permissionmodels import PagePermission</code></li>
<li class="missed"><code>                for permission in PagePermission.objects.filter(page__id=origin_id):</code></li>
<li class="missed"><code>                    permission.pk = None</code></li>
<li class="missed"><code>                    permission.page = page</code></li>
<li class="missed"><code>                    permission.save()</code></li>
<li class="missed"><code>            if settings.CMS_MODERATOR and copy_moderation:</code></li>
<li class="excluded"><code>                from cms.models.moderatormodels import PageModerator</code></li>
<li class="missed"><code>                for moderator in PageModerator.objects.filter(page__id=origin_id):</code></li>
<li class="missed"><code>                    moderator.pk = None</code></li>
<li class="missed"><code>                    moderator.page = page</code></li>
<li class="missed"><code>                    moderator.save()</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # update moderation message for standard copy</code></li>
<li class="missed"><code>            if not public_copy:</code></li>
<li class="missed"><code>                update_moderation_message(page, unicode(_('Page was copied.')))</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # copy titles of this page</code></li>
<li class="missed"><code>            for title in titles:</code></li>
<li class="missed"><code>                title.pk = None  # setting pk = None creates a new instance</code></li>
<li class="missed"><code>                title.publisher_public_id = None</code></li>
<li class="missed"><code>                title.published = False</code></li>
<li class="missed"><code>                title.page = page</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>                # create slug-copy for standard copy</code></li>
<li class="missed"><code>                if not public_copy:</code></li>
<li class="missed"><code>                    title.save() # We need to save the title in order to</code></li>
<li class="ignored"><code>                                 # retrieve it in get_available_slug</code></li>
<li class="missed"><code>                    title.slug = page_utils.get_available_slug(title)</code></li>
<li class="missed"><code>                title.save()</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # copy the placeholders (and plugins on those placeholders!)</code></li>
<li class="missed"><code>            for ph in placeholders:</code></li>
<li class="missed"><code>                plugins = list(ph.cmsplugin_set.all().order_by('tree_id', '-rght'))</code></li>
<li class="missed"><code>                try:</code></li>
<li class="missed"><code>                    ph = page.placeholders.get(slot=ph.slot)</code></li>
<li class="missed"><code>                except Placeholder.DoesNotExist:</code></li>
<li class="missed"><code>                    ph.pk = None  # make a new instance</code></li>
<li class="missed"><code>                    ph.save()</code></li>
<li class="missed"><code>                    page.placeholders.add(ph)</code></li>
<li class="ignored"><code>                    # update the page copy</code></li>
<li class="missed"><code>                    page_copy = page</code></li>
<li class="missed"><code>                if plugins:</code></li>
<li class="missed"><code>                    copy_plugins_to(plugins, ph)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # invalidate the menu for this site</code></li>
<li class="missed"><code>        menu_pool.clear(site_id=site.pk)</code></li>
<li class="missed"><code>        return page_copy   # return the page_copy or None</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def save(self, no_signals=False, change_state=True, commit=True,</code></li>
<li class="ignored"><code>             force_with_moderation=False, force_state=None, **kwargs):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Args:</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            commit: True if model should be really saved</code></li>
<li class="ignored"><code>            force_with_moderation: can be true when new object gets added under</code></li>
<li class="ignored"><code>                some existing page and this new page will require moderation;</code></li>
<li class="ignored"><code>                this is because of how this adding works - first save, then move</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # delete template cache</code></li>
<li class="missed"><code>        if hasattr(self, '_template_cache'):</code></li>
<li class="missed"><code>            delattr(self, '_template_cache')</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Published pages should always have a publication date</code></li>
<li class="missed"><code>        publish_directly, under_moderation = False, False</code></li>
<li class="missed"><code>        if self.publisher_is_draft:</code></li>
<li class="ignored"><code>            # publisher specific stuff, but only on draft model, this is here</code></li>
<li class="ignored"><code>            # because page initializes publish process</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            if settings.CMS_MODERATOR:</code></li>
<li class="missed"><code>                under_moderation = force_with_moderation or self.pk and bool(self.get_moderator_queryset().count())</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            created = not bool(self.pk)</code></li>
<li class="missed"><code>            if settings.CMS_MODERATOR:</code></li>
<li class="missed"><code>                if change_state:</code></li>
<li class="missed"><code>                    if created:</code></li>
<li class="ignored"><code>                        # new page....</code></li>
<li class="missed"><code>                        self.moderator_state = Page.MODERATOR_CHANGED</code></li>
<li class="missed"><code>                    elif not self.requires_approvement():</code></li>
<li class="ignored"><code>                        # always change state to need approvement when there is some change</code></li>
<li class="missed"><code>                        self.moderator_state = Page.MODERATOR_NEED_APPROVEMENT</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>                    if not under_moderation and (self.published or self.publisher_public):</code></li>
<li class="ignored"><code>                        # existing page without moderator - publish it directly if</code></li>
<li class="ignored"><code>                        # published is True</code></li>
<li class="missed"><code>                        publish_directly = True</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            elif change_state:</code></li>
<li class="missed"><code>                self.moderator_state = Page.MODERATOR_CHANGED</code></li>
<li class="ignored"><code>                #publish_directly = True - no publisher, no publishing!! - we just</code></li>
<li class="ignored"><code>                # use draft models in this case</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            if force_state is not None:</code></li>
<li class="missed"><code>                self.moderator_state = force_state</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # if the page is published we set the publish date if not set yet.</code></li>
<li class="missed"><code>        if self.publication_date is None and self.published:</code></li>
<li class="missed"><code>            self.publication_date = timezone.now()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if self.reverse_id == "":</code></li>
<li class="missed"><code>            self.reverse_id = None</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>        from cms.utils.permissions import _thread_locals</code></li>
<li class="missed"><code>        user = getattr(_thread_locals, "user", None)</code></li>
<li class="missed"><code>        if user:</code></li>
<li class="missed"><code>            self.changed_by = user.username</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            self.changed_by = "script"</code></li>
<li class="missed"><code>        if not self.pk:</code></li>
<li class="missed"><code>            self.created_by = self.changed_by</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if commit:</code></li>
<li class="missed"><code>            if no_signals:  # ugly hack because of mptt</code></li>
<li class="missed"><code>                self.save_base(cls=self.__class__, **kwargs)</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                super(Page, self).save(**kwargs)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        #if commit and (publish_directly or created and not under_moderation):</code></li>
<li class="missed"><code>        if self.publisher_is_draft:</code></li>
<li class="missed"><code>            if self.published:</code></li>
<li class="missed"><code>                if commit and publish_directly:</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>                    self.publish()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def save_base(self, *args, **kwargs):</code></li>
<li class="ignored"><code>        """Overriden save_base. If an instance is draft, and was changed, mark</code></li>
<li class="ignored"><code>        it as dirty.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Dirty flag is used for changed nodes identification when publish method</code></li>
<li class="ignored"><code>        takes place. After current changes are published, state is set back to</code></li>
<li class="ignored"><code>        PUBLISHER_STATE_DEFAULT (in publish method).</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        keep_state = getattr(self, '_publisher_keep_state', None)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if self.publisher_is_draft and not keep_state:</code></li>
<li class="missed"><code>            self.publisher_state = self.PUBLISHER_STATE_DIRTY</code></li>
<li class="missed"><code>        if keep_state:</code></li>
<li class="missed"><code>            delattr(self, '_publisher_keep_state')</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        ret = super(Page, self).save_base(*args, **kwargs)</code></li>
<li class="missed"><code>        return ret</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def publish(self):</code></li>
<li class="ignored"><code>        """Overrides Publisher method, because there may be some descendants, which</code></li>
<li class="ignored"><code>        are waiting for parent to publish, so publish them if possible.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        IMPORTANT: @See utils.moderator.approve_page for publishing permissions</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Returns: True if page was successfully published.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        # Publish can only be called on moderated and draft pages</code></li>
<li class="missed"><code>        if not self.publisher_is_draft:</code></li>
<li class="missed"><code>            return</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # publish, but only if all parents are published!!</code></li>
<li class="missed"><code>        published = None</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if not self.pk:</code></li>
<li class="missed"><code>            self.save()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if self._publisher_can_publish():</code></li>
<li class="ignored"><code>            ########################################################################</code></li>
<li class="ignored"><code>            # Assign the existing public page in old_public and mark it as</code></li>
<li class="ignored"><code>            # PUBLISHER_STATE_DELETE</code></li>
<li class="ignored"><code>            # the draft version was being deleted if I replaced the save()</code></li>
<li class="ignored"><code>            # below with a delete() directly so the deletion is handle at the end</code></li>
<li class="missed"><code>            old_public = self.get_public_object()</code></li>
<li class="missed"><code>            if old_public:</code></li>
<li class="missed"><code>                old_public.publisher_state = self.PUBLISHER_STATE_DELETE</code></li>
<li class="ignored"><code>                # store old public on self, pass around instead</code></li>
<li class="missed"><code>                self.old_public = old_public</code></li>
<li class="missed"><code>                old_public.publisher_public = None  # remove the reference to the publisher_draft version of the page so it does not get deleted</code></li>
<li class="missed"><code>                old_public.save()</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # we hook into the modified copy_page routing to do the heavy lifting of copying the draft page to a new public page</code></li>
<li class="missed"><code>            new_public = self.copy_page(target=None, site=self.site,</code></li>
<li class="ignored"><code>                                        copy_moderation=False, position=None,</code></li>
<li class="ignored"><code>                                        copy_permissions=False, public_copy=True)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # taken from Publisher - copy_page needs to call self._publisher_save_public(copy) for mptt insertion</code></li>
<li class="ignored"><code>            # insert_at() was maybe calling _create_tree_space() method, in this</code></li>
<li class="ignored"><code>            # case may tree_id change, so we must update tree_id from db first</code></li>
<li class="ignored"><code>            # before save</code></li>
<li class="missed"><code>            if getattr(self, 'tree_id', None):</code></li>
<li class="missed"><code>                me = self._default_manager.get(pk=self.pk)</code></li>
<li class="missed"><code>                self.tree_id = me.tree_id</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            self.published = True</code></li>
<li class="missed"><code>            self.publisher_public = new_public</code></li>
<li class="missed"><code>            self.moderator_state = Page.MODERATOR_APPROVED</code></li>
<li class="missed"><code>            self.publisher_state = self.PUBLISHER_STATE_DEFAULT</code></li>
<li class="missed"><code>            self._publisher_keep_state = True</code></li>
<li class="missed"><code>            published = True</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            self.moderator_state = Page.MODERATOR_APPROVED_WAITING_FOR_PARENTS</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        self.save(change_state=False)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if not published:</code></li>
<li class="ignored"><code>            # was not published, escape</code></li>
<li class="missed"><code>            return</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # clean moderation log</code></li>
<li class="missed"><code>        self.pagemoderatorstate_set.all().delete()</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # we delete the old public page - this only deletes the public page as we</code></li>
<li class="ignored"><code>        # have removed the old_public.publisher_public=None relationship to the draft page above</code></li>
<li class="missed"><code>        if old_public:</code></li>
<li class="ignored"><code>            # reparent public child pages before delete so they don't get purged as well</code></li>
<li class="missed"><code>            for child_page in old_public.children.order_by('lft'):</code></li>
<li class="missed"><code>                child_page.move_to(new_public, 'last-child')</code></li>
<li class="missed"><code>                child_page.save(change_state=False)</code></li>
<li class="ignored"><code>            # reload old_public to get correct tree attrs</code></li>
<li class="missed"><code>            old_public = Page.objects.get(pk=old_public.pk)</code></li>
<li class="missed"><code>            old_public.move_to(None, 'last-child')</code></li>
<li class="ignored"><code>            # moving the object out of the way berore deleting works, but why?</code></li>
<li class="ignored"><code>            # finally delete the old public page</code></li>
<li class="missed"><code>            old_public.delete()</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # page was published, check if there are some childs, which are waiting</code></li>
<li class="ignored"><code>        # for publishing (because of the parent)</code></li>
<li class="missed"><code>        publish_set = self.children.filter(moderator_state = Page.MODERATOR_APPROVED_WAITING_FOR_PARENTS)</code></li>
<li class="missed"><code>        for page in publish_set:</code></li>
<li class="ignored"><code>            # recursive call to all childrens....</code></li>
<li class="missed"><code>            page.moderator_state = Page.MODERATOR_APPROVED</code></li>
<li class="missed"><code>            page.save(change_state=False)</code></li>
<li class="missed"><code>            page.publish()</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # fire signal after publishing is done</code></li>
<li class="excluded"><code>        import cms.signals as cms_signals</code></li>
<li class="missed"><code>        cms_signals.post_publish.send(sender=Page, instance=self)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        return published</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def delete(self):</code></li>
<li class="ignored"><code>        """Mark public instance for deletion and delete draft.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        placeholders = self.placeholders.all()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        for ph in placeholders:</code></li>
<li class="missed"><code>            plugin = CMSPlugin.objects.filter(placeholder=ph)</code></li>
<li class="missed"><code>            plugin.delete()</code></li>
<li class="missed"><code>            ph.delete()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if self.publisher_public_id:</code></li>
<li class="ignored"><code>            # mark the public instance for deletion</code></li>
<li class="missed"><code>            self.publisher_public.publisher_state = self.PUBLISHER_STATE_DELETE</code></li>
<li class="missed"><code>            self.publisher_public.save()</code></li>
<li class="missed"><code>        super(Page, self).delete()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def delete_with_public(self):</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        placeholders = list(self.placeholders.all())</code></li>
<li class="missed"><code>        if self.publisher_public_id:</code></li>
<li class="missed"><code>            placeholders = placeholders + list(self.publisher_public.placeholders.all())</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        for ph in placeholders:</code></li>
<li class="missed"><code>            plugin = CMSPlugin.objects.filter(placeholder=ph)</code></li>
<li class="missed"><code>            plugin.delete()</code></li>
<li class="missed"><code>            ph.delete()</code></li>
<li class="missed"><code>        if self.publisher_public_id:</code></li>
<li class="missed"><code>            self.publisher_public.delete()</code></li>
<li class="missed"><code>        super(Page, self).delete()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_draft_object(self):</code></li>
<li class="missed"><code>        return self</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_public_object(self):</code></li>
<li class="missed"><code>        return self.publisher_public</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_languages(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        get the list of all existing languages for this page</code></li>
<li class="ignored"><code>        """</code></li>
<li class="excluded"><code>        from cms.models.titlemodels import Title</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if not hasattr(self, "all_languages"):</code></li>
<li class="missed"><code>            self.all_languages = Title.objects.filter(page=self).values_list("language", flat=True).distinct()</code></li>
<li class="missed"><code>            self.all_languages = list(self.all_languages)</code></li>
<li class="missed"><code>            self.all_languages.sort()</code></li>
<li class="missed"><code>        return self.all_languages</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_cached_ancestors(self, ascending=True):</code></li>
<li class="missed"><code>        if ascending:</code></li>
<li class="missed"><code>            if not hasattr(self, "ancestors_ascending"):</code></li>
<li class="missed"><code>                self.ancestors_ascending = list(self.get_ancestors(ascending))</code></li>
<li class="missed"><code>            return self.ancestors_ascending</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            if not hasattr(self, "ancestors_descending"):</code></li>
<li class="missed"><code>                self.ancestors_descending = list(self.get_ancestors(ascending))</code></li>
<li class="missed"><code>            return self.ancestors_descending</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_title_obj(self, language=None, fallback=True, version_id=None, force_reload=False):</code></li>
<li class="ignored"><code>        """Helper function for accessing wanted / current title.</code></li>
<li class="ignored"><code>        If wanted title doesn't exists, EmptyTitle instance will be returned.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        language = self._get_title_cache(language, fallback, version_id, force_reload)</code></li>
<li class="missed"><code>        if language in self.title_cache:</code></li>
<li class="missed"><code>            return self.title_cache[language]</code></li>
<li class="excluded"><code>        from cms.models.titlemodels import EmptyTitle</code></li>
<li class="missed"><code>        return EmptyTitle()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_title_obj_attribute(self, attrname, language=None, fallback=True, version_id=None, force_reload=False):</code></li>
<li class="ignored"><code>        """Helper function for getting attribute or None from wanted/current title.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        try:</code></li>
<li class="missed"><code>            attribute = getattr(self.get_title_obj(</code></li>
<li class="ignored"><code>                    language, fallback, version_id, force_reload), attrname)</code></li>
<li class="missed"><code>            return attribute</code></li>
<li class="missed"><code>        except AttributeError:</code></li>
<li class="missed"><code>            return None</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_path(self, language=None, fallback=True, version_id=None, force_reload=False):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        get the path of the page depending on the given language</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.get_title_obj_attribute("path", language, fallback, version_id, force_reload)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_slug(self, language=None, fallback=True, version_id=None, force_reload=False):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        get the slug of the page depending on the given language</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.get_title_obj_attribute("slug", language, fallback, version_id, force_reload)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_title(self, language=None, fallback=True, version_id=None, force_reload=False):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        get the title of the page depending on the given language</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.get_title_obj_attribute("title", language, fallback, version_id, force_reload)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_menu_title(self, language=None, fallback=True, version_id=None, force_reload=False):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        get the menu title of the page depending on the given language</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        menu_title = self.get_title_obj_attribute("menu_title", language, fallback, version_id, force_reload)</code></li>
<li class="missed"><code>        if not menu_title:</code></li>
<li class="missed"><code>            return self.get_title(language, True, version_id, force_reload)</code></li>
<li class="missed"><code>        return menu_title</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_page_title(self, language=None, fallback=True, version_id=None, force_reload=False):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        get the page title of the page depending on the given language</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        page_title = self.get_title_obj_attribute("page_title", language, fallback, version_id, force_reload)</code></li>
<li class="missed"><code>        if not page_title:</code></li>
<li class="missed"><code>            return self.get_title(language, True, version_id, force_reload)</code></li>
<li class="missed"><code>        return page_title</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_meta_description(self, language=None, fallback=True, version_id=None, force_reload=False):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        get content for the description meta tag for the page depending on the given language</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.get_title_obj_attribute("meta_description", language, fallback, version_id, force_reload)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_meta_keywords(self, language=None, fallback=True, version_id=None, force_reload=False):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        get content for the keywords meta tag for the page depending on the given language</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.get_title_obj_attribute("meta_keywords", language, fallback, version_id, force_reload)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_application_urls(self, language=None, fallback=True, version_id=None, force_reload=False):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        get application urls conf for application hook</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.get_title_obj_attribute("application_urls", language, fallback, version_id, force_reload)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_redirect(self, language=None, fallback=True, version_id=None, force_reload=False):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        get redirect</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.get_title_obj_attribute("redirect", language, fallback, version_id, force_reload)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _get_title_cache(self, language, fallback, version_id, force_reload):</code></li>
<li class="missed"><code>        if not language:</code></li>
<li class="missed"><code>            language = get_language()</code></li>
<li class="missed"><code>        load = False</code></li>
<li class="missed"><code>        if not hasattr(self, "title_cache") or force_reload:</code></li>
<li class="missed"><code>            load = True</code></li>
<li class="missed"><code>            self.title_cache = {}</code></li>
<li class="missed"><code>        elif not language in self.title_cache:</code></li>
<li class="missed"><code>            if fallback:</code></li>
<li class="missed"><code>                fallback_langs = i18n.get_fallback_languages(language)</code></li>
<li class="missed"><code>                for lang in fallback_langs:</code></li>
<li class="missed"><code>                    if lang in self.title_cache:</code></li>
<li class="missed"><code>                        return lang</code></li>
<li class="missed"><code>            load = True</code></li>
<li class="missed"><code>        if load:</code></li>
<li class="excluded"><code>            from cms.models.titlemodels import Title</code></li>
<li class="missed"><code>            if version_id:</code></li>
<li class="excluded"><code>                from reversion.models import Version</code></li>
<li class="missed"><code>                version = get_object_or_404(Version, pk=version_id)</code></li>
<li class="missed"><code>                revs = [related_version.object_version for related_version in version.revision.version_set.all()]</code></li>
<li class="missed"><code>                for rev in revs:</code></li>
<li class="missed"><code>                    obj = rev.object</code></li>
<li class="missed"><code>                    if obj.__class__ == Title:</code></li>
<li class="missed"><code>                        self.title_cache[obj.language] = obj</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                title = Title.objects.get_title(self, language, language_fallback=fallback)</code></li>
<li class="missed"><code>                if title:</code></li>
<li class="missed"><code>                    self.title_cache[title.language] = title</code></li>
<li class="missed"><code>                language = title.language</code></li>
<li class="missed"><code>        return language</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_template(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        get the template of this page if defined or if closer parent if</code></li>
<li class="ignored"><code>        defined or DEFAULT_PAGE_TEMPLATE otherwise</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if hasattr(self, '_template_cache'):</code></li>
<li class="missed"><code>            return self._template_cache</code></li>
<li class="missed"><code>        template = None</code></li>
<li class="missed"><code>        if self.template:</code></li>
<li class="missed"><code>            if self.template != settings.CMS_TEMPLATE_INHERITANCE_MAGIC:</code></li>
<li class="missed"><code>                template = self.template</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                try:</code></li>
<li class="missed"><code>                    template = self.get_ancestors(ascending=True).exclude(</code></li>
<li class="ignored"><code>                        template=settings.CMS_TEMPLATE_INHERITANCE_MAGIC).values_list('template', flat=True)[0]</code></li>
<li class="missed"><code>                except IndexError:</code></li>
<li class="missed"><code>                    pass</code></li>
<li class="missed"><code>        if not template:</code></li>
<li class="missed"><code>            template = settings.CMS_TEMPLATES[0][0]</code></li>
<li class="missed"><code>        self._template_cache = template</code></li>
<li class="missed"><code>        return template</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_template_name(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        get the textual name (2nd parameter in settings.CMS_TEMPLATES)</code></li>
<li class="ignored"><code>        of the template of this page or of the nearest</code></li>
<li class="ignored"><code>        ancestor. failing to find that, return the name of the default template.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        template = self.get_template()</code></li>
<li class="missed"><code>        for t in settings.CMS_TEMPLATES:</code></li>
<li class="missed"><code>            if t[0] == template:</code></li>
<li class="missed"><code>                return t[1]</code></li>
<li class="missed"><code>        return _("default")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def has_view_permission(self, request):</code></li>
<li class="excluded"><code>        from cms.models.permissionmodels import PagePermission, GlobalPagePermission</code></li>
<li class="excluded"><code>        from cms.utils.plugins import current_site</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if not self.publisher_is_draft and self.publisher_public:</code></li>
<li class="missed"><code>            return self.publisher_public.has_view_permission(request)</code></li>
<li class="ignored"><code>        # does any restriction exist?</code></li>
<li class="ignored"><code>        # inherited and direct</code></li>
<li class="missed"><code>        is_restricted = PagePermission.objects.for_page(page=self).filter(can_view=True).exists()</code></li>
<li class="missed"><code>        if request.user.is_authenticated():</code></li>
<li class="missed"><code>            site = current_site(request)</code></li>
<li class="missed"><code>            global_perms_q = Q(can_view=True) &amp; Q(</code></li>
<li class="ignored"><code>                Q(sites__in=[site]) | Q(sites__isnull=True)</code></li>
<li class="ignored"><code>            )</code></li>
<li class="missed"><code>            global_view_perms = GlobalPagePermission.objects.with_user(</code></li>
<li class="ignored"><code>                request.user).filter(global_perms_q).exists()</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # a global permission was given to the request's user</code></li>
<li class="missed"><code>            if global_view_perms:</code></li>
<li class="missed"><code>                return True</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            elif not is_restricted:</code></li>
<li class="missed"><code>                if ((settings.CMS_PUBLIC_FOR == 'all') or</code></li>
<li class="ignored"><code>                    (settings.CMS_PUBLIC_FOR == 'staff' and</code></li>
<li class="ignored"><code>                     request.user.is_staff)):</code></li>
<li class="missed"><code>                    return True</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # a restricted page and an authenticated user</code></li>
<li class="missed"><code>            elif is_restricted:</code></li>
<li class="missed"><code>                opts = self._meta</code></li>
<li class="missed"><code>                codename = '%s.view_%s' % (opts.app_label, opts.object_name.lower())</code></li>
<li class="missed"><code>                user_perm = request.user.has_perm(codename)</code></li>
<li class="missed"><code>                generic_perm = self.has_generic_permission(request, "view")</code></li>
<li class="missed"><code>                return (user_perm or generic_perm)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        else:</code></li>
<li class="ignored"><code>            #anonymous user</code></li>
<li class="missed"><code>            if is_restricted or not settings.CMS_PUBLIC_FOR == 'all':</code></li>
<li class="ignored"><code>                # anyonymous user, page has restriction and global access is permitted</code></li>
<li class="missed"><code>                return False</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="ignored"><code>                # anonymous user, no restriction saved in database</code></li>
<li class="missed"><code>                return True</code></li>
<li class="ignored"><code>        # Authenticated user</code></li>
<li class="ignored"><code>        # Django wide auth perms "can_view" or cms auth perms "can_view"</code></li>
<li class="missed"><code>        opts = self._meta</code></li>
<li class="missed"><code>        codename = '%s.view_%s' % (opts.app_label, opts.object_name.lower())</code></li>
<li class="missed"><code>        return (request.user.has_perm(codename) or</code></li>
<li class="ignored"><code>                self.has_generic_permission(request, "view"))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def has_change_permission(self, request):</code></li>
<li class="missed"><code>        opts = self._meta</code></li>
<li class="missed"><code>        if request.user.is_superuser:</code></li>
<li class="missed"><code>            return True</code></li>
<li class="missed"><code>        return request.user.has_perm(opts.app_label + '.' + opts.get_change_permission()) and \</code></li>
<li class="ignored"><code>            self.has_generic_permission(request, "change")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def has_delete_permission(self, request):</code></li>
<li class="missed"><code>        opts = self._meta</code></li>
<li class="missed"><code>        if request.user.is_superuser:</code></li>
<li class="missed"><code>            return True</code></li>
<li class="missed"><code>        return request.user.has_perm(opts.app_label + '.' + opts.get_delete_permission()) and \</code></li>
<li class="ignored"><code>            self.has_generic_permission(request, "delete")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def has_publish_permission(self, request):</code></li>
<li class="missed"><code>        return self.has_generic_permission(request, "publish")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def has_advanced_settings_permission(self, request):</code></li>
<li class="missed"><code>        return self.has_generic_permission(request, "advanced_settings")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def has_change_permissions_permission(self, request):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Has user ability to change permissions for current page?</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.has_generic_permission(request, "change_permissions")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def has_add_permission(self, request):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Has user ability to add page under current page?</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.has_generic_permission(request, "add")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def has_move_page_permission(self, request):</code></li>
<li class="ignored"><code>        """Has user ability to move current page?</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.has_generic_permission(request, "move_page")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def has_moderate_permission(self, request):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Has user ability to moderate current page? If moderation isn't</code></li>
<li class="ignored"><code>        installed, nobody can moderate.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if not settings.CMS_MODERATOR:</code></li>
<li class="missed"><code>            return False</code></li>
<li class="missed"><code>        return self.has_generic_permission(request, "moderate")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def has_generic_permission(self, request, perm_type):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Return true if the current user has permission on the page.</code></li>
<li class="ignored"><code>        Return the string 'All' if the user has all rights.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        att_name = "permission_%s_cache" % perm_type</code></li>
<li class="missed"><code>        if not hasattr(self, "permission_user_cache") or not hasattr(self, att_name) \</code></li>
<li class="ignored"><code>                or request.user.pk != self.permission_user_cache.pk:</code></li>
<li class="excluded"><code>            from cms.utils.permissions import has_generic_permission</code></li>
<li class="missed"><code>            self.permission_user_cache = request.user</code></li>
<li class="missed"><code>            setattr(self, att_name, has_generic_permission(</code></li>
<li class="ignored"><code>                    self.id, request.user, perm_type, self.site_id))</code></li>
<li class="missed"><code>            if getattr(self, att_name):</code></li>
<li class="missed"><code>                self.permission_edit_cache = True</code></li>
<li class="missed"><code>        return getattr(self, att_name)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def is_home(self):</code></li>
<li class="missed"><code>        if self.parent_id:</code></li>
<li class="missed"><code>            return False</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            try:</code></li>
<li class="missed"><code>                return self.home_pk_cache == self.pk</code></li>
<li class="missed"><code>            except NoHomeFound:</code></li>
<li class="missed"><code>                pass</code></li>
<li class="missed"><code>        return False</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_home_pk_cache(self):</code></li>
<li class="missed"><code>        attr = "%s_home_pk_cache_%s" % (self.publisher_is_draft and "draft" or "public", self.site_id)</code></li>
<li class="missed"><code>        if not hasattr(self, attr):</code></li>
<li class="missed"><code>            setattr(self, attr, self.get_object_queryset().get_home(self.site).pk)</code></li>
<li class="missed"><code>        return getattr(self, attr)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def set_home_pk_cache(self, value):</code></li>
<li class="missed"><code>        attr = "%s_home_pk_cache_%s" % (self.publisher_is_draft and "draft" or "public", self.site_id)</code></li>
<li class="missed"><code>        setattr(self, attr, value)</code></li>
<li class="missed"><code>    home_pk_cache = property(get_home_pk_cache, set_home_pk_cache)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_media_path(self, filename):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Returns path (relative to MEDIA_ROOT/MEDIA_URL) to directory for storing page-scope files.</code></li>
<li class="ignored"><code>        This allows multiple pages to contain files with identical names without namespace issues.</code></li>
<li class="ignored"><code>        Plugins such as Picture can use this method to initialise the 'upload_to' parameter for</code></li>
<li class="ignored"><code>        File-based fields. For example:</code></li>
<li class="ignored"><code>            image = models.ImageField(_("image"), upload_to=CMSPlugin.get_media_path)</code></li>
<li class="ignored"><code>        where CMSPlugin.get_media_path calls self.page.get_media_path</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        This location can be customised using the CMS_PAGE_MEDIA_PATH setting</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return join(settings.CMS_PAGE_MEDIA_PATH, "%d" % self.id, filename)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def last_page_states(self):</code></li>
<li class="ignored"><code>        """Returns last five page states, if they exist, optimized, calls sql</code></li>
<li class="ignored"><code>        query only if some states available</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        # TODO: optimize SQL... 1 query per page</code></li>
<li class="missed"><code>        if settings.CMS_MODERATOR:</code></li>
<li class="missed"><code>            has_moderator_state = getattr(self, '_has_moderator_state_cache', None)</code></li>
<li class="missed"><code>            if has_moderator_state == False:</code></li>
<li class="missed"><code>                return self.pagemoderatorstate_set.none()</code></li>
<li class="missed"><code>            return self.pagemoderatorstate_set.all().order_by('created',)[:5]</code></li>
<li class="missed"><code>        return self.pagemoderatorstate_set.none()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_moderator_queryset(self):</code></li>
<li class="ignored"><code>        """Returns ordered set of all PageModerator instances, which should</code></li>
<li class="ignored"><code>        moderate this page</code></li>
<li class="ignored"><code>        """</code></li>
<li class="excluded"><code>        from cms.models.moderatormodels import PageModerator</code></li>
<li class="missed"><code>        if not settings.CMS_MODERATOR or not self.tree_id:</code></li>
<li class="missed"><code>            return PageModerator.objects.get_empty_query_set()</code></li>
<li class="missed"><code>        query = Q(page__tree_id=self.tree_id, page__level__lt=self.level, moderate_descendants=True) | \</code></li>
<li class="ignored"><code>            Q(page__tree_id=self.tree_id, page__level=self.level - 1, moderate_children=True) | \</code></li>
<li class="ignored"><code>            Q(page__pk=self.pk, moderate_page=True)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        return PageModerator.objects.distinct().filter(query).order_by('page__level')</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def is_under_moderation(self):</code></li>
<li class="missed"><code>        return bool(self.get_moderator_queryset().count())</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def is_approved(self):</code></li>
<li class="ignored"><code>        """Returns true, if page is approved and published, or approved, but</code></li>
<li class="ignored"><code>        parents are missing..</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.moderator_state in (Page.MODERATOR_APPROVED, Page.MODERATOR_APPROVED_WAITING_FOR_PARENTS)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def is_public_published(self):</code></li>
<li class="ignored"><code>        """Returns true if public model is published.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if hasattr(self, 'public_published_cache'):</code></li>
<li class="ignored"><code>            # if it was cached in change list, return cached value</code></li>
<li class="missed"><code>            return self.public_published_cache</code></li>
<li class="ignored"><code>        # othervise make db lookup</code></li>
<li class="missed"><code>        if self.publisher_public_id:</code></li>
<li class="missed"><code>            return self.publisher_public.published</code></li>
<li class="ignored"><code>        #return is_public_published(self)</code></li>
<li class="missed"><code>        return False</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def reload(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Reload a page from the database</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return Page.objects.get(pk=self.pk)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def requires_approvement(self):</code></li>
<li class="missed"><code>        return self.moderator_state in (Page.MODERATOR_NEED_APPROVEMENT, Page.MODERATOR_NEED_DELETE_APPROVEMENT)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_moderation_value(self, user):</code></li>
<li class="ignored"><code>        """Returns page moderation value for given user, moderation value is</code></li>
<li class="ignored"><code>        sum of moderations.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        moderation_value = getattr(self, '_moderation_value_cache', None)</code></li>
<li class="missed"><code>        if moderation_value is not None and self._moderation_value_cache_for_user_id == user.pk:</code></li>
<li class="missed"><code>            return moderation_value</code></li>
<li class="missed"><code>        try:</code></li>
<li class="missed"><code>            page_moderator = self.pagemoderator_set.get(user=user)</code></li>
<li class="missed"><code>        except ObjectDoesNotExist:</code></li>
<li class="missed"><code>            return 0</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        moderation_value = page_moderator.get_decimal()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        self._moderation_value_cache = moderation_value</code></li>
<li class="missed"><code>        self._moderation_value_cache_for_user_id = user</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        return moderation_value</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_object_queryset(self):</code></li>
<li class="ignored"><code>        """Returns smart queryset depending on object type - draft / public</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        qs = self.__class__.objects</code></li>
<li class="missed"><code>        return self.publisher_is_draft and qs.drafts() or qs.public()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _publisher_can_publish(self):</code></li>
<li class="ignored"><code>        """Is parent of this object already published?</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if self.parent_id:</code></li>
<li class="missed"><code>            try:</code></li>
<li class="missed"><code>                return bool(self.parent.publisher_public_id)</code></li>
<li class="missed"><code>            except AttributeError:</code></li>
<li class="missed"><code>                raise MpttPublisherCantPublish</code></li>
<li class="missed"><code>        return True</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _publisher_get_public_copy(self):</code></li>
<li class="ignored"><code>        """This is here because of the relation between CMSPlugins - model</code></li>
<li class="ignored"><code>        inheritance.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        eg. Text.objects.get(pk=1).publisher_public returns instance of CMSPlugin</code></li>
<li class="ignored"><code>        instead of instance of Text, thats why this method must be overriden in</code></li>
<li class="ignored"><code>        CMSPlugin.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.publisher_public</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_next_filtered_sibling(self, **filters):</code></li>
<li class="ignored"><code>        """Very simillar to original mptt method, but adds support for filters.</code></li>
<li class="ignored"><code>        Returns this model instance's next sibling in the tree, or</code></li>
<li class="ignored"><code>        ``None`` if it doesn't have a next sibling.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        opts = self._mptt_meta</code></li>
<li class="missed"><code>        if self.is_root_node():</code></li>
<li class="missed"><code>            filters.update({</code></li>
<li class="ignored"><code>                '%s__isnull' % opts.parent_attr: True,</code></li>
<li class="ignored"><code>                '%s__gt' % opts.tree_id_attr: getattr(self, opts.tree_id_attr),</code></li>
<li class="ignored"><code>            })</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            filters.update({</code></li>
<li class="ignored"><code>                 opts.parent_attr: getattr(self, '%s_id' % opts.parent_attr),</code></li>
<li class="ignored"><code>                '%s__gt' % opts.left_attr: getattr(self, opts.right_attr),</code></li>
<li class="ignored"><code>            })</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # publisher stuff</code></li>
<li class="missed"><code>        filters.update({</code></li>
<li class="ignored"><code>            'publisher_is_draft': self.publisher_is_draft</code></li>
<li class="ignored"><code>        })</code></li>
<li class="ignored"><code>        # multisite</code></li>
<li class="missed"><code>        filters.update({</code></li>
<li class="ignored"><code>            'site__id': self.site_id</code></li>
<li class="ignored"><code>        })</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        sibling = None</code></li>
<li class="missed"><code>        try:</code></li>
<li class="missed"><code>            sibling = self._tree_manager.filter(**filters)[0]</code></li>
<li class="missed"><code>        except IndexError:</code></li>
<li class="missed"><code>            pass</code></li>
<li class="missed"><code>        return sibling</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_previous_filtered_sibling(self, **filters):</code></li>
<li class="ignored"><code>        """Very simillar to original mptt method, but adds support for filters.</code></li>
<li class="ignored"><code>        Returns this model instance's previous sibling in the tree, or</code></li>
<li class="ignored"><code>        ``None`` if it doesn't have a previous sibling.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        opts = self._mptt_meta</code></li>
<li class="missed"><code>        if self.is_root_node():</code></li>
<li class="missed"><code>            filters.update({</code></li>
<li class="ignored"><code>                '%s__isnull' % opts.parent_attr: True,</code></li>
<li class="ignored"><code>                '%s__lt' % opts.tree_id_attr: getattr(self, opts.tree_id_attr),</code></li>
<li class="ignored"><code>            })</code></li>
<li class="missed"><code>            order_by = '-%s' % opts.tree_id_attr</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            filters.update({</code></li>
<li class="ignored"><code>                 opts.parent_attr: getattr(self, '%s_id' % opts.parent_attr),</code></li>
<li class="ignored"><code>                '%s__lt' % opts.right_attr: getattr(self, opts.left_attr),</code></li>
<li class="ignored"><code>            })</code></li>
<li class="missed"><code>            order_by = '-%s' % opts.right_attr</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # publisher stuff</code></li>
<li class="missed"><code>        filters.update({</code></li>
<li class="ignored"><code>            'publisher_is_draft': self.publisher_is_draft</code></li>
<li class="ignored"><code>        })</code></li>
<li class="ignored"><code>        # multisite</code></li>
<li class="missed"><code>        filters.update({</code></li>
<li class="ignored"><code>            'site__id': self.site_id</code></li>
<li class="ignored"><code>        })</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        sibling = None</code></li>
<li class="missed"><code>        try:</code></li>
<li class="missed"><code>            sibling = self._tree_manager.filter(**filters).order_by(order_by)[0]</code></li>
<li class="missed"><code>        except IndexError:</code></li>
<li class="missed"><code>            pass</code></li>
<li class="missed"><code>        return sibling</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _publisher_save_public(self, obj):</code></li>
<li class="ignored"><code>        """Mptt specific stuff before the object can be saved, overrides original</code></li>
<li class="ignored"><code>        publisher method.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Args:</code></li>
<li class="ignored"><code>            obj - public variant of `self` to be saved.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        prev_sibling = self.get_previous_filtered_sibling(publisher_public__isnull=False)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if not self.publisher_public_id:</code></li>
<li class="ignored"><code>            # is there anybody on left side?</code></li>
<li class="missed"><code>            if prev_sibling:</code></li>
<li class="missed"><code>                obj.insert_at(prev_sibling.publisher_public, position='right', save=False)</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="ignored"><code>                # it is a first time published object, perform insert_at:</code></li>
<li class="missed"><code>                parent, public_parent = self.parent, None</code></li>
<li class="missed"><code>                if parent:</code></li>
<li class="missed"><code>                    public_parent = parent.publisher_public</code></li>
<li class="missed"><code>                if public_parent:</code></li>
<li class="missed"><code>                    obj.insert_at(public_parent, save=False)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="ignored"><code>            # check if object was moved / structural tree change</code></li>
<li class="missed"><code>            prev_public_sibling = self.old_public.get_previous_filtered_sibling()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            if not self.level == self.old_public.level or \</code></li>
<li class="ignored"><code>                not (self.level &gt; 0 and self.parent.publisher_public == self.old_public.parent) or \</code></li>
<li class="ignored"><code>                not prev_sibling == prev_public_sibling == None or \</code></li>
<li class="ignored"><code>                (prev_sibling and prev_sibling.publisher_public_id == prev_public_sibling.id):</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>                if prev_sibling:</code></li>
<li class="missed"><code>                    obj.insert_at(prev_sibling.publisher_public, position="right")</code></li>
<li class="missed"><code>                elif self.parent:</code></li>
<li class="ignored"><code>                    # move as a first child to parent</code></li>
<li class="missed"><code>                    target = self.parent.publisher_public</code></li>
<li class="missed"><code>                    obj.insert_at(target, position='first-child')</code></li>
<li class="ignored"><code>                else:</code></li>
<li class="ignored"><code>                    # it is a move from the right side or just save</code></li>
<li class="missed"><code>                    next_sibling = self.get_next_filtered_sibling()</code></li>
<li class="missed"><code>                    if next_sibling and next_sibling.publisher_public_id:</code></li>
<li class="missed"><code>                        obj.insert_at(next_sibling.publisher_public, position="left")</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="ignored"><code>                # insert at last public position</code></li>
<li class="missed"><code>                prev_sibling = self.old_public.get_previous_filtered_sibling()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>                if prev_sibling:</code></li>
<li class="missed"><code>                    obj.insert_at(prev_sibling, position="right")</code></li>
<li class="missed"><code>                elif self.old_public.parent:</code></li>
<li class="ignored"><code>                    # move as a first child to parent</code></li>
<li class="missed"><code>                    target = self.old_public.parent</code></li>
<li class="missed"><code>                    obj.insert_at(target, position='first-child')</code></li>
<li class="ignored"><code>                else:</code></li>
<li class="ignored"><code>                    # it is a move from the right side or just save</code></li>
<li class="missed"><code>                    next_sibling = self.old_public.get_next_filtered_sibling()</code></li>
<li class="missed"><code>                    if next_sibling and next_sibling.publisher_public_id:</code></li>
<li class="missed"><code>                        obj.insert_at(next_sibling, position="left")</code></li>
<li class="ignored"><code>        # or none structural change, just save</code></li>
<li class="missed"><code>        obj.save()</code></li>
<li class="missed"><code>        return obj</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def rescan_placeholders(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Rescan and if necessary create placeholders in the current template.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="excluded"><code>        # inline import to prevent circular imports</code></li>
<li class="excluded"><code>        from cms.utils.plugins import get_placeholders</code></li>
<li class="missed"><code>        placeholders = get_placeholders(self.get_template())</code></li>
<li class="missed"><code>        found = {}</code></li>
<li class="missed"><code>        for placeholder in self.placeholders.all():</code></li>
<li class="missed"><code>            if placeholder.slot in placeholders:</code></li>
<li class="missed"><code>                found[placeholder.slot] = placeholder</code></li>
<li class="missed"><code>        for placeholder_name in placeholders:</code></li>
<li class="missed"><code>            if not placeholder_name in found:</code></li>
<li class="missed"><code>                placeholder = Placeholder.objects.create(slot=placeholder_name)</code></li>
<li class="missed"><code>                self.placeholders.add(placeholder)</code></li>
<li class="missed"><code>                found[placeholder_name] = placeholder</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def _reversion():</code></li>
<li class="missed"><code>    exclude_fields = ['publisher_is_draft', 'publisher_public', 'publisher_state']</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    reversion_register(</code></li>
<li class="ignored"><code>        Page,</code></li>
<li class="ignored"><code>        follow=["title_set", "placeholders", "pagepermission_set"],</code></li>
<li class="ignored"><code>        exclude_fields=exclude_fields</code></li>
<li class="ignored"><code>    )</code></li>
<li class="missed"><code>_reversion()</code></li>
  </ol>
</div>

<div class="nav">
  <a href="cms.models.moderatormodels.html">cms.models.moderatormodels</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="cms.models.permissionmodels.html">cms.models.permissionmodels</a>
</div>

  </body>
</html>

