<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <title>Test coverage report: mptt.managers</title>
    <style type="text/css" media="screen">
      a
      {
        color: #3d707a;
      }
      
      a:hover, a:active
      {
        color: #bf7d18;
      }
    
      body 
      {
        font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        font-size: 13px;
      }
      
      .nav 
      {
        font-size: 12px;
        margin-left: 50px;
      }

      .ignored
      {
        color: #707070;
      }

      .executed 
      {
        color: #3d9900;
      }

      .missed 
      {
        color: red;
        font-weight: bold;
      }

      .excluded 
      {
        color: #6090f0;
        font-weight: lighter;
      }
    
      #content-header 
      {
        font-size: 12px;
        padding: 18px 0 18px 50px;
      }

      #content-header h1 
      {
        font-size: 16px;
        margin: 10px 0 0 0;
        color: #909090;
      }
      
      #module-name
      {
        color: #583707;
      }
    
      #content-header p
      {
        font-size: 13px;
        margin: 0;
        color: #909090;
      }

      #content-header .normal 
      {
        color: #609030;
      }

      #content-header .warning 
      {
        color: #d0a000;
      }

      #content-header .critical 
      {
        color: red;
      }
      
      #source-listing 
      {
        margin-bottom: 24px;
      }

      #source-listing ol 
      {
        padding: 0 0 0 50px;
        width: 90%;
        font-family: monospace;
        list-style-position: outside;
      }

      #source-listing ol li 
      {
        line-height: 18px;
        font-size: small;
      }
        
      #source-listing ol code 
      {
        padding:  0 .001em 0 0; /* Firefox doesn't render empty li's properly */
        font-size: medium;
        white-space: pre;
      }
   </style>
  </head>

  <body>

<div class="nav">
  <a href="mptt.forms.html">mptt.forms</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="mptt.models.html">mptt.models</a>
</div>

<div id="content-header">
  <h1>
    <span id="module-name">mptt.managers</span>:
    373 total statements,
    <span class="critical">0.0% covered</span>
  </h1>
  <p>Generated: Wed 2013-03-13 10:33 CET</p>
  <p>Source file: /media/Envs/Envs/filer-gallery/lib/python2.7/site-packages/mptt/managers.py</p>
  <p>
    Stats:
    <span class="executed">0 executed</span>,
    <span class="missed">367 missed</span>,
    <span class="excluded">6 excluded</span>,
    <span class="ignored">501 ignored</span> 
  </p> 
</div>

<div id="source-listing">
  <ol>
    <li class="ignored"><code>"""</code></li>
<li class="ignored"><code>A custom manager for working with trees of objects.</code></li>
<li class="ignored"><code>"""</code></li>
<li class="excluded"><code>from django.db import connection, models, transaction</code></li>
<li class="excluded"><code>from django.db.models import F, Max</code></li>
<li class="excluded"><code>from django.utils.translation import ugettext as _</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>try:</code></li>
<li class="excluded"><code>    from django.db import connections, router</code></li>
<li class="missed"><code>except ImportError:</code></li>
<li class="ignored"><code>    # multi db support was new in django 1.2</code></li>
<li class="ignored"><code>    # NOTE we don't support django 1.1 anymore, so this stuff is likely to get removed soon</code></li>
<li class="missed"><code>    connections = None</code></li>
<li class="missed"><code>    router = None</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>from mptt.exceptions import InvalidMove</code></li>
<li class="excluded"><code>from mptt.utils import _exists</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>__all__ = ('TreeManager',)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>qn = connection.ops.quote_name</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>COUNT_SUBQUERY = """(</code></li>
<li class="ignored"><code>    SELECT COUNT(*)</code></li>
<li class="ignored"><code>    FROM %(rel_table)s</code></li>
<li class="ignored"><code>    WHERE %(mptt_fk)s = %(mptt_table)s.%(mptt_pk)s</code></li>
<li class="ignored"><code>)"""</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>CUMULATIVE_COUNT_SUBQUERY = """(</code></li>
<li class="ignored"><code>    SELECT COUNT(*)</code></li>
<li class="ignored"><code>    FROM %(rel_table)s</code></li>
<li class="ignored"><code>    WHERE %(mptt_fk)s IN</code></li>
<li class="ignored"><code>    (</code></li>
<li class="ignored"><code>        SELECT m2.%(mptt_pk)s</code></li>
<li class="ignored"><code>        FROM %(mptt_table)s m2</code></li>
<li class="ignored"><code>        WHERE m2.%(tree_id)s = %(mptt_table)s.%(tree_id)s</code></li>
<li class="ignored"><code>          AND m2.%(left)s BETWEEN %(mptt_table)s.%(left)s</code></li>
<li class="ignored"><code>                              AND %(mptt_table)s.%(right)s</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code>)"""</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class TreeManager(models.Manager):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    A manager for working with trees of objects.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def init_from_model(self, model):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Sets things up. This would normally be done in contribute_to_class(),</code></li>
<li class="ignored"><code>        but Django calls that before we've created our extra tree fields on the</code></li>
<li class="ignored"><code>        model (which we need). So it's done here instead, after field setup.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Avoid calling "get_field_by_name()", which populates the related</code></li>
<li class="ignored"><code>        # models cache and can cause circular imports in complex projects.</code></li>
<li class="ignored"><code>        # Instead, find the tree_id field using "get_fields_with_model()".</code></li>
<li class="missed"><code>        [tree_field] = [fld for fld in model._meta.get_fields_with_model() if fld[0].name == self.tree_id_attr]</code></li>
<li class="missed"><code>        if tree_field[1]:</code></li>
<li class="ignored"><code>            # tree_model is the model that contains the tree fields.</code></li>
<li class="ignored"><code>            # this is usually just the same as model, but not for derived models.</code></li>
<li class="missed"><code>            self.tree_model = tree_field[1]</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            self.tree_model = model</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        self._base_manager = None</code></li>
<li class="missed"><code>        if self.tree_model is not model:</code></li>
<li class="ignored"><code>            # _base_manager is the treemanager on tree_model</code></li>
<li class="missed"><code>            self._base_manager = self.tree_model._tree_manager</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @property</code></li>
<li class="ignored"><code>    def parent_attr(self):</code></li>
<li class="missed"><code>        return self.model._mptt_meta.parent_attr</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @property</code></li>
<li class="ignored"><code>    def left_attr(self):</code></li>
<li class="missed"><code>        return self.model._mptt_meta.left_attr</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @property</code></li>
<li class="ignored"><code>    def right_attr(self):</code></li>
<li class="missed"><code>        return self.model._mptt_meta.right_attr</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @property</code></li>
<li class="ignored"><code>    def tree_id_attr(self):</code></li>
<li class="missed"><code>        return self.model._mptt_meta.tree_id_attr</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @property</code></li>
<li class="ignored"><code>    def level_attr(self):</code></li>
<li class="missed"><code>        return self.model._mptt_meta.level_attr</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _translate_lookups(self, **lookups):</code></li>
<li class="missed"><code>        new_lookups = {}</code></li>
<li class="missed"><code>        for k, v in lookups.items():</code></li>
<li class="missed"><code>            parts = k.split('__')</code></li>
<li class="missed"><code>            new_parts = []</code></li>
<li class="missed"><code>            for part in parts:</code></li>
<li class="missed"><code>                new_parts.append(getattr(self, '%s_attr' % part, part))</code></li>
<li class="missed"><code>            new_lookups['__'.join(new_parts)] = v</code></li>
<li class="missed"><code>        return new_lookups</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _mptt_filter(self, qs=None, **filters):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Like self.filter(), but translates name-agnostic filters for MPTT fields.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if self._base_manager:</code></li>
<li class="missed"><code>            return self._base_manager._mptt_filter(qs=qs, **filters)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if qs is None:</code></li>
<li class="missed"><code>            qs = self.get_query_set()</code></li>
<li class="missed"><code>        return qs.filter(**self._translate_lookups(**filters))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _mptt_update(self, qs=None, **items):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Like self.update(), but translates name-agnostic MPTT fields.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if self._base_manager:</code></li>
<li class="missed"><code>            return self._base_manager._mptt_update(qs=qs, **items)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if qs is None:</code></li>
<li class="missed"><code>            qs = self.get_query_set()</code></li>
<li class="missed"><code>        return qs.update(**self._translate_lookups(**items))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _get_connection(self, node):</code></li>
<li class="missed"><code>        if connections is None:</code></li>
<li class="missed"><code>            return connection</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            return connections[router.db_for_write(node)]</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def add_related_count(self, queryset, rel_model, rel_field, count_attr,</code></li>
<li class="ignored"><code>                          cumulative=False):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Adds a related item count to a given ``QuerySet`` using its</code></li>
<li class="ignored"><code>        ``extra`` method, for a ``Model`` class which has a relation to</code></li>
<li class="ignored"><code>        this ``Manager``'s ``Model`` class.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Arguments:</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        ``rel_model``</code></li>
<li class="ignored"><code>           A ``Model`` class which has a relation to this `Manager``'s</code></li>
<li class="ignored"><code>           ``Model`` class.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        ``rel_field``</code></li>
<li class="ignored"><code>           The name of the field in ``rel_model`` which holds the</code></li>
<li class="ignored"><code>           relation.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        ``count_attr``</code></li>
<li class="ignored"><code>           The name of an attribute which should be added to each item in</code></li>
<li class="ignored"><code>           this ``QuerySet``, containing a count of how many instances</code></li>
<li class="ignored"><code>           of ``rel_model`` are related to it through ``rel_field``.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        ``cumulative``</code></li>
<li class="ignored"><code>           If ``True``, the count will be for each item and all of its</code></li>
<li class="ignored"><code>           descendants, otherwise it will be for each item itself.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        meta = self.model._meta</code></li>
<li class="missed"><code>        if cumulative:</code></li>
<li class="missed"><code>            subquery = CUMULATIVE_COUNT_SUBQUERY % {</code></li>
<li class="ignored"><code>                'rel_table': qn(rel_model._meta.db_table),</code></li>
<li class="ignored"><code>                'mptt_fk': qn(rel_model._meta.get_field(rel_field).column),</code></li>
<li class="ignored"><code>                'mptt_table': qn(self.tree_model._meta.db_table),</code></li>
<li class="ignored"><code>                'mptt_pk': qn(meta.pk.column),</code></li>
<li class="ignored"><code>                'tree_id': qn(meta.get_field(self.tree_id_attr).column),</code></li>
<li class="ignored"><code>                'left': qn(meta.get_field(self.left_attr).column),</code></li>
<li class="ignored"><code>                'right': qn(meta.get_field(self.right_attr).column),</code></li>
<li class="ignored"><code>            }</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            subquery = COUNT_SUBQUERY % {</code></li>
<li class="ignored"><code>                'rel_table': qn(rel_model._meta.db_table),</code></li>
<li class="ignored"><code>                'mptt_fk': qn(rel_model._meta.get_field(rel_field).column),</code></li>
<li class="ignored"><code>                'mptt_table': qn(self.tree_model._meta.db_table),</code></li>
<li class="ignored"><code>                'mptt_pk': qn(meta.pk.column),</code></li>
<li class="ignored"><code>            }</code></li>
<li class="missed"><code>        return queryset.extra(select={count_attr: subquery})</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_query_set(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Returns a ``QuerySet`` which contains all tree items, ordered in</code></li>
<li class="ignored"><code>        such a way that that root nodes appear in tree id order and</code></li>
<li class="ignored"><code>        their subtrees appear in depth-first order.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return super(TreeManager, self).get_query_set().order_by(</code></li>
<li class="ignored"><code>            self.tree_id_attr, self.left_attr)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def insert_node(self, node, target, position='last-child', save=False, allow_existing_pk=False):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Sets up the tree state for ``node`` (which has not yet been</code></li>
<li class="ignored"><code>        inserted into in the database) so it will be positioned relative</code></li>
<li class="ignored"><code>        to a given ``target`` node as specified by ``position`` (when</code></li>
<li class="ignored"><code>        appropriate) it is inserted, with any neccessary space already</code></li>
<li class="ignored"><code>        having been made for it.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        A ``target`` of ``None`` indicates that ``node`` should be</code></li>
<li class="ignored"><code>        the last root node.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        If ``save`` is ``True``, ``node``'s ``save()`` method will be</code></li>
<li class="ignored"><code>        called before it is returned.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        NOTE: This is a low-level method; it does NOT respect ``MPTTMeta.order_insertion_by``.</code></li>
<li class="ignored"><code>        In most cases you should just set the node's parent and let mptt call this during save.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if self._base_manager:</code></li>
<li class="missed"><code>            return self._base_manager.insert_node(node, target, position=position, save=save)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if node.pk and not allow_existing_pk and _exists(self.filter(pk=node.pk)):</code></li>
<li class="missed"><code>            raise ValueError(_('Cannot insert a node which has already been saved.'))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if target is None:</code></li>
<li class="missed"><code>            setattr(node, self.left_attr, 1)</code></li>
<li class="missed"><code>            setattr(node, self.right_attr, 2)</code></li>
<li class="missed"><code>            setattr(node, self.level_attr, 0)</code></li>
<li class="missed"><code>            setattr(node, self.tree_id_attr, self._get_next_tree_id())</code></li>
<li class="missed"><code>            setattr(node, self.parent_attr, None)</code></li>
<li class="missed"><code>        elif target.is_root_node() and position in ['left', 'right']:</code></li>
<li class="missed"><code>            target_tree_id = getattr(target, self.tree_id_attr)</code></li>
<li class="missed"><code>            if position == 'left':</code></li>
<li class="missed"><code>                tree_id = target_tree_id</code></li>
<li class="missed"><code>                space_target = target_tree_id - 1</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                tree_id = target_tree_id + 1</code></li>
<li class="missed"><code>                space_target = target_tree_id</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            self._create_tree_space(space_target)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            setattr(node, self.left_attr, 1)</code></li>
<li class="missed"><code>            setattr(node, self.right_attr, 2)</code></li>
<li class="missed"><code>            setattr(node, self.level_attr, 0)</code></li>
<li class="missed"><code>            setattr(node, self.tree_id_attr, tree_id)</code></li>
<li class="missed"><code>            setattr(node, self.parent_attr, None)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            setattr(node, self.left_attr, 0)</code></li>
<li class="missed"><code>            setattr(node, self.level_attr, 0)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            space_target, level, left, parent, right_shift = \</code></li>
<li class="ignored"><code>                self._calculate_inter_tree_move_values(node, target, position)</code></li>
<li class="missed"><code>            tree_id = getattr(parent, self.tree_id_attr)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            self._create_space(2, space_target, tree_id)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            setattr(node, self.left_attr, -left)</code></li>
<li class="missed"><code>            setattr(node, self.right_attr, -left + 1)</code></li>
<li class="missed"><code>            setattr(node, self.level_attr, -level)</code></li>
<li class="missed"><code>            setattr(node, self.tree_id_attr, tree_id)</code></li>
<li class="missed"><code>            setattr(node, self.parent_attr, parent)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            if parent:</code></li>
<li class="missed"><code>                self._post_insert_update_cached_parent_right(parent, right_shift)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if save:</code></li>
<li class="missed"><code>            node.save()</code></li>
<li class="missed"><code>        return node</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def move_node(self, node, target, position='last-child'):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Moves ``node`` relative to a given ``target`` node as specified</code></li>
<li class="ignored"><code>        by ``position`` (when appropriate), by examining both nodes and</code></li>
<li class="ignored"><code>        calling the appropriate method to perform the move.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        A ``target`` of ``None`` indicates that ``node`` should be</code></li>
<li class="ignored"><code>        turned into a root node.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Valid values for ``position`` are ``'first-child'``,</code></li>
<li class="ignored"><code>        ``'last-child'``, ``'left'`` or ``'right'``.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        ``node`` will be modified to reflect its new tree state in the</code></li>
<li class="ignored"><code>        database.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        This method explicitly checks for ``node`` being made a sibling</code></li>
<li class="ignored"><code>        of a root node, as this is a special case due to our use of tree</code></li>
<li class="ignored"><code>        ids to order root nodes.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        NOTE: This is a low-level method; it does NOT respect ``MPTTMeta.order_insertion_by``.</code></li>
<li class="ignored"><code>        In most cases you should just move the node yourself by setting node.parent.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if self._base_manager:</code></li>
<li class="missed"><code>            return self._base_manager.move_node(node, target, position=position)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if target is None:</code></li>
<li class="missed"><code>            if node.is_child_node():</code></li>
<li class="missed"><code>                self._make_child_root_node(node)</code></li>
<li class="missed"><code>        elif target.is_root_node() and position in ['left', 'right']:</code></li>
<li class="missed"><code>            self._make_sibling_of_root_node(node, target, position)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            if node.is_root_node():</code></li>
<li class="missed"><code>                self._move_root_node(node, target, position)</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                self._move_child_node(node, target, position)</code></li>
<li class="missed"><code>        transaction.commit_unless_managed()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def root_node(self, tree_id):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Returns the root node of the tree with the given id.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if self._base_manager:</code></li>
<li class="missed"><code>            return self._base_manager.root_node(tree_id)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        return self._mptt_filter(tree_id=tree_id, parent__isnull=True).get()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def root_nodes(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Creates a ``QuerySet`` containing root nodes.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if self._base_manager:</code></li>
<li class="missed"><code>            return self._base_manager.root_nodes()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        return self._mptt_filter(parent__isnull=True)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def rebuild(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Rebuilds whole tree in database using `parent` link.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if self._base_manager:</code></li>
<li class="missed"><code>            return self._base_manager.rebuild()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        opts = self.model._mptt_meta</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        qs = self._mptt_filter(parent__isnull=True)</code></li>
<li class="missed"><code>        if opts.order_insertion_by:</code></li>
<li class="missed"><code>            qs = qs.order_by(*opts.order_insertion_by)</code></li>
<li class="missed"><code>        pks = qs.values_list('pk', flat=True)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        idx = 0</code></li>
<li class="missed"><code>        for pk in pks:</code></li>
<li class="missed"><code>            idx += 1</code></li>
<li class="missed"><code>            self._rebuild_helper(pk, 1, idx)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _post_insert_update_cached_parent_right(self, instance, right_shift):</code></li>
<li class="missed"><code>        setattr(instance, self.right_attr, getattr(instance, self.right_attr) + right_shift)</code></li>
<li class="missed"><code>        attr = '_%s_cache' % self.parent_attr</code></li>
<li class="missed"><code>        if hasattr(instance, attr):</code></li>
<li class="missed"><code>            parent = getattr(instance, attr)</code></li>
<li class="missed"><code>            if parent:</code></li>
<li class="missed"><code>                self._post_insert_update_cached_parent_right(parent, right_shift)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _rebuild_helper(self, pk, left, tree_id, level=0):</code></li>
<li class="missed"><code>        opts = self.model._mptt_meta</code></li>
<li class="missed"><code>        right = left + 1</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        qs = self._mptt_filter(parent__pk=pk)</code></li>
<li class="missed"><code>        if opts.order_insertion_by:</code></li>
<li class="missed"><code>            qs = qs.order_by(*opts.order_insertion_by)</code></li>
<li class="missed"><code>        child_ids = qs.values_list('pk', flat=True)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        for child_id in child_ids:</code></li>
<li class="missed"><code>            right = self._rebuild_helper(child_id, right, tree_id, level + 1)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        qs = self.model._default_manager.filter(pk=pk)</code></li>
<li class="missed"><code>        self._mptt_update(qs,</code></li>
<li class="ignored"><code>            left=left,</code></li>
<li class="ignored"><code>            right=right,</code></li>
<li class="ignored"><code>            level=level,</code></li>
<li class="ignored"><code>            tree_id=tree_id</code></li>
<li class="ignored"><code>        )</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        return right + 1</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _calculate_inter_tree_move_values(self, node, target, position):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Calculates values required when moving ``node`` relative to</code></li>
<li class="ignored"><code>        ``target`` as specified by ``position``.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        left = getattr(node, self.left_attr)</code></li>
<li class="missed"><code>        level = getattr(node, self.level_attr)</code></li>
<li class="missed"><code>        target_left = getattr(target, self.left_attr)</code></li>
<li class="missed"><code>        target_right = getattr(target, self.right_attr)</code></li>
<li class="missed"><code>        target_level = getattr(target, self.level_attr)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if position == 'last-child' or position == 'first-child':</code></li>
<li class="missed"><code>            if position == 'last-child':</code></li>
<li class="missed"><code>                space_target = target_right - 1</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                space_target = target_left</code></li>
<li class="missed"><code>            level_change = level - target_level - 1</code></li>
<li class="missed"><code>            parent = target</code></li>
<li class="missed"><code>        elif position == 'left' or position == 'right':</code></li>
<li class="missed"><code>            if position == 'left':</code></li>
<li class="missed"><code>                space_target = target_left - 1</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                space_target = target_right</code></li>
<li class="missed"><code>            level_change = level - target_level</code></li>
<li class="missed"><code>            parent = getattr(target, self.parent_attr)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            raise ValueError(_('An invalid position was given: %s.') % position)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        left_right_change = left - space_target - 1</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        right_shift = 0</code></li>
<li class="missed"><code>        if parent:</code></li>
<li class="missed"><code>            right_shift = 2 * (node.get_descendant_count() + 1)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        return space_target, level_change, left_right_change, parent, right_shift</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _close_gap(self, size, target, tree_id):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Closes a gap of a certain ``size`` after the given ``target``</code></li>
<li class="ignored"><code>        point in the tree identified by ``tree_id``.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        self._manage_space(-size, target, tree_id)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _create_space(self, size, target, tree_id):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Creates a space of a certain ``size`` after the given ``target``</code></li>
<li class="ignored"><code>        point in the tree identified by ``tree_id``.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        self._manage_space(size, target, tree_id)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _create_tree_space(self, target_tree_id):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Creates space for a new tree by incrementing all tree ids</code></li>
<li class="ignored"><code>        greater than ``target_tree_id``.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        qs = self._mptt_filter(tree_id__gt=target_tree_id)</code></li>
<li class="missed"><code>        self._mptt_update(qs, tree_id=F(self.tree_id_attr) + 1)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _get_next_tree_id(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Determines the next largest unused tree id for the tree managed</code></li>
<li class="ignored"><code>        by this manager.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        qs = self.get_query_set()</code></li>
<li class="missed"><code>        max_tree_id = qs.aggregate(Max(self.tree_id_attr)).values()[0]</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        max_tree_id = max_tree_id or 0</code></li>
<li class="missed"><code>        return max_tree_id + 1</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _inter_tree_move_and_close_gap(self, node, level_change,</code></li>
<li class="ignored"><code>            left_right_change, new_tree_id, parent_pk=None):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Removes ``node`` from its current tree, with the given set of</code></li>
<li class="ignored"><code>        changes being applied to ``node`` and its descendants, closing</code></li>
<li class="ignored"><code>        the gap left by moving ``node`` as it does so.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        If ``parent_pk`` is ``None``, this indicates that ``node`` is</code></li>
<li class="ignored"><code>        being moved to a brand new tree as its root node, and will thus</code></li>
<li class="ignored"><code>        have its parent field set to ``NULL``. Otherwise, ``node`` will</code></li>
<li class="ignored"><code>        have ``parent_pk`` set for its parent field.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        opts = self.model._meta</code></li>
<li class="missed"><code>        inter_tree_move_query = """</code></li>
<li class="ignored"><code>        UPDATE %(table)s</code></li>
<li class="ignored"><code>        SET %(level)s = CASE</code></li>
<li class="ignored"><code>                WHEN %(left)s &gt;= %%s AND %(left)s &lt;= %%s</code></li>
<li class="ignored"><code>                    THEN %(level)s - %%s</code></li>
<li class="ignored"><code>                ELSE %(level)s END,</code></li>
<li class="ignored"><code>            %(tree_id)s = CASE</code></li>
<li class="ignored"><code>                WHEN %(left)s &gt;= %%s AND %(left)s &lt;= %%s</code></li>
<li class="ignored"><code>                    THEN %%s</code></li>
<li class="ignored"><code>                ELSE %(tree_id)s END,</code></li>
<li class="ignored"><code>            %(left)s = CASE</code></li>
<li class="ignored"><code>                WHEN %(left)s &gt;= %%s AND %(left)s &lt;= %%s</code></li>
<li class="ignored"><code>                    THEN %(left)s - %%s</code></li>
<li class="ignored"><code>                WHEN %(left)s &gt; %%s</code></li>
<li class="ignored"><code>                    THEN %(left)s - %%s</code></li>
<li class="ignored"><code>                ELSE %(left)s END,</code></li>
<li class="ignored"><code>            %(right)s = CASE</code></li>
<li class="ignored"><code>                WHEN %(right)s &gt;= %%s AND %(right)s &lt;= %%s</code></li>
<li class="ignored"><code>                    THEN %(right)s - %%s</code></li>
<li class="ignored"><code>                WHEN %(right)s &gt; %%s</code></li>
<li class="ignored"><code>                    THEN %(right)s - %%s</code></li>
<li class="ignored"><code>                ELSE %(right)s END,</code></li>
<li class="ignored"><code>            %(parent)s = CASE</code></li>
<li class="ignored"><code>                WHEN %(pk)s = %%s</code></li>
<li class="ignored"><code>                    THEN %(new_parent)s</code></li>
<li class="ignored"><code>                ELSE %(parent)s END</code></li>
<li class="ignored"><code>        WHERE %(tree_id)s = %%s""" % {</code></li>
<li class="ignored"><code>            'table': qn(self.tree_model._meta.db_table),</code></li>
<li class="ignored"><code>            'level': qn(opts.get_field(self.level_attr).column),</code></li>
<li class="ignored"><code>            'left': qn(opts.get_field(self.left_attr).column),</code></li>
<li class="ignored"><code>            'tree_id': qn(opts.get_field(self.tree_id_attr).column),</code></li>
<li class="ignored"><code>            'right': qn(opts.get_field(self.right_attr).column),</code></li>
<li class="ignored"><code>            'parent': qn(opts.get_field(self.parent_attr).column),</code></li>
<li class="ignored"><code>            'pk': qn(opts.pk.column),</code></li>
<li class="ignored"><code>            'new_parent': parent_pk is None and 'NULL' or '%s',</code></li>
<li class="ignored"><code>        }</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        left = getattr(node, self.left_attr)</code></li>
<li class="missed"><code>        right = getattr(node, self.right_attr)</code></li>
<li class="missed"><code>        gap_size = right - left + 1</code></li>
<li class="missed"><code>        gap_target_left = left - 1</code></li>
<li class="missed"><code>        params = [</code></li>
<li class="ignored"><code>            left, right, level_change,</code></li>
<li class="ignored"><code>            left, right, new_tree_id,</code></li>
<li class="ignored"><code>            left, right, left_right_change,</code></li>
<li class="ignored"><code>            gap_target_left, gap_size,</code></li>
<li class="ignored"><code>            left, right, left_right_change,</code></li>
<li class="ignored"><code>            gap_target_left, gap_size,</code></li>
<li class="ignored"><code>            node.pk,</code></li>
<li class="ignored"><code>            getattr(node, self.tree_id_attr)</code></li>
<li class="ignored"><code>        ]</code></li>
<li class="missed"><code>        if parent_pk is not None:</code></li>
<li class="missed"><code>            params.insert(-1, parent_pk)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        cursor = self._get_connection(node).cursor()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        cursor.execute(inter_tree_move_query, params)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _make_child_root_node(self, node, new_tree_id=None):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Removes ``node`` from its tree, making it the root node of a new</code></li>
<li class="ignored"><code>        tree.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        If ``new_tree_id`` is not specified a new tree id will be</code></li>
<li class="ignored"><code>        generated.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        ``node`` will be modified to reflect its new tree state in the</code></li>
<li class="ignored"><code>        database.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        left = getattr(node, self.left_attr)</code></li>
<li class="missed"><code>        right = getattr(node, self.right_attr)</code></li>
<li class="missed"><code>        level = getattr(node, self.level_attr)</code></li>
<li class="missed"><code>        if not new_tree_id:</code></li>
<li class="missed"><code>            new_tree_id = self._get_next_tree_id()</code></li>
<li class="missed"><code>        left_right_change = left - 1</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        self._inter_tree_move_and_close_gap(node, level, left_right_change,</code></li>
<li class="ignored"><code>                                            new_tree_id)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Update the node to be consistent with the updated</code></li>
<li class="ignored"><code>        # tree in the database.</code></li>
<li class="missed"><code>        setattr(node, self.left_attr, left - left_right_change)</code></li>
<li class="missed"><code>        setattr(node, self.right_attr, right - left_right_change)</code></li>
<li class="missed"><code>        setattr(node, self.level_attr, 0)</code></li>
<li class="missed"><code>        setattr(node, self.tree_id_attr, new_tree_id)</code></li>
<li class="missed"><code>        setattr(node, self.parent_attr, None)</code></li>
<li class="missed"><code>        node._mptt_cached_fields[self.parent_attr] = None</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _make_sibling_of_root_node(self, node, target, position):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Moves ``node``, making it a sibling of the given ``target`` root</code></li>
<li class="ignored"><code>        node as specified by ``position``.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        ``node`` will be modified to reflect its new tree state in the</code></li>
<li class="ignored"><code>        database.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Since we use tree ids to reduce the number of rows affected by</code></li>
<li class="ignored"><code>        tree mangement during insertion and deletion, root nodes are not</code></li>
<li class="ignored"><code>        true siblings; thus, making an item a sibling of a root node is</code></li>
<li class="ignored"><code>        a special case which involves shuffling tree ids around.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if node == target:</code></li>
<li class="missed"><code>            raise InvalidMove(_('A node may not be made a sibling of itself.'))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        opts = self.model._meta</code></li>
<li class="missed"><code>        tree_id = getattr(node, self.tree_id_attr)</code></li>
<li class="missed"><code>        target_tree_id = getattr(target, self.tree_id_attr)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if node.is_child_node():</code></li>
<li class="missed"><code>            if position == 'left':</code></li>
<li class="missed"><code>                space_target = target_tree_id - 1</code></li>
<li class="missed"><code>                new_tree_id = target_tree_id</code></li>
<li class="missed"><code>            elif position == 'right':</code></li>
<li class="missed"><code>                space_target = target_tree_id</code></li>
<li class="missed"><code>                new_tree_id = target_tree_id + 1</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                raise ValueError(_('An invalid position was given: %s.') % position)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            self._create_tree_space(space_target)</code></li>
<li class="missed"><code>            if tree_id &gt; space_target:</code></li>
<li class="ignored"><code>                # The node's tree id has been incremented in the</code></li>
<li class="ignored"><code>                # database - this change must be reflected in the node</code></li>
<li class="ignored"><code>                # object for the method call below to operate on the</code></li>
<li class="ignored"><code>                # correct tree.</code></li>
<li class="missed"><code>                setattr(node, self.tree_id_attr, tree_id + 1)</code></li>
<li class="missed"><code>            self._make_child_root_node(node, new_tree_id)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            if position == 'left':</code></li>
<li class="missed"><code>                if target_tree_id &gt; tree_id:</code></li>
<li class="missed"><code>                    left_sibling = target.get_previous_sibling()</code></li>
<li class="missed"><code>                    if node == left_sibling:</code></li>
<li class="missed"><code>                        return</code></li>
<li class="missed"><code>                    new_tree_id = getattr(left_sibling, self.tree_id_attr)</code></li>
<li class="missed"><code>                    lower_bound, upper_bound = tree_id, new_tree_id</code></li>
<li class="missed"><code>                    shift = -1</code></li>
<li class="ignored"><code>                else:</code></li>
<li class="missed"><code>                    new_tree_id = target_tree_id</code></li>
<li class="missed"><code>                    lower_bound, upper_bound = new_tree_id, tree_id</code></li>
<li class="missed"><code>                    shift = 1</code></li>
<li class="missed"><code>            elif position == 'right':</code></li>
<li class="missed"><code>                if target_tree_id &gt; tree_id:</code></li>
<li class="missed"><code>                    new_tree_id = target_tree_id</code></li>
<li class="missed"><code>                    lower_bound, upper_bound = tree_id, target_tree_id</code></li>
<li class="missed"><code>                    shift = -1</code></li>
<li class="ignored"><code>                else:</code></li>
<li class="missed"><code>                    right_sibling = target.get_next_sibling()</code></li>
<li class="missed"><code>                    if node == right_sibling:</code></li>
<li class="missed"><code>                        return</code></li>
<li class="missed"><code>                    new_tree_id = getattr(right_sibling, self.tree_id_attr)</code></li>
<li class="missed"><code>                    lower_bound, upper_bound = new_tree_id, tree_id</code></li>
<li class="missed"><code>                    shift = 1</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                raise ValueError(_('An invalid position was given: %s.') % position)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            root_sibling_query = """</code></li>
<li class="ignored"><code>            UPDATE %(table)s</code></li>
<li class="ignored"><code>            SET %(tree_id)s = CASE</code></li>
<li class="ignored"><code>                WHEN %(tree_id)s = %%s</code></li>
<li class="ignored"><code>                    THEN %%s</code></li>
<li class="ignored"><code>                ELSE %(tree_id)s + %%s END</code></li>
<li class="ignored"><code>            WHERE %(tree_id)s &gt;= %%s AND %(tree_id)s &lt;= %%s""" % {</code></li>
<li class="ignored"><code>                'table': qn(self.tree_model._meta.db_table),</code></li>
<li class="ignored"><code>                'tree_id': qn(opts.get_field(self.tree_id_attr).column),</code></li>
<li class="ignored"><code>            }</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            cursor = self._get_connection(node).cursor()</code></li>
<li class="missed"><code>            cursor.execute(root_sibling_query, [tree_id, new_tree_id, shift,</code></li>
<li class="ignored"><code>                                                lower_bound, upper_bound])</code></li>
<li class="missed"><code>            setattr(node, self.tree_id_attr, new_tree_id)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _manage_space(self, size, target, tree_id):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Manages spaces in the tree identified by ``tree_id`` by changing</code></li>
<li class="ignored"><code>        the values of the left and right columns by ``size`` after the</code></li>
<li class="ignored"><code>        given ``target`` point.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        opts = self.model._meta</code></li>
<li class="missed"><code>        space_query = """</code></li>
<li class="ignored"><code>        UPDATE %(table)s</code></li>
<li class="ignored"><code>        SET %(left)s = CASE</code></li>
<li class="ignored"><code>                WHEN %(left)s &gt; %%s</code></li>
<li class="ignored"><code>                    THEN %(left)s + %%s</code></li>
<li class="ignored"><code>                ELSE %(left)s END,</code></li>
<li class="ignored"><code>            %(right)s = CASE</code></li>
<li class="ignored"><code>                WHEN %(right)s &gt; %%s</code></li>
<li class="ignored"><code>                    THEN %(right)s + %%s</code></li>
<li class="ignored"><code>                ELSE %(right)s END</code></li>
<li class="ignored"><code>        WHERE %(tree_id)s = %%s</code></li>
<li class="ignored"><code>          AND (%(left)s &gt; %%s OR %(right)s &gt; %%s)""" % {</code></li>
<li class="ignored"><code>            'table': qn(self.tree_model._meta.db_table),</code></li>
<li class="ignored"><code>            'left': qn(opts.get_field(self.left_attr).column),</code></li>
<li class="ignored"><code>            'right': qn(opts.get_field(self.right_attr).column),</code></li>
<li class="ignored"><code>            'tree_id': qn(opts.get_field(self.tree_id_attr).column),</code></li>
<li class="ignored"><code>        }</code></li>
<li class="missed"><code>        cursor = self._get_connection(self.model).cursor()</code></li>
<li class="missed"><code>        cursor.execute(space_query, [target, size, target, size, tree_id,</code></li>
<li class="ignored"><code>                                     target, target])</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _move_child_node(self, node, target, position):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Calls the appropriate method to move child node ``node``</code></li>
<li class="ignored"><code>        relative to the given ``target`` node as specified by</code></li>
<li class="ignored"><code>        ``position``.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        tree_id = getattr(node, self.tree_id_attr)</code></li>
<li class="missed"><code>        target_tree_id = getattr(target, self.tree_id_attr)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if tree_id == target_tree_id:</code></li>
<li class="missed"><code>            self._move_child_within_tree(node, target, position)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            self._move_child_to_new_tree(node, target, position)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _move_child_to_new_tree(self, node, target, position):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Moves child node ``node`` to a different tree, inserting it</code></li>
<li class="ignored"><code>        relative to the given ``target`` node in the new tree as</code></li>
<li class="ignored"><code>        specified by ``position``.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        ``node`` will be modified to reflect its new tree state in the</code></li>
<li class="ignored"><code>        database.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        left = getattr(node, self.left_attr)</code></li>
<li class="missed"><code>        right = getattr(node, self.right_attr)</code></li>
<li class="missed"><code>        level = getattr(node, self.level_attr)</code></li>
<li class="missed"><code>        new_tree_id = getattr(target, self.tree_id_attr)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        space_target, level_change, left_right_change, parent, new_parent_right = \</code></li>
<li class="ignored"><code>            self._calculate_inter_tree_move_values(node, target, position)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        tree_width = right - left + 1</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Make space for the subtree which will be moved</code></li>
<li class="missed"><code>        self._create_space(tree_width, space_target, new_tree_id)</code></li>
<li class="ignored"><code>        # Move the subtree</code></li>
<li class="missed"><code>        self._inter_tree_move_and_close_gap(node, level_change,</code></li>
<li class="ignored"><code>            left_right_change, new_tree_id, parent.pk)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Update the node to be consistent with the updated</code></li>
<li class="ignored"><code>        # tree in the database.</code></li>
<li class="missed"><code>        setattr(node, self.left_attr, left - left_right_change)</code></li>
<li class="missed"><code>        setattr(node, self.right_attr, right - left_right_change)</code></li>
<li class="missed"><code>        setattr(node, self.level_attr, level - level_change)</code></li>
<li class="missed"><code>        setattr(node, self.tree_id_attr, new_tree_id)</code></li>
<li class="missed"><code>        setattr(node, self.parent_attr, parent)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        node._mptt_cached_fields[self.parent_attr] = parent.pk</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _move_child_within_tree(self, node, target, position):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Moves child node ``node`` within its current tree relative to</code></li>
<li class="ignored"><code>        the given ``target`` node as specified by ``position``.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        ``node`` will be modified to reflect its new tree state in the</code></li>
<li class="ignored"><code>        database.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        left = getattr(node, self.left_attr)</code></li>
<li class="missed"><code>        right = getattr(node, self.right_attr)</code></li>
<li class="missed"><code>        level = getattr(node, self.level_attr)</code></li>
<li class="missed"><code>        width = right - left + 1</code></li>
<li class="missed"><code>        tree_id = getattr(node, self.tree_id_attr)</code></li>
<li class="missed"><code>        target_left = getattr(target, self.left_attr)</code></li>
<li class="missed"><code>        target_right = getattr(target, self.right_attr)</code></li>
<li class="missed"><code>        target_level = getattr(target, self.level_attr)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if position == 'last-child' or position == 'first-child':</code></li>
<li class="missed"><code>            if node == target:</code></li>
<li class="missed"><code>                raise InvalidMove(_('A node may not be made a child of itself.'))</code></li>
<li class="missed"><code>            elif left &lt; target_left &lt; right:</code></li>
<li class="missed"><code>                raise InvalidMove(_('A node may not be made a child of any of its descendants.'))</code></li>
<li class="missed"><code>            if position == 'last-child':</code></li>
<li class="missed"><code>                if target_right &gt; right:</code></li>
<li class="missed"><code>                    new_left = target_right - width</code></li>
<li class="missed"><code>                    new_right = target_right - 1</code></li>
<li class="ignored"><code>                else:</code></li>
<li class="missed"><code>                    new_left = target_right</code></li>
<li class="missed"><code>                    new_right = target_right + width - 1</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                if target_left &gt; left:</code></li>
<li class="missed"><code>                    new_left = target_left - width + 1</code></li>
<li class="missed"><code>                    new_right = target_left</code></li>
<li class="ignored"><code>                else:</code></li>
<li class="missed"><code>                    new_left = target_left + 1</code></li>
<li class="missed"><code>                    new_right = target_left + width</code></li>
<li class="missed"><code>            level_change = level - target_level - 1</code></li>
<li class="missed"><code>            parent = target</code></li>
<li class="missed"><code>        elif position == 'left' or position == 'right':</code></li>
<li class="missed"><code>            if node == target:</code></li>
<li class="missed"><code>                raise InvalidMove(_('A node may not be made a sibling of itself.'))</code></li>
<li class="missed"><code>            elif left &lt; target_left &lt; right:</code></li>
<li class="missed"><code>                raise InvalidMove(_('A node may not be made a sibling of any of its descendants.'))</code></li>
<li class="missed"><code>            if position == 'left':</code></li>
<li class="missed"><code>                if target_left &gt; left:</code></li>
<li class="missed"><code>                    new_left = target_left - width</code></li>
<li class="missed"><code>                    new_right = target_left - 1</code></li>
<li class="ignored"><code>                else:</code></li>
<li class="missed"><code>                    new_left = target_left</code></li>
<li class="missed"><code>                    new_right = target_left + width - 1</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                if target_right &gt; right:</code></li>
<li class="missed"><code>                    new_left = target_right - width + 1</code></li>
<li class="missed"><code>                    new_right = target_right</code></li>
<li class="ignored"><code>                else:</code></li>
<li class="missed"><code>                    new_left = target_right + 1</code></li>
<li class="missed"><code>                    new_right = target_right + width</code></li>
<li class="missed"><code>            level_change = level - target_level</code></li>
<li class="missed"><code>            parent = getattr(target, self.parent_attr)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            raise ValueError(_('An invalid position was given: %s.') % position)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        left_boundary = min(left, new_left)</code></li>
<li class="missed"><code>        right_boundary = max(right, new_right)</code></li>
<li class="missed"><code>        left_right_change = new_left - left</code></li>
<li class="missed"><code>        gap_size = width</code></li>
<li class="missed"><code>        if left_right_change &gt; 0:</code></li>
<li class="missed"><code>            gap_size = -gap_size</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        opts = self.model._meta</code></li>
<li class="ignored"><code>        # The level update must come before the left update to keep</code></li>
<li class="ignored"><code>        # MySQL happy - left seems to refer to the updated value</code></li>
<li class="ignored"><code>        # immediately after its update has been specified in the query</code></li>
<li class="ignored"><code>        # with MySQL, but not with SQLite or Postgres.</code></li>
<li class="missed"><code>        move_subtree_query = """</code></li>
<li class="ignored"><code>        UPDATE %(table)s</code></li>
<li class="ignored"><code>        SET %(level)s = CASE</code></li>
<li class="ignored"><code>                WHEN %(left)s &gt;= %%s AND %(left)s &lt;= %%s</code></li>
<li class="ignored"><code>                  THEN %(level)s - %%s</code></li>
<li class="ignored"><code>                ELSE %(level)s END,</code></li>
<li class="ignored"><code>            %(left)s = CASE</code></li>
<li class="ignored"><code>                WHEN %(left)s &gt;= %%s AND %(left)s &lt;= %%s</code></li>
<li class="ignored"><code>                  THEN %(left)s + %%s</code></li>
<li class="ignored"><code>                WHEN %(left)s &gt;= %%s AND %(left)s &lt;= %%s</code></li>
<li class="ignored"><code>                  THEN %(left)s + %%s</code></li>
<li class="ignored"><code>                ELSE %(left)s END,</code></li>
<li class="ignored"><code>            %(right)s = CASE</code></li>
<li class="ignored"><code>                WHEN %(right)s &gt;= %%s AND %(right)s &lt;= %%s</code></li>
<li class="ignored"><code>                  THEN %(right)s + %%s</code></li>
<li class="ignored"><code>                WHEN %(right)s &gt;= %%s AND %(right)s &lt;= %%s</code></li>
<li class="ignored"><code>                  THEN %(right)s + %%s</code></li>
<li class="ignored"><code>                ELSE %(right)s END,</code></li>
<li class="ignored"><code>            %(parent)s = CASE</code></li>
<li class="ignored"><code>                WHEN %(pk)s = %%s</code></li>
<li class="ignored"><code>                  THEN %%s</code></li>
<li class="ignored"><code>                ELSE %(parent)s END</code></li>
<li class="ignored"><code>        WHERE %(tree_id)s = %%s""" % {</code></li>
<li class="ignored"><code>            'table': qn(self.tree_model._meta.db_table),</code></li>
<li class="ignored"><code>            'level': qn(opts.get_field(self.level_attr).column),</code></li>
<li class="ignored"><code>            'left': qn(opts.get_field(self.left_attr).column),</code></li>
<li class="ignored"><code>            'right': qn(opts.get_field(self.right_attr).column),</code></li>
<li class="ignored"><code>            'parent': qn(opts.get_field(self.parent_attr).column),</code></li>
<li class="ignored"><code>            'pk': qn(opts.pk.column),</code></li>
<li class="ignored"><code>            'tree_id': qn(opts.get_field(self.tree_id_attr).column),</code></li>
<li class="ignored"><code>        }</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        cursor = self._get_connection(node).cursor()</code></li>
<li class="missed"><code>        cursor.execute(move_subtree_query, [</code></li>
<li class="ignored"><code>            left, right, level_change,</code></li>
<li class="ignored"><code>            left, right, left_right_change,</code></li>
<li class="ignored"><code>            left_boundary, right_boundary, gap_size,</code></li>
<li class="ignored"><code>            left, right, left_right_change,</code></li>
<li class="ignored"><code>            left_boundary, right_boundary, gap_size,</code></li>
<li class="ignored"><code>            node.pk, parent.pk,</code></li>
<li class="ignored"><code>            tree_id])</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Update the node to be consistent with the updated</code></li>
<li class="ignored"><code>        # tree in the database.</code></li>
<li class="missed"><code>        setattr(node, self.left_attr, new_left)</code></li>
<li class="missed"><code>        setattr(node, self.right_attr, new_right)</code></li>
<li class="missed"><code>        setattr(node, self.level_attr, level - level_change)</code></li>
<li class="missed"><code>        setattr(node, self.parent_attr, parent)</code></li>
<li class="missed"><code>        node._mptt_cached_fields[self.parent_attr] = parent.pk</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _move_root_node(self, node, target, position):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Moves root node``node`` to a different tree, inserting it</code></li>
<li class="ignored"><code>        relative to the given ``target`` node as specified by</code></li>
<li class="ignored"><code>        ``position``.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        ``node`` will be modified to reflect its new tree state in the</code></li>
<li class="ignored"><code>        database.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        left = getattr(node, self.left_attr)</code></li>
<li class="missed"><code>        right = getattr(node, self.right_attr)</code></li>
<li class="missed"><code>        level = getattr(node, self.level_attr)</code></li>
<li class="missed"><code>        tree_id = getattr(node, self.tree_id_attr)</code></li>
<li class="missed"><code>        new_tree_id = getattr(target, self.tree_id_attr)</code></li>
<li class="missed"><code>        width = right - left + 1</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if node == target:</code></li>
<li class="missed"><code>            raise InvalidMove(_('A node may not be made a child of itself.'))</code></li>
<li class="missed"><code>        elif tree_id == new_tree_id:</code></li>
<li class="missed"><code>            raise InvalidMove(_('A node may not be made a child of any of its descendants.'))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        space_target, level_change, left_right_change, parent, right_shift = \</code></li>
<li class="ignored"><code>            self._calculate_inter_tree_move_values(node, target, position)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Create space for the tree which will be inserted</code></li>
<li class="missed"><code>        self._create_space(width, space_target, new_tree_id)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Move the root node, making it a child node</code></li>
<li class="missed"><code>        opts = self.model._meta</code></li>
<li class="missed"><code>        move_tree_query = """</code></li>
<li class="ignored"><code>        UPDATE %(table)s</code></li>
<li class="ignored"><code>        SET %(level)s = %(level)s - %%s,</code></li>
<li class="ignored"><code>            %(left)s = %(left)s - %%s,</code></li>
<li class="ignored"><code>            %(right)s = %(right)s - %%s,</code></li>
<li class="ignored"><code>            %(tree_id)s = %%s,</code></li>
<li class="ignored"><code>            %(parent)s = CASE</code></li>
<li class="ignored"><code>                WHEN %(pk)s = %%s</code></li>
<li class="ignored"><code>                    THEN %%s</code></li>
<li class="ignored"><code>                ELSE %(parent)s END</code></li>
<li class="ignored"><code>        WHERE %(left)s &gt;= %%s AND %(left)s &lt;= %%s</code></li>
<li class="ignored"><code>          AND %(tree_id)s = %%s""" % {</code></li>
<li class="ignored"><code>            'table': qn(self.tree_model._meta.db_table),</code></li>
<li class="ignored"><code>            'level': qn(opts.get_field(self.level_attr).column),</code></li>
<li class="ignored"><code>            'left': qn(opts.get_field(self.left_attr).column),</code></li>
<li class="ignored"><code>            'right': qn(opts.get_field(self.right_attr).column),</code></li>
<li class="ignored"><code>            'tree_id': qn(opts.get_field(self.tree_id_attr).column),</code></li>
<li class="ignored"><code>            'parent': qn(opts.get_field(self.parent_attr).column),</code></li>
<li class="ignored"><code>            'pk': qn(opts.pk.column),</code></li>
<li class="ignored"><code>        }</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        cursor = self._get_connection(node).cursor()</code></li>
<li class="missed"><code>        cursor.execute(move_tree_query, [level_change, left_right_change,</code></li>
<li class="ignored"><code>            left_right_change, new_tree_id, node.pk, parent.pk, left, right,</code></li>
<li class="ignored"><code>            tree_id])</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Update the former root node to be consistent with the updated</code></li>
<li class="ignored"><code>        # tree in the database.</code></li>
<li class="missed"><code>        setattr(node, self.left_attr, left - left_right_change)</code></li>
<li class="missed"><code>        setattr(node, self.right_attr, right - left_right_change)</code></li>
<li class="missed"><code>        setattr(node, self.level_attr, level - level_change)</code></li>
<li class="missed"><code>        setattr(node, self.tree_id_attr, new_tree_id)</code></li>
<li class="missed"><code>        setattr(node, self.parent_attr, parent)</code></li>
<li class="missed"><code>        node._mptt_cached_fields[self.parent_attr] = parent.pk</code></li>
  </ol>
</div>

<div class="nav">
  <a href="mptt.forms.html">mptt.forms</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="mptt.models.html">mptt.models</a>
</div>

  </body>
</html>

