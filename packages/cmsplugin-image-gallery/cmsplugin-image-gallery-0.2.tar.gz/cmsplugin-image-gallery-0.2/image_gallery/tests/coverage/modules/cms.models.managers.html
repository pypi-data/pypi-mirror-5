<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <title>Test coverage report: cms.models.managers</title>
    <style type="text/css" media="screen">
      a
      {
        color: #3d707a;
      }
      
      a:hover, a:active
      {
        color: #bf7d18;
      }
    
      body 
      {
        font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        font-size: 13px;
      }
      
      .nav 
      {
        font-size: 12px;
        margin-left: 50px;
      }

      .ignored
      {
        color: #707070;
      }

      .executed 
      {
        color: #3d9900;
      }

      .missed 
      {
        color: red;
        font-weight: bold;
      }

      .excluded 
      {
        color: #6090f0;
        font-weight: lighter;
      }
    
      #content-header 
      {
        font-size: 12px;
        padding: 18px 0 18px 50px;
      }

      #content-header h1 
      {
        font-size: 16px;
        margin: 10px 0 0 0;
        color: #909090;
      }
      
      #module-name
      {
        color: #583707;
      }
    
      #content-header p
      {
        font-size: 13px;
        margin: 0;
        color: #909090;
      }

      #content-header .normal 
      {
        color: #609030;
      }

      #content-header .warning 
      {
        color: #d0a000;
      }

      #content-header .critical 
      {
        color: red;
      }
      
      #source-listing 
      {
        margin-bottom: 24px;
      }

      #source-listing ol 
      {
        padding: 0 0 0 50px;
        width: 90%;
        font-family: monospace;
        list-style-position: outside;
      }

      #source-listing ol li 
      {
        line-height: 18px;
        font-size: small;
      }
        
      #source-listing ol code 
      {
        padding:  0 .001em 0 0; /* Firefox doesn't render empty li's properly */
        font-size: medium;
        white-space: pre;
      }
   </style>
  </head>

  <body>

<div class="nav">
  <a href="cms.models.fields.html">cms.models.fields</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="cms.models.metaclasses.html">cms.models.metaclasses</a>
</div>

<div id="content-header">
  <h1>
    <span id="module-name">cms.models.managers</span>:
    200 total statements,
    <span class="critical">0.0% covered</span>
  </h1>
  <p>Generated: Wed 2013-03-13 10:33 CET</p>
  <p>Source file: /media/Envs/Envs/filer-gallery/lib/python2.7/site-packages/cms/models/managers.py</p>
  <p>
    Stats:
    <span class="executed">0 executed</span>,
    <span class="missed">185 missed</span>,
    <span class="excluded">15 excluded</span>,
    <span class="ignored">301 ignored</span> 
  </p> 
</div>

<div id="source-listing">
  <ol>
    <li class="ignored"><code># -*- coding: utf-8 -*-</code></li>
<li class="excluded"><code>from cms.cache.permissions import get_permission_cache, set_permission_cache</code></li>
<li class="excluded"><code>from cms.exceptions import NoPermissionsException</code></li>
<li class="excluded"><code>from cms.models.query import PageQuerySet</code></li>
<li class="excluded"><code>from cms.publisher import PublisherManager</code></li>
<li class="excluded"><code>from cms.utils.i18n import get_fallback_languages</code></li>
<li class="excluded"><code>from django.conf import settings</code></li>
<li class="excluded"><code>from django.contrib.sites.models import Site</code></li>
<li class="excluded"><code>from django.db import models</code></li>
<li class="excluded"><code>from django.db.models import Q</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class PageManager(PublisherManager):</code></li>
<li class="ignored"><code>    """Use draft() and public() methods for accessing the corresponding</code></li>
<li class="ignored"><code>    instances.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_query_set(self):</code></li>
<li class="ignored"><code>        """Change standard model queryset to our own.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return PageQuerySet(self.model)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def drafts(self):</code></li>
<li class="missed"><code>        return super(PageManager, self).drafts().exclude(</code></li>
<li class="ignored"><code>            publisher_state=self.model.PUBLISHER_STATE_DELETE</code></li>
<li class="ignored"><code>        )</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def public(self):</code></li>
<li class="missed"><code>        return super(PageManager, self).public().exclude(</code></li>
<li class="ignored"><code>            publisher_state=self.model.PUBLISHER_STATE_DELETE</code></li>
<li class="ignored"><code>        )</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # !IMPORTANT: following methods always return access to draft instances,</code></li>
<li class="ignored"><code>    # take care on what you do one them. use Page.objects.public() for accessing</code></li>
<li class="ignored"><code>    # the published page versions</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # Just some of the queryset methods are implemented here, access queryset</code></li>
<li class="ignored"><code>    # for more getting more supporting methods.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # TODO: check which from following methods are really required to be on</code></li>
<li class="ignored"><code>    # manager, maybe some of them can be just accessible over queryset...?</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def on_site(self, site=None):</code></li>
<li class="missed"><code>        return self.get_query_set().on_site(site)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def root(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Return a queryset with pages that don't have parents, a.k.a. root. For</code></li>
<li class="ignored"><code>        current site - used in frontend</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.get_query_set().root()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def all_root(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Return a queryset with pages that don't have parents, a.k.a. root. For</code></li>
<li class="ignored"><code>        all sites - used in frontend</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.get_query_set().all_root()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def valid_targets(self, page_id, request, perms, page=None):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Give valid targets to move a page into the tree</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.get_query_set().valid_targets(page_id, request, perms, page)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def published(self, site=None):</code></li>
<li class="missed"><code>        return self.get_query_set().published(site)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def expired(self):</code></li>
<li class="missed"><code>        return self.drafts().expired()</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>#    - seems this is not used anymore...</code></li>
<li class="ignored"><code>#    def get_pages_with_application(self, path, language):</code></li>
<li class="ignored"><code>#        """Returns all pages containing application for current path, or</code></li>
<li class="ignored"><code>#        any parrent. Returned list is sorted by path length, longer path first.</code></li>
<li class="ignored"><code>#        """</code></li>
<li class="ignored"><code>#        paths = levelize_path(path)</code></li>
<li class="ignored"><code>#        q = Q()</code></li>
<li class="ignored"><code>#        for path in paths:</code></li>
<li class="ignored"><code>#            # build q for all the paths</code></li>
<li class="ignored"><code>#            q |= Q(title_set__path=path, title_set__language=language)</code></li>
<li class="ignored"><code>#        app_pages = self.published().filter(q &amp; Q(title_set__application_urls__gt='')).distinct()</code></li>
<li class="ignored"><code>#        # add proper ordering</code></li>
<li class="ignored"><code>#        app_pages.query.order_by.extend(('LENGTH(`cms_title`.`path`) DESC',))</code></li>
<li class="ignored"><code>#        return app_pages</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_all_pages_with_application(self):</code></li>
<li class="ignored"><code>        """Returns all pages containing applications for all sites.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Doesn't cares about the application language.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.get_query_set().filter(title_set__application_urls__gt='').distinct()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_home(self, site=None):</code></li>
<li class="missed"><code>        return self.get_query_set().get_home(site)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def search(self, q, language=None, current_site_only=True):</code></li>
<li class="ignored"><code>        """Simple search function</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Plugins can define a 'search_fields' tuple similar to ModelAdmin classes</code></li>
<li class="ignored"><code>        """</code></li>
<li class="excluded"><code>        from cms.plugin_pool import plugin_pool</code></li>
<li class="missed"><code>        qs = self.get_query_set()</code></li>
<li class="missed"><code>        if settings.CMS_MODERATOR:</code></li>
<li class="missed"><code>            qs = qs.public()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if current_site_only:</code></li>
<li class="missed"><code>            site = Site.objects.get_current()</code></li>
<li class="missed"><code>            qs = qs.filter(site=site)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        qt = Q(title_set__title__icontains=q)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # find 'searchable' plugins and build query</code></li>
<li class="missed"><code>        qp = Q()</code></li>
<li class="missed"><code>        plugins = plugin_pool.get_all_plugins()</code></li>
<li class="missed"><code>        for plugin in plugins:</code></li>
<li class="missed"><code>            cmsplugin = plugin.model</code></li>
<li class="missed"><code>            if hasattr(cmsplugin, 'search_fields'):</code></li>
<li class="missed"><code>                for field in cmsplugin.search_fields:</code></li>
<li class="missed"><code>                    qp |= Q(**{'placeholders__cmsplugin__%s__%s__icontains' % \</code></li>
<li class="ignored"><code>                                   (cmsplugin.__name__.lower(), field):q})</code></li>
<li class="missed"><code>        if language:</code></li>
<li class="missed"><code>            qt &amp;= Q(title_set__language=language)</code></li>
<li class="missed"><code>            qp &amp;= Q(cmsplugin__language=language)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        qs = qs.filter(qt | qp)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        return qs.distinct()</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class TitleManager(PublisherManager):</code></li>
<li class="missed"><code>    def get_title(self, page, language, language_fallback=False):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Gets the latest content for a particular page and language. Falls back</code></li>
<li class="ignored"><code>        to another language if wanted.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        try:</code></li>
<li class="missed"><code>            title = self.get(language=language, page=page)</code></li>
<li class="missed"><code>            return title</code></li>
<li class="missed"><code>        except self.model.DoesNotExist:</code></li>
<li class="missed"><code>            if language_fallback:</code></li>
<li class="missed"><code>                try:</code></li>
<li class="missed"><code>                    titles = self.filter(page=page)</code></li>
<li class="missed"><code>                    fallbacks = get_fallback_languages(language)</code></li>
<li class="missed"><code>                    for lang in fallbacks:</code></li>
<li class="missed"><code>                        for title in titles:</code></li>
<li class="missed"><code>                            if lang == title.language:</code></li>
<li class="missed"><code>                                return title</code></li>
<li class="missed"><code>                    return None</code></li>
<li class="missed"><code>                except self.model.DoesNotExist:</code></li>
<li class="missed"><code>                    pass</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                raise</code></li>
<li class="missed"><code>        return None</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_page_slug(self, slug, site=None):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Returns the latest slug for the given slug and checks if it's available</code></li>
<li class="ignored"><code>        on the current site.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if not site:</code></li>
<li class="missed"><code>            site = Site.objects.get_current()</code></li>
<li class="missed"><code>        try:</code></li>
<li class="missed"><code>            titles = self.filter(</code></li>
<li class="ignored"><code>                slug=slug,</code></li>
<li class="ignored"><code>                page__site=site,</code></li>
<li class="ignored"><code>            ).select_related()  # 'page')</code></li>
<li class="missed"><code>        except self.model.DoesNotExist:</code></li>
<li class="missed"><code>            return None</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            return titles</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # created new public method to meet test case requirement and to get a list of titles for published pages</code></li>
<li class="missed"><code>    def public(self):</code></li>
<li class="missed"><code>        return self.get_query_set().filter(page__publisher_is_draft=False, page__published=True)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def drafts(self):</code></li>
<li class="missed"><code>        return self.get_query_set().filter(page__publisher_is_draft=True)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def set_or_create(self, request, page, form, language):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        set or create a title for a particular page and language</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        base_fields = [</code></li>
<li class="ignored"><code>            'slug',</code></li>
<li class="ignored"><code>            'title',</code></li>
<li class="ignored"><code>            'meta_description',</code></li>
<li class="ignored"><code>            'meta_keywords',</code></li>
<li class="ignored"><code>            'page_title',</code></li>
<li class="ignored"><code>            'menu_title'</code></li>
<li class="ignored"><code>        ]</code></li>
<li class="missed"><code>        advanced_fields = [</code></li>
<li class="ignored"><code>            'application_urls',</code></li>
<li class="ignored"><code>            'redirect',</code></li>
<li class="ignored"><code>        ]</code></li>
<li class="missed"><code>        cleaned_data = form.cleaned_data</code></li>
<li class="missed"><code>        try:</code></li>
<li class="missed"><code>            obj = self.get(page=page, language=language)</code></li>
<li class="missed"><code>        except self.model.DoesNotExist:</code></li>
<li class="missed"><code>            data = {}</code></li>
<li class="missed"><code>            for name in base_fields:</code></li>
<li class="missed"><code>                if name in cleaned_data:</code></li>
<li class="missed"><code>                    data[name] = cleaned_data[name]</code></li>
<li class="missed"><code>            data['page'] = page</code></li>
<li class="missed"><code>            data['language'] = language</code></li>
<li class="missed"><code>            if page.has_advanced_settings_permission(request):</code></li>
<li class="missed"><code>                overwrite_url = cleaned_data.get('overwrite_url', None)</code></li>
<li class="missed"><code>                if overwrite_url:</code></li>
<li class="missed"><code>                    data['has_url_overwrite'] = True</code></li>
<li class="missed"><code>                    data['path'] = overwrite_url</code></li>
<li class="missed"><code>                for field in advanced_fields:</code></li>
<li class="missed"><code>                    value = cleaned_data.get(field, None)</code></li>
<li class="missed"><code>                    if value:</code></li>
<li class="missed"><code>                        data[field] = value</code></li>
<li class="missed"><code>            return self.create(**data)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        for name in base_fields:</code></li>
<li class="missed"><code>            value = cleaned_data.get(name, None)</code></li>
<li class="missed"><code>            setattr(obj, name, value)</code></li>
<li class="missed"><code>        if page.has_advanced_settings_permission(request):</code></li>
<li class="missed"><code>            overwrite_url = cleaned_data.get('overwrite_url', None)</code></li>
<li class="missed"><code>            obj.has_url_overwrite = bool(overwrite_url)</code></li>
<li class="missed"><code>            obj.path = overwrite_url</code></li>
<li class="missed"><code>            for field in advanced_fields:</code></li>
<li class="missed"><code>                setattr(obj, field, cleaned_data.get(field, None))</code></li>
<li class="missed"><code>        obj.save()</code></li>
<li class="missed"><code>        return obj</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>################################################################################</code></li>
<li class="ignored"><code># Permissions</code></li>
<li class="ignored"><code>################################################################################</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class BasicPagePermissionManager(models.Manager):</code></li>
<li class="ignored"><code>    """Global page permission manager accessible under objects.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    !IMPORTANT: take care, PagePermissionManager extends this manager</code></li>
<li class="ignored"><code>    """</code></li>
<li class="missed"><code>    def with_user(self, user):</code></li>
<li class="ignored"><code>        """Get all objects for given user, also takes look if user is in some</code></li>
<li class="ignored"><code>        group.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.filter(Q(user=user) | Q(group__user=user))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def with_can_change_permissions(self, user):</code></li>
<li class="ignored"><code>        """Set of objects on which user haves can_change_permissions. !But only</code></li>
<li class="ignored"><code>        the ones on which is this assigned directly. For getting reall</code></li>
<li class="ignored"><code>        permissions use page.permissions manager.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.with_user(user).filter(can_change_permissions=True)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class PagePermissionManager(BasicPagePermissionManager):</code></li>
<li class="ignored"><code>    """Page permission manager accessible under objects.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="missed"><code>    def subordinate_to_user(self, user):</code></li>
<li class="ignored"><code>        """Get all page permission objects on which user/group is lover in</code></li>
<li class="ignored"><code>        hierarchy then given user and given user can change permissions on them.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        !IMPORTANT, but exclude objects with given user, or any group containing</code></li>
<li class="ignored"><code>        this user - he can't be able to change his own permissions, because if</code></li>
<li class="ignored"><code>        he does, and removes some permissions from himself, he will not be able</code></li>
<li class="ignored"><code>        to add them anymore.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Example:</code></li>
<li class="ignored"><code>                                       A</code></li>
<li class="ignored"><code>                                    /    \</code></li>
<li class="ignored"><code>                                  user    B,E</code></li>
<li class="ignored"><code>                                /     \</code></li>
<li class="ignored"><code>                              C,X     D,Y</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            Gives permission nodes C,X,D,Y under user, so he can edit</code></li>
<li class="ignored"><code>            permissions if he haves can_change_permission.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Example:</code></li>
<li class="ignored"><code>                                      A,Y</code></li>
<li class="ignored"><code>                                    /    \</code></li>
<li class="ignored"><code>                                  user    B,E,X</code></li>
<li class="ignored"><code>                                /     \</code></li>
<li class="ignored"><code>                              C,X     D,Y</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            Gives permission nodes C,D under user, so he can edit, but not</code></li>
<li class="ignored"><code>            anymore to X,Y, because this users are on the same level or higher</code></li>
<li class="ignored"><code>            in page hierarchy. (but only if user have can_change_permission)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Example:</code></li>
<li class="ignored"><code>                                        A</code></li>
<li class="ignored"><code>                                    /      \</code></li>
<li class="ignored"><code>                                  user     B,E</code></li>
<li class="ignored"><code>                                /     \      \</code></li>
<li class="ignored"><code>                              C,X     D,Y    user</code></li>
<li class="ignored"><code>                                            /    \</code></li>
<li class="ignored"><code>                                           I      J,A</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            User permissions can be assigned to multiple page nodes, so merge of</code></li>
<li class="ignored"><code>            all of them is required. In this case user can see permissions for</code></li>
<li class="ignored"><code>            users C,X,D,Y,I,J but not A, because A user in higher in hierarchy.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        If permission object holds group, this permission object can be visible</code></li>
<li class="ignored"><code>        to user only if all of the group members are lover in hierarchy. If any</code></li>
<li class="ignored"><code>        of members is higher then given user, this entry must stay invisible.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        If user is superuser, or haves global can_change_permission permissions,</code></li>
<li class="ignored"><code>        show him everything.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Result of this is used in admin for page permissions inline.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="excluded"><code>        from cms.models import GlobalPagePermission, Page</code></li>
<li class="missed"><code>        if user.is_superuser or \</code></li>
<li class="ignored"><code>            GlobalPagePermission.objects.with_can_change_permissions(user):</code></li>
<li class="ignored"><code>            # everything for those guys</code></li>
<li class="missed"><code>                return self.all()</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # get user level</code></li>
<li class="excluded"><code>        from cms.utils.permissions import get_user_permission_level</code></li>
<li class="missed"><code>        try:</code></li>
<li class="missed"><code>            user_level = get_user_permission_level(user)</code></li>
<li class="missed"><code>        except NoPermissionsException:</code></li>
<li class="missed"><code>            return self.none()</code></li>
<li class="ignored"><code>        # get current site</code></li>
<li class="missed"><code>        site = Site.objects.get_current()</code></li>
<li class="ignored"><code>        # get all permissions</code></li>
<li class="missed"><code>        page_id_allow_list = Page.permissions.get_change_permissions_id_list(user, site)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # get permission set, but without objects targeting user, or any group</code></li>
<li class="ignored"><code>        # in which he can be</code></li>
<li class="missed"><code>        qs = self.filter(</code></li>
<li class="ignored"><code>            page__id__in=page_id_allow_list,</code></li>
<li class="ignored"><code>            page__level__gte=user_level,</code></li>
<li class="ignored"><code>        )</code></li>
<li class="missed"><code>        qs = qs.exclude(user=user).exclude(group__user=user)</code></li>
<li class="missed"><code>        return qs</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def for_page(self, page):</code></li>
<li class="ignored"><code>        """Returns queryset containing all instances somehow connected to given</code></li>
<li class="ignored"><code>        page. This includes permissions to page itself and permissions inherited</code></li>
<li class="ignored"><code>        from higher pages.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        NOTE: this returns just PagePermission instances, to get complete access</code></li>
<li class="ignored"><code>        list merge return of this function with Global permissions.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="excluded"><code>        from cms.models import ACCESS_DESCENDANTS, ACCESS_CHILDREN,\</code></li>
<li class="ignored"><code>            ACCESS_PAGE_AND_CHILDREN, ACCESS_PAGE_AND_DESCENDANTS</code></li>
<li class="ignored"><code>        # code taken from</code></li>
<li class="ignored"><code>        # https://github.com/divio/django-cms/issues/1113#issuecomment-3376790</code></li>
<li class="missed"><code>        q_tree = Q(page__tree_id=page.tree_id)</code></li>
<li class="missed"><code>        q_page = Q(page=page)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # NOTE:  '... or 0' is used for test cases,</code></li>
<li class="ignored"><code>        #        if the page is not saved through mptt</code></li>
<li class="missed"><code>        left_right = {</code></li>
<li class="ignored"><code>              'page__%s__lte' % page._mptt_meta.left_attr: getattr(page, page._mptt_meta.left_attr) or 0,</code></li>
<li class="ignored"><code>              'page__%s__gte' % page._mptt_meta.right_attr: getattr(page, page._mptt_meta.right_attr) or 0,</code></li>
<li class="ignored"><code>        }</code></li>
<li class="missed"><code>        q_parents = Q(**left_right)</code></li>
<li class="missed"><code>        q_desc = (Q(page__level__lt=page.level) &amp; (Q(grant_on=ACCESS_DESCENDANTS) | Q(grant_on=ACCESS_PAGE_AND_DESCENDANTS)))</code></li>
<li class="missed"><code>        q_kids = (Q(page__level=page.level - 1) &amp; (Q(grant_on=ACCESS_CHILDREN) | Q(grant_on=ACCESS_PAGE_AND_CHILDREN)))</code></li>
<li class="missed"><code>        query = q_tree &amp; q_parents &amp; (q_page | q_desc | q_kids)</code></li>
<li class="missed"><code>        return self.filter(query).order_by('page__level')</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class PagePermissionsPermissionManager(models.Manager):</code></li>
<li class="ignored"><code>    """Page permissions permission manager.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    !IMPORTANT: this actually points to Page model, not to PagePermission.</code></li>
<li class="ignored"><code>    Seems this will be better approach. Accessible under permissions.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    Maybe this even shouldn't be a manager - it mixes different models together.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    # we will return this in case we have a superuser, or permissions are not</code></li>
<li class="ignored"><code>    # enabled/configured in settings</code></li>
<li class="missed"><code>    GRANT_ALL = 'All'</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_publish_id_list(self, user, site):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Give a list of page where the user has publish rights or the string "All" if</code></li>
<li class="ignored"><code>        the user has all rights.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.__get_id_list(user, site, "can_publish")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_change_id_list(self, user, site):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Give a list of page where the user has edit rights or the string "All" if</code></li>
<li class="ignored"><code>        the user has all rights.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.__get_id_list(user, site, "can_change")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_add_id_list(self, user, site):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Give a list of page where the user has add page rights or the string</code></li>
<li class="ignored"><code>        "All" if the user has all rights.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.__get_id_list(user, site, "can_add")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_delete_id_list(self, user, site):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Give a list of page where the user has delete rights or the string "All" if</code></li>
<li class="ignored"><code>        the user has all rights.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.__get_id_list(user, site, "can_delete")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_advanced_settings_id_list(self, user, site):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Give a list of page where the user can change advanced settings or the</code></li>
<li class="ignored"><code>        string "All" if the user has all rights.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.__get_id_list(user, site, "can_change_advanced_settings")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_change_permissions_id_list(self, user, site):</code></li>
<li class="ignored"><code>        """Give a list of page where the user can change permissions.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.__get_id_list(user, site, "can_change_permissions")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_move_page_id_list(self, user, site):</code></li>
<li class="ignored"><code>        """Give a list of pages which user can move.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.__get_id_list(user, site, "can_move_page")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_moderate_id_list(self, user, site):</code></li>
<li class="ignored"><code>        """Give a list of pages which user can moderate. If moderation isn't</code></li>
<li class="ignored"><code>        installed, nobody can moderate.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if not settings.CMS_MODERATOR:</code></li>
<li class="missed"><code>            return []</code></li>
<li class="missed"><code>        return self.__get_id_list(user, site, "can_moderate")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_view_id_list(self, user, site):</code></li>
<li class="ignored"><code>        """Give a list of pages which user can view.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        return self.__get_id_list(user, site, "can_view")</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    '''</code></li>
<li class="ignored"><code>    def get_change_list_id_list(self, user, site):</code></li>
<li class="ignored"><code>        """This is used just in admin now. Gives all ids where user haves can_edit</code></li>
<li class="ignored"><code>        and can_add merged together.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        There is for sure a better way how to do this over sql, need to be</code></li>
<li class="ignored"><code>        optimized...</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        can_change = self.get_change_id_list(user)</code></li>
<li class="ignored"><code>        can_add = self.get_add_id_list(user)</code></li>
<li class="ignored"><code>        if can_change is can_add:</code></li>
<li class="ignored"><code>            # GRANT_ALL case</code></li>
<li class="ignored"><code>            page_id_list = can_change</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="ignored"><code>            permission_set = filter(lambda i: not i is PagePermissionsPermissionManager.GRANT_ALL, [can_change, can_add])</code></li>
<li class="ignored"><code>            if len(permission_set) is 1:</code></li>
<li class="ignored"><code>                page_id_list = permission_set[0]</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="ignored"><code>                page_id_list = list(set(can_change).union(set(can_add)))</code></li>
<li class="ignored"><code>        return page_id_list</code></li>
<li class="ignored"><code>    '''</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def __get_id_list(self, user, site, attr):</code></li>
<li class="excluded"><code>        from cms.models import (GlobalPagePermission, PagePermission,</code></li>
<li class="ignored"><code>                                MASK_PAGE, MASK_CHILDREN, MASK_DESCENDANTS)</code></li>
<li class="missed"><code>        if attr != "can_view":</code></li>
<li class="missed"><code>            if not user.is_authenticated() or not user.is_staff:</code></li>
<li class="missed"><code>                return []</code></li>
<li class="missed"><code>        if user.is_superuser or not settings.CMS_PERMISSION:</code></li>
<li class="ignored"><code>            # got superuser, or permissions aren't enabled? just return grant</code></li>
<li class="ignored"><code>            # all mark</code></li>
<li class="missed"><code>            return PagePermissionsPermissionManager.GRANT_ALL</code></li>
<li class="ignored"><code>        # read from cache if posssible</code></li>
<li class="missed"><code>        cached = get_permission_cache(user, attr)</code></li>
<li class="missed"><code>        if cached is not None:</code></li>
<li class="missed"><code>            return cached</code></li>
<li class="ignored"><code>        # check global permissions</code></li>
<li class="missed"><code>        global_permissions = GlobalPagePermission.objects.with_user(user)</code></li>
<li class="missed"><code>        if global_permissions.filter(**{</code></li>
<li class="ignored"><code>                attr: True, 'sites__in': [site]</code></li>
<li class="ignored"><code>            }).exists():</code></li>
<li class="ignored"><code>            # user or his group are allowed to do `attr` action</code></li>
<li class="ignored"><code>            # !IMPORTANT: page permissions must not override global permissions</code></li>
<li class="missed"><code>            return PagePermissionsPermissionManager.GRANT_ALL</code></li>
<li class="ignored"><code>        # for standard users without global permissions, get all pages for him or</code></li>
<li class="ignored"><code>        # his group/s</code></li>
<li class="missed"><code>        qs = PagePermission.objects.with_user(user)</code></li>
<li class="missed"><code>        qs.order_by('page__tree_id', 'page__level', 'page__lft')</code></li>
<li class="ignored"><code>        # default is denny...</code></li>
<li class="missed"><code>        page_id_allow_list = []</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        for permission in qs:</code></li>
<li class="missed"><code>            if getattr(permission, attr):</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>                # can add is special - we are actually adding page under current page</code></li>
<li class="missed"><code>                if permission.grant_on &amp; MASK_PAGE or attr is "can_add":</code></li>
<li class="missed"><code>                    page_id_allow_list.append(permission.page.id)</code></li>
<li class="missed"><code>                if permission.grant_on &amp; MASK_CHILDREN and not attr is "can_add":</code></li>
<li class="missed"><code>                    page_id_allow_list.extend(permission.page.get_children().values_list('id', flat=True))</code></li>
<li class="missed"><code>                elif permission.grant_on &amp; MASK_DESCENDANTS:</code></li>
<li class="missed"><code>                    page_id_allow_list.extend(permission.page.get_descendants().values_list('id', flat=True))</code></li>
<li class="ignored"><code>        # store value in cache</code></li>
<li class="missed"><code>        set_permission_cache(user, attr, page_id_allow_list)</code></li>
<li class="missed"><code>        return page_id_allow_list</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class PageModeratorStateManager(models.Manager):</code></li>
<li class="missed"><code>    def get_delete_actions(self):</code></li>
<li class="excluded"><code>        from cms.models import PageModeratorState</code></li>
<li class="missed"><code>        return self.filter(action=PageModeratorState.ACTION_DELETE)</code></li>
  </ol>
</div>

<div class="nav">
  <a href="cms.models.fields.html">cms.models.fields</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="cms.models.metaclasses.html">cms.models.metaclasses</a>
</div>

  </body>
</html>

