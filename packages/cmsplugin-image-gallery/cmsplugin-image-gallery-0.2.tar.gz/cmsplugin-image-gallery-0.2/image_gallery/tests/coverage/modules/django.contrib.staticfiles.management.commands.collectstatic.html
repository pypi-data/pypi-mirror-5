<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <title>Test coverage report: django.contrib.staticfiles.management.commands.collectstatic</title>
    <style type="text/css" media="screen">
      a
      {
        color: #3d707a;
      }
      
      a:hover, a:active
      {
        color: #bf7d18;
      }
    
      body 
      {
        font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        font-size: 13px;
      }
      
      .nav 
      {
        font-size: 12px;
        margin-left: 50px;
      }

      .ignored
      {
        color: #707070;
      }

      .executed 
      {
        color: #3d9900;
      }

      .missed 
      {
        color: red;
        font-weight: bold;
      }

      .excluded 
      {
        color: #6090f0;
        font-weight: lighter;
      }
    
      #content-header 
      {
        font-size: 12px;
        padding: 18px 0 18px 50px;
      }

      #content-header h1 
      {
        font-size: 16px;
        margin: 10px 0 0 0;
        color: #909090;
      }
      
      #module-name
      {
        color: #583707;
      }
    
      #content-header p
      {
        font-size: 13px;
        margin: 0;
        color: #909090;
      }

      #content-header .normal 
      {
        color: #609030;
      }

      #content-header .warning 
      {
        color: #d0a000;
      }

      #content-header .critical 
      {
        color: red;
      }
      
      #source-listing 
      {
        margin-bottom: 24px;
      }

      #source-listing ol 
      {
        padding: 0 0 0 50px;
        width: 90%;
        font-family: monospace;
        list-style-position: outside;
      }

      #source-listing ol li 
      {
        line-height: 18px;
        font-size: small;
      }
        
      #source-listing ol code 
      {
        padding:  0 .001em 0 0; /* Firefox doesn't render empty li's properly */
        font-size: medium;
        white-space: pre;
      }
   </style>
  </head>

  <body>

<div class="nav">
  <a href="django.contrib.staticfiles.handlers.html">django.contrib.staticfiles.handlers</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="django.contrib.staticfiles.management.commands.findstatic.html">django.contrib.staticfiles.management.commands.findstatic</a>
</div>

<div id="content-header">
  <h1>
    <span id="module-name">django.contrib.staticfiles.management.commands.collectstatic</span>:
    164 total statements,
    <span class="critical">0.0% covered</span>
  </h1>
  <p>Generated: Wed 2013-03-13 10:33 CET</p>
  <p>Source file: /media/Envs/Envs/filer-gallery/lib/python2.7/site-packages/django/contrib/staticfiles/management/commands/collectstatic.py</p>
  <p>
    Stats:
    <span class="executed">0 executed</span>,
    <span class="missed">155 missed</span>,
    <span class="excluded">9 excluded</span>,
    <span class="ignored">141 ignored</span> 
  </p> 
</div>

<div id="source-listing">
  <ol>
    <li class="excluded"><code>from __future__ import with_statement</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>import os</code></li>
<li class="excluded"><code>import sys</code></li>
<li class="excluded"><code>from optparse import make_option</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>from django.core.files.storage import FileSystemStorage</code></li>
<li class="excluded"><code>from django.core.management.base import CommandError, NoArgsCommand</code></li>
<li class="excluded"><code>from django.utils.encoding import smart_str, smart_unicode</code></li>
<li class="excluded"><code>from django.utils.datastructures import SortedDict</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>from django.contrib.staticfiles import finders, storage</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class Command(NoArgsCommand):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Command that allows to copy or symlink static files from different</code></li>
<li class="ignored"><code>    locations to the settings.STATIC_ROOT.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="missed"><code>    option_list = NoArgsCommand.option_list + (</code></li>
<li class="ignored"><code>        make_option('--noinput',</code></li>
<li class="ignored"><code>            action='store_false', dest='interactive', default=True,</code></li>
<li class="ignored"><code>            help="Do NOT prompt the user for input of any kind."),</code></li>
<li class="ignored"><code>        make_option('--no-post-process',</code></li>
<li class="ignored"><code>            action='store_false', dest='post_process', default=True,</code></li>
<li class="ignored"><code>            help="Do NOT post process collected files."),</code></li>
<li class="ignored"><code>        make_option('-i', '--ignore', action='append', default=[],</code></li>
<li class="ignored"><code>            dest='ignore_patterns', metavar='PATTERN',</code></li>
<li class="ignored"><code>            help="Ignore files or directories matching this glob-style "</code></li>
<li class="ignored"><code>                "pattern. Use multiple times to ignore more."),</code></li>
<li class="ignored"><code>        make_option('-n', '--dry-run',</code></li>
<li class="ignored"><code>            action='store_true', dest='dry_run', default=False,</code></li>
<li class="ignored"><code>            help="Do everything except modify the filesystem."),</code></li>
<li class="ignored"><code>        make_option('-c', '--clear',</code></li>
<li class="ignored"><code>            action='store_true', dest='clear', default=False,</code></li>
<li class="ignored"><code>            help="Clear the existing files using the storage "</code></li>
<li class="ignored"><code>                 "before trying to copy or link the original file."),</code></li>
<li class="ignored"><code>        make_option('-l', '--link',</code></li>
<li class="ignored"><code>            action='store_true', dest='link', default=False,</code></li>
<li class="ignored"><code>            help="Create a symbolic link to each file instead of copying."),</code></li>
<li class="ignored"><code>        make_option('--no-default-ignore', action='store_false',</code></li>
<li class="ignored"><code>            dest='use_default_ignore_patterns', default=True,</code></li>
<li class="ignored"><code>            help="Don't ignore the common private glob-style patterns 'CVS', "</code></li>
<li class="ignored"><code>                "'.*' and '*~'."),</code></li>
<li class="ignored"><code>    )</code></li>
<li class="missed"><code>    help = "Collect static files in a single location."</code></li>
<li class="missed"><code>    requires_model_validation = False</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def __init__(self, *args, **kwargs):</code></li>
<li class="missed"><code>        super(NoArgsCommand, self).__init__(*args, **kwargs)</code></li>
<li class="missed"><code>        self.copied_files = []</code></li>
<li class="missed"><code>        self.symlinked_files = []</code></li>
<li class="missed"><code>        self.unmodified_files = []</code></li>
<li class="missed"><code>        self.post_processed_files = []</code></li>
<li class="missed"><code>        self.storage = storage.staticfiles_storage</code></li>
<li class="missed"><code>        try:</code></li>
<li class="missed"><code>            self.storage.path('')</code></li>
<li class="missed"><code>        except NotImplementedError:</code></li>
<li class="missed"><code>            self.local = False</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            self.local = True</code></li>
<li class="ignored"><code>        # Use ints for file times (ticket #14665), if supported</code></li>
<li class="missed"><code>        if hasattr(os, 'stat_float_times'):</code></li>
<li class="missed"><code>            os.stat_float_times(False)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def set_options(self, **options):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Set instance variables based on an options dict</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        self.interactive = options['interactive']</code></li>
<li class="missed"><code>        self.verbosity = int(options.get('verbosity', 1))</code></li>
<li class="missed"><code>        self.symlink = options['link']</code></li>
<li class="missed"><code>        self.clear = options['clear']</code></li>
<li class="missed"><code>        self.dry_run = options['dry_run']</code></li>
<li class="missed"><code>        ignore_patterns = options['ignore_patterns']</code></li>
<li class="missed"><code>        if options['use_default_ignore_patterns']:</code></li>
<li class="missed"><code>            ignore_patterns += ['CVS', '.*', '*~']</code></li>
<li class="missed"><code>        self.ignore_patterns = list(set(ignore_patterns))</code></li>
<li class="missed"><code>        self.post_process = options['post_process']</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def collect(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Perform the bulk of the work of collectstatic.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Split off from handle_noargs() to facilitate testing.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if self.symlink:</code></li>
<li class="missed"><code>            if sys.platform == 'win32':</code></li>
<li class="missed"><code>                raise CommandError("Symlinking is not supported by this "</code></li>
<li class="ignored"><code>                                   "platform (%s)." % sys.platform)</code></li>
<li class="missed"><code>            if not self.local:</code></li>
<li class="missed"><code>                raise CommandError("Can't symlink to a remote destination.")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if self.clear:</code></li>
<li class="missed"><code>            self.clear_dir('')</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if self.symlink:</code></li>
<li class="missed"><code>            handler = self.link_file</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            handler = self.copy_file</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        found_files = SortedDict()</code></li>
<li class="missed"><code>        for finder in finders.get_finders():</code></li>
<li class="missed"><code>            for path, storage in finder.list(self.ignore_patterns):</code></li>
<li class="ignored"><code>                # Prefix the relative path if the source storage contains it</code></li>
<li class="missed"><code>                if getattr(storage, 'prefix', None):</code></li>
<li class="missed"><code>                    prefixed_path = os.path.join(storage.prefix, path)</code></li>
<li class="ignored"><code>                else:</code></li>
<li class="missed"><code>                    prefixed_path = path</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>                if prefixed_path not in found_files:</code></li>
<li class="missed"><code>                    found_files[prefixed_path] = (storage, path)</code></li>
<li class="missed"><code>                    handler(path, prefixed_path, storage)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Here we check if the storage backend has a post_process</code></li>
<li class="ignored"><code>        # method and pass it the list of modified files.</code></li>
<li class="missed"><code>        if self.post_process and hasattr(self.storage, 'post_process'):</code></li>
<li class="missed"><code>            processor = self.storage.post_process(found_files,</code></li>
<li class="ignored"><code>                                                  dry_run=self.dry_run)</code></li>
<li class="missed"><code>            for original_path, processed_path, processed in processor:</code></li>
<li class="missed"><code>                if processed:</code></li>
<li class="missed"><code>                    self.log(u"Post-processed '%s' as '%s" %</code></li>
<li class="ignored"><code>                             (original_path, processed_path), level=1)</code></li>
<li class="missed"><code>                    self.post_processed_files.append(original_path)</code></li>
<li class="ignored"><code>                else:</code></li>
<li class="missed"><code>                    self.log(u"Skipped post-processing '%s'" % original_path)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        return {</code></li>
<li class="ignored"><code>            'modified': self.copied_files + self.symlinked_files,</code></li>
<li class="ignored"><code>            'unmodified': self.unmodified_files,</code></li>
<li class="ignored"><code>            'post_processed': self.post_processed_files,</code></li>
<li class="ignored"><code>        }</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def handle_noargs(self, **options):</code></li>
<li class="missed"><code>        self.set_options(**options)</code></li>
<li class="ignored"><code>        # Warn before doing anything more.</code></li>
<li class="missed"><code>        if (isinstance(self.storage, FileSystemStorage) and</code></li>
<li class="ignored"><code>                self.storage.location):</code></li>
<li class="missed"><code>            destination_path = self.storage.location</code></li>
<li class="missed"><code>            destination_display = ':\n\n    %s' % destination_path</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            destination_path = None</code></li>
<li class="missed"><code>            destination_display = '.'</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if self.clear:</code></li>
<li class="missed"><code>            clear_display = 'This will DELETE EXISTING FILES!'</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            clear_display = 'This will overwrite existing files!'</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if self.interactive:</code></li>
<li class="missed"><code>            confirm = raw_input(u"""</code></li>
<li class="ignored"><code>You have requested to collect static files at the destination</code></li>
<li class="ignored"><code>location as specified in your settings%s</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>%s</code></li>
<li class="ignored"><code>Are you sure you want to do this?</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>Type 'yes' to continue, or 'no' to cancel: """</code></li>
<li class="ignored"><code>% (destination_display, clear_display))</code></li>
<li class="missed"><code>            if confirm != 'yes':</code></li>
<li class="missed"><code>                raise CommandError("Collecting static files cancelled.")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        collected = self.collect()</code></li>
<li class="missed"><code>        modified_count = len(collected['modified'])</code></li>
<li class="missed"><code>        unmodified_count = len(collected['unmodified'])</code></li>
<li class="missed"><code>        post_processed_count = len(collected['post_processed'])</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if self.verbosity &gt;= 1:</code></li>
<li class="missed"><code>            template = ("\n%(modified_count)s %(identifier)s %(action)s"</code></li>
<li class="ignored"><code>                        "%(destination)s%(unmodified)s%(post_processed)s.\n")</code></li>
<li class="missed"><code>            summary = template % {</code></li>
<li class="ignored"><code>                'modified_count': modified_count,</code></li>
<li class="ignored"><code>                'identifier': 'static file' + (modified_count != 1 and 's' or ''),</code></li>
<li class="ignored"><code>                'action': self.symlink and 'symlinked' or 'copied',</code></li>
<li class="ignored"><code>                'destination': (destination_path and " to '%s'"</code></li>
<li class="ignored"><code>                                % destination_path or ''),</code></li>
<li class="ignored"><code>                'unmodified': (collected['unmodified'] and ', %s unmodified'</code></li>
<li class="ignored"><code>                               % unmodified_count or ''),</code></li>
<li class="ignored"><code>                'post_processed': (collected['post_processed'] and</code></li>
<li class="ignored"><code>                                   ', %s post-processed'</code></li>
<li class="ignored"><code>                                   % post_processed_count or ''),</code></li>
<li class="ignored"><code>            }</code></li>
<li class="missed"><code>            self.stdout.write(smart_str(summary))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def log(self, msg, level=2):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Small log helper</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        msg = smart_str(msg)</code></li>
<li class="missed"><code>        if not msg.endswith("\n"):</code></li>
<li class="missed"><code>            msg += "\n"</code></li>
<li class="missed"><code>        if self.verbosity &gt;= level:</code></li>
<li class="missed"><code>            self.stdout.write(msg)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def clear_dir(self, path):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Deletes the given relative path using the destinatin storage backend.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        dirs, files = self.storage.listdir(path)</code></li>
<li class="missed"><code>        for f in files:</code></li>
<li class="missed"><code>            fpath = os.path.join(path, f)</code></li>
<li class="missed"><code>            if self.dry_run:</code></li>
<li class="missed"><code>                self.log(u"Pretending to delete '%s'" %</code></li>
<li class="ignored"><code>                         smart_unicode(fpath), level=1)</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                self.log(u"Deleting '%s'" % smart_unicode(fpath), level=1)</code></li>
<li class="missed"><code>                self.storage.delete(fpath)</code></li>
<li class="missed"><code>        for d in dirs:</code></li>
<li class="missed"><code>            self.clear_dir(os.path.join(path, d))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def delete_file(self, path, prefixed_path, source_storage):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Checks if the target file should be deleted if it already exists</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if self.storage.exists(prefixed_path):</code></li>
<li class="missed"><code>            try:</code></li>
<li class="ignored"><code>                # When was the target file modified last time?</code></li>
<li class="missed"><code>                target_last_modified = \</code></li>
<li class="ignored"><code>                    self.storage.modified_time(prefixed_path)</code></li>
<li class="missed"><code>            except (OSError, NotImplementedError, AttributeError):</code></li>
<li class="ignored"><code>                # The storage doesn't support ``modified_time`` or failed</code></li>
<li class="missed"><code>                pass</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                try:</code></li>
<li class="ignored"><code>                    # When was the source file modified last time?</code></li>
<li class="missed"><code>                    source_last_modified = source_storage.modified_time(path)</code></li>
<li class="missed"><code>                except (OSError, NotImplementedError, AttributeError):</code></li>
<li class="missed"><code>                    pass</code></li>
<li class="ignored"><code>                else:</code></li>
<li class="ignored"><code>                    # The full path of the target file</code></li>
<li class="missed"><code>                    if self.local:</code></li>
<li class="missed"><code>                        full_path = self.storage.path(prefixed_path)</code></li>
<li class="ignored"><code>                    else:</code></li>
<li class="missed"><code>                        full_path = None</code></li>
<li class="ignored"><code>                    # Skip the file if the source file is younger</code></li>
<li class="missed"><code>                    if target_last_modified &gt;= source_last_modified:</code></li>
<li class="missed"><code>                        if not ((self.symlink and full_path</code></li>
<li class="ignored"><code>                                 and not os.path.islink(full_path)) or</code></li>
<li class="ignored"><code>                                (not self.symlink and full_path</code></li>
<li class="ignored"><code>                                 and os.path.islink(full_path))):</code></li>
<li class="missed"><code>                            if prefixed_path not in self.unmodified_files:</code></li>
<li class="missed"><code>                                self.unmodified_files.append(prefixed_path)</code></li>
<li class="missed"><code>                            self.log(u"Skipping '%s' (not modified)" % path)</code></li>
<li class="missed"><code>                            return False</code></li>
<li class="ignored"><code>            # Then delete the existing file if really needed</code></li>
<li class="missed"><code>            if self.dry_run:</code></li>
<li class="missed"><code>                self.log(u"Pretending to delete '%s'" % path)</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                self.log(u"Deleting '%s'" % path)</code></li>
<li class="missed"><code>                self.storage.delete(prefixed_path)</code></li>
<li class="missed"><code>        return True</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def link_file(self, path, prefixed_path, source_storage):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Attempt to link ``path``</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        # Skip this file if it was already copied earlier</code></li>
<li class="missed"><code>        if prefixed_path in self.symlinked_files:</code></li>
<li class="missed"><code>            return self.log(u"Skipping '%s' (already linked earlier)" % path)</code></li>
<li class="ignored"><code>        # Delete the target file if needed or break</code></li>
<li class="missed"><code>        if not self.delete_file(path, prefixed_path, source_storage):</code></li>
<li class="missed"><code>            return</code></li>
<li class="ignored"><code>        # The full path of the source file</code></li>
<li class="missed"><code>        source_path = source_storage.path(path)</code></li>
<li class="ignored"><code>        # Finally link the file</code></li>
<li class="missed"><code>        if self.dry_run:</code></li>
<li class="missed"><code>            self.log(u"Pretending to link '%s'" % source_path, level=1)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            self.log(u"Linking '%s'" % source_path, level=1)</code></li>
<li class="missed"><code>            full_path = self.storage.path(prefixed_path)</code></li>
<li class="missed"><code>            try:</code></li>
<li class="missed"><code>                os.makedirs(os.path.dirname(full_path))</code></li>
<li class="missed"><code>            except OSError:</code></li>
<li class="missed"><code>                pass</code></li>
<li class="missed"><code>            os.symlink(source_path, full_path)</code></li>
<li class="missed"><code>        if prefixed_path not in self.symlinked_files:</code></li>
<li class="missed"><code>            self.symlinked_files.append(prefixed_path)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def copy_file(self, path, prefixed_path, source_storage):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Attempt to copy ``path`` with storage</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        # Skip this file if it was already copied earlier</code></li>
<li class="missed"><code>        if prefixed_path in self.copied_files:</code></li>
<li class="missed"><code>            return self.log(u"Skipping '%s' (already copied earlier)" % path)</code></li>
<li class="ignored"><code>        # Delete the target file if needed or break</code></li>
<li class="missed"><code>        if not self.delete_file(path, prefixed_path, source_storage):</code></li>
<li class="missed"><code>            return</code></li>
<li class="ignored"><code>        # The full path of the source file</code></li>
<li class="missed"><code>        source_path = source_storage.path(path)</code></li>
<li class="ignored"><code>        # Finally start copying</code></li>
<li class="missed"><code>        if self.dry_run:</code></li>
<li class="missed"><code>            self.log(u"Pretending to copy '%s'" % source_path, level=1)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            self.log(u"Copying '%s'" % source_path, level=1)</code></li>
<li class="missed"><code>            if self.local:</code></li>
<li class="missed"><code>                full_path = self.storage.path(prefixed_path)</code></li>
<li class="missed"><code>                try:</code></li>
<li class="missed"><code>                    os.makedirs(os.path.dirname(full_path))</code></li>
<li class="missed"><code>                except OSError:</code></li>
<li class="missed"><code>                    pass</code></li>
<li class="missed"><code>            with source_storage.open(path) as source_file:</code></li>
<li class="missed"><code>                self.storage.save(prefixed_path, source_file)</code></li>
<li class="missed"><code>        if not prefixed_path in self.copied_files:</code></li>
<li class="missed"><code>            self.copied_files.append(prefixed_path)</code></li>
  </ol>
</div>

<div class="nav">
  <a href="django.contrib.staticfiles.handlers.html">django.contrib.staticfiles.handlers</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="django.contrib.staticfiles.management.commands.findstatic.html">django.contrib.staticfiles.management.commands.findstatic</a>
</div>

  </body>
</html>

