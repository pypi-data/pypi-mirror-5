'''
collection of tools that facilitate the testing of pylabs3 based code
'''
import mock
import functools
import os
import sys
import imp


class MockNotFound(Exception):
    pass


class ModuleProxy(object):
    '''
    Represents a component in the q.foo.bar chain
    '''
    def __init__(self, path, calls):
        self.path = path
        self.calls = calls

    def __getattr__(self, attr):
        new_path = self.path + [attr]
        full_path = '.'.join(new_path)
        if full_path in self.calls:
            call = self.calls[full_path]
            if call.q_as_first_arg:  # some mocks need the q context
                # create a new q stub with the calls
                call = functools.partial(call, ModuleProxy(['q'], self.calls))
            return call
        elif any(x.startswith(full_path) for x in self.calls):
            return ModuleProxy(new_path, self.calls)
        else:
            raise MockNotFound('%s does not exist' % full_path)


def q_call(call_path, *args, **kwargs):
    '''
    Generates a new q function mock

    call_path: full q.foo.bar path (string)
    custom_mock: override the normal mock generation with a custom mock object
    q_as_first_arg: inject the full q root object as the first function argument
    args, kwargs: arguments to the instantiated Mock() object
    '''
    default_mock = mock.Mock(*args, **kwargs)
    call_mock = kwargs.get('custom_mock', default_mock)
    call_mock.q_as_first_arg = kwargs.get('q_as_first_arg', False)
    return call_path, call_mock


def q_mock(*calls):
    '''
    Instantiates the q mock object with all the mocked calls

    calls: list of ('q.foo.bar', mock) tuples generated by q_call
    '''
    return ModuleProxy(['q'], dict(calls))


def locally_execute_rscript(q, agentguid, scriptname, params, executionparams):
    '''
    Mocks the executeActorActionScript behaviour

    Note that this code assumes the rscript dir to be relative to the caller file path.
    It tries to execute the script with path <calling_source_file_dir>/scripts/<scriptname>.rscript
    For more parameter info, consult the executeActorActionScript docstring
    '''
    calling_frame = sys._getframe(1)
    calling_file_path = calling_frame.f_code.co_filename

    script_path = os.path.join(os.path.dirname(calling_file_path),
                               'scripts', scriptname + '.rscript')
    script_globals = {
        'params': params,
        'q': q
    }
    execfile(script_path, script_globals)
    return params


def import_qpackage_src(qpackage_name, platform, relative_path, module_name):
    '''
    Imports a qpackage source file

    The script finds the base test directory that contains all test subdirs
    and and imports qpackage sources relative to this test folder.
    The function returns the imported module object

    qpackage_name: name of the qpackage
    platform: platform dir that contains the source files, typically generic/linux
    relative path: relative path from <qpackage_name>/qpackage4/<platform> to the source file
    module_name: name of the module/source file to import
    '''
    calling_frame = sys._getframe(1)
    calling_file_path = calling_frame.f_code.co_filename
    calling_dir_path = os.path.dirname(calling_file_path)

    descend_path = calling_dir_path
    descend_count = 0
    test_dir_found = False

    # descend tree until we find a test package dir
    while descend_path:
        # check if dir is still a package
        if not os.path.isfile(os.path.join(descend_path, '__init__.py')):
            raise ImportError('path %s is not a package dir' % descend_path)
        descend_path, _, current_dir = descend_path.rpartition(os.path.sep)
        descend_count += 1
        if current_dir == 'test':
            test_dir_found = True
            break
    if not test_dir_found:
        raise ImportError('can\'t find test root dir')

    base_dir_components = [calling_dir_path] + ['..'] * descend_count
    base_dir = os.path.abspath(os.path.join(*base_dir_components))

    src_path = os.path.join(base_dir, 'qpackage4', qpackage_name, platform,
                            relative_path.replace('.', os.path.sep),
                            module_name + '.py')
    return imp.load_source(module_name, src_path)
