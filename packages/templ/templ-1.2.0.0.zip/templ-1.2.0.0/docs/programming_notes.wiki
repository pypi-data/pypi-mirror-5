Note that there are *no mutable values* in templ. Strings, Lists, and...well that's actually about it,
are all immutable. Operations on them, like slice, splice, append, substr, etc., all just create new objects.

== Design Decisions ==
     _Or: Why I did some of the things I did_
     
=== Void ===

I only let void except at most one expression because otherwise I have to deal with Returns and stuff.
I already have that in {:} and {::}. 

=== Vota ($$) ===

Why not use {$$$} for something like a double lookup, like {$$$$ X} = {$$$ {$$ X}}. Because how often does that
really come up? This seemed pretty reasonable.


== Exectuables ==

Executables that implicitely create new variables should only create variables in the local scope and should
prefix them with ":", like the ":args" variable when userfuncs are executed. If a user provides names for
them, then it is generally considered explicit and you can (probably should) use the names they give you,
don't need to prefix with ":" or anything. When users are giving such names, they should not use the ":"
prefix.

=== built-in executables ===

For argument count checking, it is preferred to use the `exact` parameter if there are no more than 4 possible
argument counts allowed. If you have more than that, `min` and `max` preferred when it makes sense.

It is preferred to check the number of arguments first, and raise that error before anything else. Then, it is
preferred to do all up-front checking on arguments one at a time in order given (low index to high index). In
other words, we don't want to see any error for argument 2, fix that, and then find out there's an error with
argument 1. It's annoying.


 vim: set tw=110:
