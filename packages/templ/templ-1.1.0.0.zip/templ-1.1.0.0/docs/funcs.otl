Templ Executables

Control Structures
	Loops
		x {for NAME INTHIS [IF] DO}
			Aliases: "for.loop"
			: Loops over the values in list `INTHIS`. Before iterating, a new
			: scope is pushed to the stack. For each iteration, the symbol
			: named by `NAME` is assigned the next value from `INTHIS`, and
			: then the expression `IF` is evaluated: if the result is the
			: String "0", then this iteration is skipped, but the loop is
			: *not* aborted. Otherwise, this iteration is performed by
			: evaluating the expression `DO`.
			: 
			: The resulting value is the result of the last evaluation of
			: `DO`. If any evaluations of `DO` is a Return value, the loop is
			: aborted (no further iterations are performed) and the Return
			: value is stripped to give the result.
		x {gen NAME INTHIS [IF] DO}
			Aliases: "for.gen"
			: Runs like a `for` loop but a list is built from the results of
			: each evaluation of `DO`. It's a list comprehension.
		x {while TEST DO}
			Aliases: "while.loop"
			: A simple loop. For each iteration, evaluates the expression
			: `TEST`: if it's equal to "1" then we perform the iteration by
			: evaluating `DO`, otherwise we abort the loop.
			:
			: A new scope is pushed before any iterations, and opped before
			: returning.
			:
			: The resulting value is the result of the last evaluation of
			: `DO`. If any evaluations of `DO` is a Return value, the loop is
			: aborted (no further iterations are performed) and the Return
			: value is stripped to give the result.
		x {gen-while TEST DO}
			Aliases: "while.gen"
			:Like `gen`, but uses the WHILE loop setup instead of FOR loop.
		x {loop [[INIT] [TEST] [POST]] DO}
			Aliases: "loop.loop"
			:{loop [INIT] [TEST] [POST] DO}
			:{loop [INIT] TEST [POST] DO}
			:{loop [INIT] TEST POST DO}
			:
			:Works like a C-style for loop: it pushes a new scope to the stack, then evaluates INIT.
			:Then it begins to loop: at the start of the loop, it evaluates TEST: if that evaluates to "0",
			:it's done, otherwise it evaluates DO, then evaluates POST, then does the next iteration of the
			:loop, starting with evaluation of TEST again.
			:
			:With three argument, INIT is not used. With two arguments, neither INIT nor POST are used.
			:With only one argument, only DO is used, so it just keeps going until DO evaluates to a RETURN.
			:
			:The resulting value is the result of the last evaluation of
			:`DO`. If any evaluations of `DO` is a Return value, the loop is
			:aborted (no further iterations are performed) and the Return
			:value is stripped to give the result.
		x {gen-loop [[INIT] [TEST] [POST]] DO}
			Aliases: "loop.gen"
			:Like `gen`, but uses the LOOP loop setup instead of FOR loop.
    """
	Conditionals
		x {if IF0 THEN0 [IF1 THEN1 [IF 2 THEN2 [...]]] [ELSE] }
			: Operator for conditional execution. Evalutes each of the IF
			: expressions one at a time. The first that evaluates to anything
			: other than "0" has it's corresponding (subsequent) THEN
			: expression evaluated, and the result of that eval is the result
			: of the `if` expression. If all of the IFs evaluate to "0", then
			: the ELSE is evaluated and the result is the result of this.
			:
			: If nothing is evaluated, result is Null.
	Misc
		x {dont [...]}
			Aliases: "#", "syn", "syntax", "rem"
			: Doesn't do anything, but must be wellformed.
			: The syn and syntax aliasesare meant for use with syntax
			: highlighting engines, like VIM.
		x {return [VAL]}
			:Returns a new Return object, wrapping VAL if given, other with
			:NULL.
		x {unret RET}
			: Unwraps a Return value, resulting in the value that the Return
			: value wraps.
	Errors
		x {try EXPR [CATCH [NAME]]}
			: Evaluates EXPR, but if any errors occur, they are trapped. If
			: CATCH is given, it is evaluated as an EXPR if and only if an
			: error occurs. A new scope is pushed before execution and popped
			: afterwards. If NAME is given, the error value is assigned to
			: a symbol name NAME in this new scope, before evaluating CATCH.
		x {error [VAL]}
			: Raises an error with error value VAL. If nothing catches it, it
			: results in an error and execution is terminated. If VAL isn't
			: given, default is NULL.
	Execution
		x {scope [EXPR0 [EXPR1 [...]]]}
			Aliases: "::"
			Qualified name: "exp.scope"
			: Executes each EXPRn one at a time, resulting value is the resulting
			: value of the last expression executed. If any value results in a
			: Return object, no further statements are executed. The return object
			: itself is still the resulting value, it is not unwrapped.
			:
			: Execution occurs in a new scope which is popped before the
			: expressino concludes.
		x {exec LIST}
			Qualified name: "pck.scope"
			:Same as scope, but the expressesion are packed into a list, which
			:means this is *not* an operator, this is a function.
		x {block [EXPR0 [EXPR1 [...]]]}
			Aliases ":"
			:Like scope except that a new scope is NOT created.
		x {exec-block LIST}
			Qualified name: "pck.block"
			:Same as block, but the expressions are packed into a list.
		x {call EXE [ARGS]}
			Qualified name: pck.call
			:Resolves executable EXE then invokes it passing the List ARGS as
			:arguments. Default ARGS is empty list.
		x {invoke EXE [ARG0 [ARG1 [...]]]}
			Qualified name: exp.call
			:Same as call, but arguments are unpacked.

Definition Functions
	x {lambda [ARGNAMES] EXPR [DOC]}
		:Defines a new anonymous user function. When executed, EXPR is
		:evaluated in a new scope, and the result is the result of the
		:function. Before EXPR is evaluated, any arguments passed into the
		:execution are stored as a list at a new symbol in the scope called ":argv".
		:Additionally, if ARGNAMES is given, it's an array of symbols and the
		:passed in args are unpacked into those names in the new scope.
		:Arguments that are named but not passed in are not defined, args that
		:are provided by not named are only accessible through ":argv".

String Functions
	: Negative indices are acceptable.
	x {chr VAL}
		: Returns one String of one character, the character has a numerical
		: value given by `VAL`.
	x {ord CHAR}
		: Returns a String representing the integer value of the single
		: character CHAR. CHAR must be a String, and must have exactly one
		: character, otherwise you get an exception. You can use `ord-1`
		: instead.
	x {ord-1 CHAR}
		: Same as ord, but doesn't care if CHAR has more than one character
		: or not, it just gives the ORD of the first character.
	x {implode [GLUE] LIST}
		Aliases: "imp"
		Aliases: "pck.join"	as in "packed" because the args are packed into a list.
		: Default GLUE is empty string. Returns a string with all the elements
		: of LIST (which must all be Strings) glued together by GLUE
	x {join GLUE [VAL0 [VAL1 [...]]])
		Possible Alias: ">*<"
		Aliases: "exp.join" as in "expanded" because the args are not packed into a list.
		: Like implode, but the values are unpacked instead of in a list.
	x {glue [VAL0 [VAL1 [...]]])
		Possible Alias: "><"
		Qualified name: str.cat
		: macro alias for {join "" ... }
	x {echo [VAL0 [VAL1 [...]]]}
		Aliases: "exp.echo"
		: All arguments must be strings, joins them together with an empty
		: string, and prints them to outstream.
	x {spit LIST}
		Aliases: "pck.echo"
		: Macro alias for {echo {implode "" LIST}}. Like echo, but args are
		: packed.
	x {str VAL}
		Qualified name: str.new
		: Converts VAL to a String form, regardless of it's Type.
	x {substr FIRST [END] STRING}
		Qualified name: str.slice
		: Returns a substring of `STRING` starting with index `FIRST` and
		: ending immediately before index `END`, or the end of the string
		: whichever comes first. Not an error if `END` runs past the end of the
		: string. If it does not run past, then the length of the string is
		: END - FIRST. If FIRST is not less than END, then it is an empty string.
		: 
		: Negative indices are valid, they specify distances from the end of the
		: string, so -1 is the last character. I.e., if FIRST is -1 and END is
		: unspecified, it will return the last character of the string.
		: 
		: END can also be the special string "END" (case sensitive), as an
		: alternative to not specifying it. In otherwords, that means it will
		: go all the way to the end.
	x {char-at INDEX STRING}
		Qualified name: str.at
		: Macro alias for {substr INDEX INDEX+1 STRING}
	x {strpos NEEDLE [START [END]] HAYSTACK}
		Qualified name: str.find
		: Searches for the index of the first occurrence of NEEDLE in
		: HAYSTACK, starting no SOONER than START and ending *before* END. If
		: three args given, END is defualt. Default START is 0, Default END is
		: to search the length of the string (search all the way to the end).
		: Returns Null if not found, otherwise a *positive* index into
		: HAYSTACK.
		:
		: The special value "END" (case sensitive) is acceptable for the `END` argument.
		: See `substr` for details.
	x {in-str NEEDLE [START] [END] HAYSTACK}
		Qualified name: str.in
		:Macro alias for {not {is-null {strpos NEEDLE START END HAYSTACK}}}.
	x {str.reverse STRING}
		:Returns a new String with is the reverse of the given `STRING`.
	x {to-lower STRING}
		Qualified name: str.lower
		: Returns a copy of STRING with all character replaced by lower-case
		: versions.
	x {to-upper STRING}
		Qualified name: str.upper
		: Returns a copy of STRING with all character replaced by upper-case
		: versions.
	x {strlen STRING}
		Qualified name: str.len
		:Returns the number of characters in STRING.

List Functions:
	x {flatten LIST}
		Qualified name: list.flatten
		: returns flattened version of the list: when a nested list is found,
		: it is flattened and the flattened version is expanded to take it's
		: place. Empty lists end up removed.
	x {find NEEDLE [START] [END] HAYSTACK}
		Qualified name: list.find
		: Finds the index into HAYSTACK of the first occurence of something
		: equal to the value NEEDLE, which can be any type. START and END are
		: as with strpos. Returns Null if not found.
	x {in NEEDLE [START] [END] HAYSTACK}
		Qualified name: list.in
		: Macro alias for {not {is-null {find NEEDLE START END HAYSTACK}}}.
	x {reverse LIST}
		Qualified name: list.reverse
		: Returns a copy of LIST in the opposite order.
	x {implode ...}
		See under String functions
	x {list [VAL0 [VAL1 [...]]]}
		Qualified name: list.new
		Alias: "'"
	x {chars STRING}
		Qualified name: str.list
		: Returns a new list whose elements are individual characters of
		: STRING.
	x {cat [LIST0 [LIST1 [...]]]}
		Qualified name: list.cat
		: REturns a new list consisting of all the given lists strung
		: together. With no args, results in an empty list.
	x {at IDX LIST}
		Qualified name: list.at
		Aliases: "@"
		:Returns the element at index IDX in LIST. Error if IDX is out of
		:bounds. Note that unlike `char-at`, an out of bounds negative index
		:here will cause an error, because this isn't a macro expansion for
		:slice.
	x {slice FIRST [END] LIST}
		Qualified name: list.slice
		:Returns a new List with the specified elements of List. Starts at
		:FIRST, ends right before END. If END isn't given, it's the length of
		:the list. Not an error for END to go past the end of the list, it
		:just truncates.
	x {len LIST}
		Qualified name: "list.len"
		:Returns the number of elements in List LIST.
	x {empty LIST}
		Aliases: "mt", "is-empty", "list.empty"
		:True if LIST has 0 elements in it. This is a question, not a
		:constructor. You might be looking for `nil`.
	x {nil}
		Qualified name: "list.nil"
		:Creates a new empty array. This is a macro expansion of {' }.
	x {range [START] STOP [STEP]}
		:Produces a List consisting of numeric values starting with START, incrementing by STEP,
		:and ending before getting to STOP. Default START is 0, default STEP is 1. If any values
		:are floats, the resulting elements are floats.
		:One argument works as  {range 0 STOP 1}.
		:Two arguments works as {range START STOP 1}.
	x {insert VAL [IDX] LIST}
		Qualified name: "list.insert"
		:returns a new list which is the same as LIST except that it has a new
		:value VAL inserted so that it is at index IDX. The value that used to
		:be at index IDX, and all values are higher indicies, are moved up by
		:one index. If IDX isn't given, default is 0 (front of the list).
		:
		:Special value END is allowed for IDX, then it works like append.
	x {splice THIS [IDX] INTO}
		Qualified name: "list.splice"
		:Like insert, except in this case THIS is a List of items which are
		:all inserted into the target list `INTO`.
		:
		:Special value END is allowed for IDX, then it works like cat but with
		:arguments in reverse order.
	x {append VAL LIST}
		Qualified name: "list.append"
		: Returns a new list that is the same as LIST but with VAL attached as
		: a new element to the end.
		: Note that the splice equivalent of append is cat, except the args
		: are in a different order.
	x {getf LABEL LIST}
		Qualified name: plist.get
		:Returns the element in LIST immediately following the element which
		:is equal to LABEL. Error if no LABEL is not found in LIST, or if
		:there is no element following it.
	x {idxf LABEL PLIST}
		Qualified name: plist.idx
		: Returns the numerical index into the given plist of the field with
		: the given label. This is the index of the *value*, not the label.
		: The label is always at the previous index.
		:
		: If not found, returns None.
	x {hasf LABEL LIST}
		Qualified name: plist.has
		:Determines if LABEL exists in the given LIST and is NOT the last
		:element of the list. I.e., whether or not LABEL will work in a call
		:to getf.
	x {plist.find VALUE PLIST}
		: Finds the index into PLIST of the first occurence of something
		: equal to VALUE , which can be any type. Note this is only checking
		: values, not fields (i.e., only the even indices), and returns the
		: index of that value. The label for the field is always at the
		: previous index.
		:
		: If not found, returns None.
	x {plist.in VALUE PLIST}
		Qualified name: plist.in
		: Macro alias for {not {is-null {plist.find VALUE PLIST}}}.
	x {plist.len PLIST}
		:Returns the number of *fields* in the given PLIST. A field is a pair
		:of subsequent elements in a List: LABEL VALUE. So a List with 4
		:elements has 2 fields as a plist. Note that a final odd-indexed
		:element is not considered part of a plist, so is not included in the
		:length.
	x {cons X [Y]}
		Qualified name: cons.new
		:Creates a new List [X, Y]. Default value for Y is an empty list
		:(which typically is used to terminate linked lists and trees).
	x {car CONS}
		:Returns the first item from the List CONS.
        :An error if CONS is an empty list.
	x {cdr CONS}
		:Returns the second item from the List CONS. Error if there are fewer
		:than 2 elements in CONS.
	x {cons.len CONS}
		:Determines the number of elements in the CONS linked list. 
		: Error if any of the elements in the linked list are not CONS
		: cells.

Math Funcs:
	x {add [VAL1 [VAL2 [...]]]}
		__mnemonics__ = "add", "+", "math.add"
		:Returns the sum of all the values.
	x {sub [VAL1] VAL2}
		__mnemonics__ = "sub", "-", "math.sub"
		:With two arguments, returns VAL1 - VAL2. With one argument, returns
		:-(VAL2).
	{equiv VAL1 VAL2}
		__mnemonics__ = ("equiv", "==", )
		: Test equality of two numerical values, regardless of type. Which is
		: to that for instance 2.0 == 2. But values must be numeric strings.

Misc:
	x {eq VAL1 VAL}
		Aliases: "equal", "==="
		:checks equality of two objects.
	x {let [NAME0 [NAME1 [...]]]}
		Qualified name: exp.let
		:Adds new symbols to the lowest scope in the stack.
		: Result is NULL.
	x {pck.let LIST}
		:For each element in LIST, a new symbol with that name is created in
		:the lowest scope on the stack.
		:Elements of LIST must all be Strings.
	x {getset NAME [VALUE]}
		Aliases: "$"
		:If two arguments are given, sets the value of the lowest occurence of
		:NAME in the stack to VALUE, and results in VALUE. If the value
		:doesn't exist, it's created in the current (lowest) scope.
		:
		:If one argument is given, just looks up NAME in the stack and returns
		:the value. Error if no such symbol exists.
	x {get NAME}
		:Macro alias for {getset NAME}, returns the value of symbol NAME.
	x {set NAME VALUE}
		Aliases: "$="
		:Macro alias for {getset NAME VALUE}.
	x {exists NAME}
		Aliases: "?"
		:Determines if a symbol exists with name NAME.
	x {void [EXPR]}
		Aliases: "v"
		:Evaluates EXPR unconditionally but results in a Null value
		:regardless.
	x {vota ARG}
		Aliases: "value-of-the-argument", "$$"
		:Simply results in ARG (works as a macro), useful for putting quoted
		:strings in the top level Template.
	x {filepos VAL}
		Aliases: "str.filepos"
		:Returns a string describing the position from which VAL orignates.
	x {filepos-tuple VAL}
		Aliases: "list.filepos"
		:Like `filepos`, but the returns value is a three-tuple List:
		:filename, line, column.
	x {filepos-plist VAL}
		Aliases: "plist.filepos"
		:Like `filepos` but the returned value is a three-element plist:
		: "file", "line", "column".
	{vars}
		:Results in a List of all the Symbols on the stack.
	{locals}
		:Results in a List of all the Symbols in the current scope.
		

Handy Helpers
	x {ocb}
		: Open curly brace. A macro that expands directly to the String object
		: "{".
	x {oesc}
		: Open escaped curly brace. A macro that expands directly to the
		: String object "\{".
	x {ccb}
		:
	x {cecb}
		:
	x {eol}
		: End-of-line macro. Macro expands directly to a String object giving
		: an appropriate end of line string for the current system. Usually
		: "\r\n", or just "\n". This is probably only necessary when writing
		: to a binary stream, otherwise just use `lnbrk` and your os will
		: probably translate it.
	x {lnbrk}
		Aliases: "\n"
		: Line-break macro. Macro expands directly to the single-character
		: String with ASCII value 0x0A (decimal 10). This is the traditional
		: "linebreak" character, often escaped in other programming languages 
		: as "\n". Note that templ has no escapes in strings or string
		: literals.
	x {tab}
		Aliases: "\t"
		: Tab macro. Macro expands directly to the single-character
		: String with ASCII value  . This is the traditional
		: "horizontal tab" character, often escaped in other programming languages 
		: as "\t". Note that templ has no escapes in strings or string
		: literals.



File I/O:
	: Files are just represented as strings giving the FID.
	x {open NAME MODE}
		:Opens a file, returns an FD describing it.
	x {close FD}
		:Close the file
	x {write FD STR0 [STR1 [...]]}
		:Writes the given string to file FD.
	x {read FD [COUNT]}
		:Reads the specified COUNT number of characters from FD, or fewer if
		:end of the file is reached, returns the String.
	x {stdout}
		:Results in the STDOUT FD.
	x {stderr}
		:Results in the STDERR FD.
	x {stdin}
		:Results in the STDIN FD.
	x {redirect FD EXPR}
		: First evaluates FD, then evaluates EXPR but redirecting all of the
		: expressions output to the specified FD file.
	x {buffer EXPR}
		: Evaluates EXPR but buffers all of its output, and results in the String
        : that it buffered. That means the result of EXPR is lost. You can use
        : `buffer-to` if you need the result of EXPR.
	x {buffer-to NAME EXPR}
		: Evaluates EXPR but buffers all of its output, and saves the string to
        : the symbol names NAME (using a mechanism just like `set`).
        : The result of this expression is the result of EXPR. If you don't need
        : the result of EXPR, you can use `buffer` instead.

Boolean:
	x {true}
		:Macro alias for String value "1", a Boolean true.
	x {false}
		:Macro alias for String value "0", a Boolean false.
	x {bool VAL}
		:If VAL is equal to "0", result value is "0", otherwise result is "1".
	x {is-true VAL}
		:If VAL is equal to "1", result value is "1", otherwise result is "0".
	x {is-false VAL}
		Aliases: "not"
		:If VAL is equal to "0", result value is "1", otherwise result is "0".
	x {and [VAL0 [VAL1 [...]]]}
		Aliases: "&&", "all"
		Qualified name: "exp.and"
		:If no args given, results in True. If one or more args given, results
		:in True if an only if none of the arguments are equal to False.
	x {or [VAL0 [VAL1 [...]]]}
		Aliases: "||", "any"
		Qualified name: "exp.or"
		:If no args given, results in False. If one or more args given,
		:results in True if any of the arguments are not equal to True.
	{pck.and LIST}
		:Like and but args are packed.
	{pck.or LIST}
		:Like or but args are packed.

Type Checking:
	x {is-null X}
		Qualified name: null.is
	x {is-str X}
		Qualified name: str.is
	x {is-list X}
		Qualified name: list.is
	{is-flat X}
		:Determines if X is a List without any nested lists.
	{just-strings X}
		:Determines if X is a List whose elements are all either Strings or
		:Lists whose elements are all either Strings or...
	{is-flat-strings X}
		:Determines if X is a flat List with only Strings for elements (no
		:nested lists, even lists of all Strings).
	x {is-exe X}
		Qualified name: exe.is
		:Determines if X is an executable object.
	x {is-func X}
	x {is-oper X}
	x {is-macro X}
