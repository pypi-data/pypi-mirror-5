// Generated by CoffeeScript 1.6.3
(function() {
  var Extractor, Handlebars, fs, log;

  Handlebars = require('./lib/custom_handlebars.js').Handlebars;

  fs = require('fs');

  log = function(string) {
    return fs.appendFileSync('/tmp/pybabel_hbs_extractor_log', '-->' + string + '\n');
  };

  process.stdin.resume();

  process.stdin.setEncoding('utf8');

  process.stdin.on('data', function(chunk) {
    var command, parts;
    if (chunk.indexOf('PYHBS COMMAND') === 0) {
      parts = chunk.split(":");
      command = parts[1].trim();
      if (command === 'PARSE FILE') {
        Extractor.init();
        Extractor.received_data = fs.readFileSync(parts[2].trim(), {
          encoding: 'utf8'
        });
        return Extractor.flush();
      }
    }
  });

  Extractor = {
    start: function() {
      this.init();
      return this.communicate('WAITING FOR COMMAND');
    },
    init: function() {
      this.received_data = "";
      return this.output = [];
    },
    communicate: function(message) {
      return process.stdout.write('PYHBS RESPONSE:' + message);
    },
    flush: function() {
      var parsed_data;
      this.communicate('SENDING OUTPUT');
      parsed_data = Handlebars.parse(this.received_data);
      this.extract(parsed_data);
      process.stdout.write(JSON.stringify(this.output));
      return this.communicate('OUTPUT END');
    },
    extract: function(node) {
      var alt_content_node, content_node, statement, _i, _len, _ref, _results;
      if (node.statements) {
        _ref = node.statements;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          statement = _ref[_i];
          _results.push(this.extract(statement));
        }
        return _results;
      } else if (node.type === 'block' && node.mustache.id.original === 'trans') {
        content_node = node.program.statements[0];
        return this.output.push({
          line_number: content_node.first_line,
          content: content_node.string,
          funcname: '_'
        });
      } else if (node.type === 'block' && node.mustache.id.original === 'ntrans') {
        content_node = node.program.statements[0];
        alt_content_node = node.program.inverse.statements[0];
        return this.output.push({
          line_number: content_node.first_line,
          alt_line_number: alt_content_node.first_line,
          content: content_node.string,
          alt_content: alt_content_node.string,
          funcname: 'ngettext'
        });
      } else if (node.type === 'block') {
        this.extract(node.program);
        if (node.program.inverse) {
          this.extract(node.program.inverse);
        }
      } else if (node.type === 'mustache') {
        if (node.id.original === '_') {
          return this.output.push({
            line_number: node.first_line,
            content: node.params[0].string,
            funcname: '_'
          });
        } else if (node.id.original === 'n_') {
          return this.output.push({
            line_number: node.first_line,
            content: node.params[0].string,
            alt_content: node.params[1].string,
            funcname: 'ngettext'
          });
        }
      }
    }
  };

  Extractor.start();

}).call(this);
