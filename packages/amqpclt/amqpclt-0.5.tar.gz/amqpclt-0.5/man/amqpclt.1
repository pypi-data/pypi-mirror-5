.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AMQPCLT 1"
.TH AMQPCLT 1 "2013-05-16" "" "amqpclt man page"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
amqpclt 0.5 \- versatile AMQP client
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBamqpclt\fR \fI[\s-1OPTIONS\s0]\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBamqpclt\fR is a versatile tool to interact with messaging brokers speaking
\&\s-1AMQP\s0 and/or message queues (see :py:mod:`messaging.queue`) on disk.
.PP
It receives messages (see :py:mod:`messaging.message`) from an incoming
module, optionally massaging them (i.e. filtering and/or modifying), and
sends them to an outgoing module. Depending on which modules are used,
the tool can perform different operations.
.PP
Here are the supported incoming modules:
.IP "\(bu" 4
broker: connect to a messaging broker using \s-1AMQP\s0, subscribe to one
  or more queues and receive the messages sent by the broker
.IP "\(bu" 4
queue: read messages from a message queue on disk
  (see :py:mod:`messaging.queue`)
.PP
Here are the supported outgoing modules:
.IP "\(bu" 4
broker: connect to a messaging broker using \s-1AMQP\s0 and send the messages
.IP "\(bu" 4
queue: store the messages in a message queue on disk
  (see :py:mod:`messaging.queue`)
.PP
Here are some frequently used combinations:
.IP "\(bu" 4
incoming broker + outgoing queue: drain some destinations, storing
  the messages on disk
.IP "\(bu" 4
incoming queue + outgoing broker: (re\-)send messages that have been
  previously stored on disk, optionally with modifications (such as
  altering the destination)
.IP "\(bu" 4
incoming broker + outgoing broker: shovel messages from one broker
  to another
.PP
See the \*(L"\s-1EXAMPLES\s0\*(R" sections for concrete examples.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-\-callback\-code\fR \fI\s-1CODE\s0\fR" 4
.IX Item "--callback-code CODE"
execute the Python code on each message, see the \*(L"\s-1CALLBACK\s0\*(R" section for more information
.IP "\fB\-\-callback\-data\fR \fI\s-1VALUE\s0,...\fR" 4
.IX Item "--callback-data VALUE,..."
pass this data to the user supplied callback code, see the \*(L"\s-1CALLBACK\s0\*(R" section for more information
.IP "\fB\-\-callback\-path\fR \fI\s-1PATH\s0\fR" 4
.IX Item "--callback-path PATH"
execute the Python code in the given file on each message, see the \*(L"\s-1CALLBACK\s0\*(R" section for more information
.IP "\fB\-\-conf\fR \fI\s-1PATH\s0\fR" 4
.IX Item "--conf PATH"
use the given configuration file, see theconfigURATION \s-1FILE\s0 section for more information
.IP "\fB\-c, \-\-count\fR \fI\s-1INTEGER\s0\fR" 4
.IX Item "-c, --count INTEGER"
process at most the given number of messages; note: when using an incoming broker, to avoid consuming more messages, it is recommended to enable the \-\-reliable option
.IP "\fB\-\-daemon\fR" 4
.IX Item "--daemon"
detach \fBamqpclt\fR so that it becomes a daemon running in the background
.IP "\fB\-\-duration\fR \fI\s-1SECONDS\s0\fR" 4
.IX Item "--duration SECONDS"
process messages during at most the given number of seconds and then stop
.IP "\fB\-h, \-\-help\fR" 4
.IX Item "-h, --help"
print the help page
.IP "\fB\-\-incoming\-broker\-auth\fR \fI\s-1STRING\s0\fR" 4
.IX Item "--incoming-broker-auth STRING"
use this authentication string (see :py:mod:`auth.credential`) to authenticate to the incoming broker
.IP "\fB\-\-incoming\-broker\-module\fR \fI\s-1STRING\s0\fR" 4
.IX Item "--incoming-broker-module STRING"
module to use (pika|kombu)
.IP "\fB\-\-incoming\-broker\-type\fR \fI\s-1STRING\s0\fR" 4
.IX Item "--incoming-broker-type STRING"
set the incoming broker type; this can be useful when using features which are broker specific
.IP "\fB\-\-incoming\-broker\-uri\fR \fI\s-1URI\s0\fR" 4
.IX Item "--incoming-broker-uri URI"
use this authentication \s-1URI\s0 to connect to the incoming broker
.IP "\fB\-\-incoming\-queue\fR \fIKEY=VALUE...\fR" 4
.IX Item "--incoming-queue KEY=VALUE..."
read incoming messages from the given message queue (see :py:mod:`messaging.queue`)
.IP "\fB\-\-lazy\fR" 4
.IX Item "--lazy"
initialize the outgoing module only after having received the first message
.IP "\fB\-\-log\fR \fI\s-1STRING\s0\fR" 4
.IX Item "--log STRING"
select logging system, one of: stdout, syslog, file, null
.IP "\fB\-\-logfile\fR \fI\s-1STRING\s0\fR" 4
.IX Item "--logfile STRING"
select logging file if log system file is selected
.IP "\fB\-\-loglevel\fR \fI\s-1STRING\s0\fR" 4
.IX Item "--loglevel STRING"
select logging level, one of: debug, info, warning and error
.IP "\fB\-\-loop\fR" 4
.IX Item "--loop"
when using an incoming message queue, loop over it
.IP "\fB\-\-outgoing\-broker\-auth\fR \fI\s-1STRING\s0\fR" 4
.IX Item "--outgoing-broker-auth STRING"
use this authentication string (see :py:mod:`auth.credential`) to authenticate to the outgoing broker
.IP "\fB\-\-outgoing\-broker\-module\fR \fI\s-1STRING\s0\fR" 4
.IX Item "--outgoing-broker-module STRING"
module to use (pika|kombu)
.IP "\fB\-\-outgoing\-broker\-type\fR \fI\s-1STRING\s0\fR" 4
.IX Item "--outgoing-broker-type STRING"
set the outgoing broker type; this can be useful when using features which are broker specific
.IP "\fB\-\-outgoing\-broker\-uri\fR \fI\s-1URI\s0\fR" 4
.IX Item "--outgoing-broker-uri URI"
use this authentication \s-1URI\s0 to connect to the outgoing broker
.IP "\fB\-\-outgoing\-queue\fR \fIKEY=VALUE...\fR" 4
.IX Item "--outgoing-queue KEY=VALUE..."
store outgoing messages into the given message queue (see :py:mod:`messaging.queue`)
.IP "\fB\-\-pidfile\fR \fI\s-1PATH\s0\fR" 4
.IX Item "--pidfile PATH"
use this pid file
.IP "\fB\-\-pod\fR" 4
.IX Item "--pod"
print the pod guide
.IP "\fB\-\-prefetch\fR \fI\s-1INTEGER\s0\fR" 4
.IX Item "--prefetch INTEGER"
set the prefetch value (i.e. the maximum number of messages to received without acknowledging them) on the incoming broker
.IP "\fB\-\-quit\fR" 4
.IX Item "--quit"
tell another instance of \fBamqpclt\fR (identified by its pid file, as specified by the \-\-pidfile option) to quit
.IP "\fB\-\-reliable\fR" 4
.IX Item "--reliable"
use \s-1AMQP\s0 features for more reliable messaging (i.e. client side acknowledgments) at the cost of less performance
.IP "\fB\-\-remove\fR" 4
.IX Item "--remove"
when using an incoming message queue, remove the processed messages
.IP "\fB\-\-rst\fR" 4
.IX Item "--rst"
print the rst guide
.IP "\fB\-\-statistics\fR" 4
.IX Item "--statistics"
report statistics at the end of the execution
.IP "\fB\-\-status\fR" 4
.IX Item "--status"
get the status of another instance of \fBamqpclt\fR (identified by its pid file, as specified by the \-\-pidfile option); the exit code will be zero if the instance is alive and non-zero otherwise
.IP "\fB\-\-subscribe\fR" 4
.IX Item "--subscribe"
use these options in the \s-1AMQP\s0 subscription used with the incoming broker; this option can be given multiple times
.IP "\fB\-\-timeout\-connect\fR \fI\s-1SECONDS\s0\fR" 4
.IX Item "--timeout-connect SECONDS"
use this timeout when connecting to the broker; can be fractional
.IP "\fB\-\-timeout\-inactivity\fR \fI\s-1SECONDS\s0\fR" 4
.IX Item "--timeout-inactivity SECONDS"
use this timeout in the incoming module to stop  \fBamqpclt\fR when no new messages have been received (aka drain mode); can be fractional
.IP "\fB\-\-timeout\-linger\fR \fI\s-1SECONDS\s0\fR" 4
.IX Item "--timeout-linger SECONDS"
when stopping \fBamqpclt\fR, use this timeout to finish interacting with the broker; can be fractional
.IP "\fB\-\-version\fR" 4
.IX Item "--version"
print the program version
.IP "\fB\-\-window\fR \fI\s-1INTEGER\s0\fR" 4
.IX Item "--window INTEGER"
keep at most the given number of not-yet-acknowledged messages in memory
.SH "CONFIGURATION FILE"
.IX Header "CONFIGURATION FILE"
\&\fBamqpclt\fR can read its options from a configuration file. For this,
the Perl Config:General module is used and the option names are the
same as on the command line. For instance:
.PP
.Vb 5
\&    daemon = true
\&    pidfile = /var/run/amqpclt.pid
\&    incoming\-queue = path=/var/spool/amqpclt
\&    outgoing\-broker\-uri = amqp://broker.acme.com:5672/virtual_host
\&    outgoing\-broker\-auth = "plain name=guest pass=guest"
.Ve
.PP
Alternatively, options can be nested:
.PP
.Vb 4
\&    <outgoing\-broker>
\&        uri = amqp://broker.acme.com:5672/virtual_host
\&        auth = "plain name=guest pass=guest"
\&    </outgoing\-broker>
.Ve
.PP
Or even:
.PP
.Vb 10
\&    <outgoing>
\&        <broker>
\&            uri = amqp://broker.acme.com:5672/virtual_host
\&            <auth>
\&                scheme = plain
\&                name = guest
\&                pass = guest
\&            </auth>
\&        </broker>
\&    </outgoing>
.Ve
.PP
The options specified on the command line have precedence over the
ones found in the configuration file.
.SH "CALLBACK"
.IX Header "CALLBACK"
\&\fBamqpclt\fR can be given python code to execute on all processed messages.
This can be used for different purposes:
.IP "\(bu" 4
massaging: the code can change any part of the message, including setting
  or removing header fields
.IP "\(bu" 4
filtering: the code can decide if the message must be given to the
  outgoing module or not
.IP "\(bu" 4
displaying: the code can print any part of the message
.IP "\(bu" 4
copying: the code can store a copy of the message into files or
  message queues
.PP
To use callbacks, the \-\-callback\-path or \-\-callback\-code option must be used.
The python code must provide functions with the following signature:
.IP "\(bu" 4
start(self, \s-1DATA\s0)
  (optional) this will be called when the program starts, with the supplied
  data (see the \-\-callback\-data option) as a list reference
.IP "\(bu" 4
check(self, \s-1MESSAGE\s0)
  (mandatory) this will be called when the program has one message to process;
  it will be given the message (see messaging.message.Message) and must return
  either a message (it could be the same one or a new one) or a string
  describing why the message has been dropped
.IP "\(bu" 4
idle(self)
  (optional) this will be called when the program has no message to process
.IP "\(bu" 4
stop(self)
  (optional) this will be called when the program stops
.PP
The code can be put in a file, on the command line or in the \fBamqpclt\fR
configuration file, using the \*(L"here document\*(R" syntax.
.PP
Here is an example (to be put in the \fBamqpclt\fR configuration file) that
prints on stdout a \s-1JSON\s0 array of messages:
.PP
.Vb 10
\&    callback\-code = <<EOF
\&    def start (self):
\&        self.count = 0
\&    def check(self, msg):
\&        if self.count:
\&            sys.stdout.write(", ")
\&        else:
\&            sys.stdout.write("[")
\&        self.count += 1
\&        sys.stdout.write(msg.serialize())
\&        return msg
\&    def stop(self):
\&        if self.count:
\&            sys.stdout.write("]\en")
\&        else:
\&            sys.stdout.write("[]\en")
\&    EOF
.Ve
.PP
For simple callback code that only needs the check subroutine, it is enough
to supply the \*(L"inside code\*(R". If the function definition is missing,
the supplied code will be wrapped with:
.PP
.Vb 4
\&    def check(self, msg):
\&        hdr = msg.header
\&        ... your code goes here ...
\&        return msg
.Ve
.PP
This allows for instance to remove the message-id header with something like:
.PP
.Vb 1
\&  $ amqpclt ... \-\-callback\-code \*(Aqdel(hdr["foo"])\*(Aq
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "\s-1SENDING\s0"
.IX Subsection "SENDING"
Here is an example of a configuration file for a message sender
daemon (from queue to broker), forcing the persistent header to true
(something which is highly recommended for reliable messaging) and
setting the destination:
.PP
.Vb 10
\&    # define the source message queue
\&    <incoming\-queue>
\&     path = /var/spool/sender
\&    </incoming\-queue>
\&    # modify the message header on the fly
\&    callback\-code = <<EOF
\&        hdr["destination"] = "/queue/app1.data"
\&        hdr["persistent"] = "true"
\&    EOF
\&    # define the destination broker
\&    <outgoing\-broker>
\&        uri = "amqp://broker.acme.com:5672/virtual_host"
\&    </outgoing\-broker>
\&    # miscellaneous options
\&    reliable = true
\&    pidfile = /var/run/sender.pid
\&    daemon = true
\&    loop = true
\&    remove = true
.Ve
.SS "\s-1SHOVELING\s0"
.IX Subsection "SHOVELING"
Here is an example of a configuration file for a message shoveler
(from broker to broker), clearing some headers on the fly so that messages
can be replayed safely:
.PP
.Vb 10
\&    # define the source broker
\&    <incoming\-broker>
\&        uri = "amqp://broker.acme.com:5672/virtual_host"
\&    </incoming\-broker>
\&    # define the subscriptions
\&    <subscribe>
\&        destination = /queue/app1.data
\&    </subscribe>
\&    <subscribe>
\&        destination = /queue/app2.data
\&    </subscribe>
\&    # define the destination broker
\&    <outgoing\-broker>
\&        uri = "amqp://dev\-broker.acme.com:5672/virtual_host"
\&    </outgoing\-broker>
\&    # modify the message destination
\&    callback\-code = <<EOF
\&        hdr["destination"] = "/queue/dest_to_be_replayed"
\&    EOF
.Ve
.SS "\s-1RECEIVING\s0"
.IX Subsection "RECEIVING"
Here is an example of a configuration file for a message receiver
(from broker to queue):
.PP
.Vb 10
\&    # define the source broker
\&    <incoming\-broker>
\&        uri = "amqp://broker.acme.com:5672/virtual_host"
\&        <auth>
\&            scheme = plain
\&            name = receiver
\&            pass = secret
\&        </auth>
\&    </incoming\-broker>
\&    # define the subscriptions
\&    <subscribe>
\&        destination = /queue/app1.data
\&    </subscribe>
\&    <subscribe>
\&        destination = /queue/app2.data
\&    </subscribe>
\&    # define the destination message queue
\&    <outgoing\-queue>
\&        path = /var/spool/receiver
\&    </outgoing\-queue>
\&    # miscellaneous options
\&    pidfile = /var/run/receiver.pid
.Ve
.PP
To run it as a daemon:
.PP
.Vb 1
\&    $ amqpclt \-\-conf test.conf \-\-daemon
.Ve
.PP
To use the configuration file above with some options
on the command line to drain the queues:
.PP
.Vb 1
\&    $ amqpclt \-\-conf test.conf \-\-timeout\-inactivity 10
.Ve
.SS "\s-1TAPPING\s0"
.IX Subsection "TAPPING"
Callback code can also be used to tap messages, i.e. get a copy of all
messages processed by \fBamqpclt\fR. Here is some callback code for this purpose
that could for instance be merged with the shoveling code above.
It also shows how to use the \-\-callback\-data option:
.PP
.Vb 3
\&    callback\-code = <<EOF
\&        def start(self, path, qtype="DQS"):
\&            self.tap_queue = queue.new({"path" : path, "type" : qtype})
\&
\&        def check(self, msg):
\&            self.tap_queue.add_message(msg)
\&            return msg
\&    EOF
.Ve
.PP
Callback data must be given to specify which message queue to use:
.PP
.Vb 1
\&    $ amqpclt \-\-conf tap.conf \-\-callback\-data "/tmp/tap,DQS"
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Massimo Paladin <massimo.paladin@gmail.com> \- Copyright (C) 2013 \s-1CERN\s0
