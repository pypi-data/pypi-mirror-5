! -*- f90 -*-
! If you're editing this, make sure the file extension is .pyf.mako, not .pyf.
! If it is .pyf, you are editing a generated file, and your changes will be
! overwritten.



python module _internal
  interface
      subroutine jfuns2d(ier,nterms,z,scale,fjs,ifder,fjder, &
          lwfjs,iscale,ntop)
        ! implicit real *8 (a-h,o-z)
        integer, intent(out) :: ier
        integer, intent(in) :: nterms
        complex*16, intent(in) :: z
        real*8, intent(in) :: scale
        integer, intent(in),check(lwfjs>=nterms+2) :: lwfjs
        complex*16, intent(out) :: fjs(0:lwfjs)
        integer, intent(in) :: ifder
        complex*16, intent(out) :: fjder(0:lwfjs)
        complex*16, intent(cache,hide) :: iscale(0:lwfjs)
        complex*16, intent(out) :: ntop
    end subroutine

    ! {{{ special functions

    subroutine legeexps(itype,n,x,u,v,whts)
      integer, intent(in) :: itype, n
      real*8, intent(out) :: x(n),whts(n),u(n,n),v(n,n)
    end subroutine

    subroutine legefder(x,val,der,pexp,n)
      implicit real *8 (a-h,o-z)
      real *8 pexp(n+1)
      intent(out) val, der
      intent(in) x, pexp, n
    end subroutine

    ! }}}

    ! {{{ form{mp,ta} entrypoints

            subroutine l2dformmp( &
              ier,  &
              rscale, source, &
                charge, &
              ns, center, nterms,expn)
                intent(in) rscale,sources,charge,ns,center,nterms
                intent(out) ier,expn

                implicit real *8 (a-h,o-z)
                complex *16 zk,charge(ns)
                dimension center(2),source(2,ns),zdiff(2)
                real *8 dipvec(2,ns)
                complex *16 dipstr(ns)

                complex*16 expn(0:nterms)
            end subroutine
            subroutine l2dformta( &
              ier,  &
              rscale, source, &
                charge, &
              ns, center, nterms,expn)
                intent(in) rscale,sources,charge,ns,center,nterms
                intent(out) ier,expn

                implicit real *8 (a-h,o-z)
                complex *16 zk,charge(ns)
                dimension center(2),source(2,ns),zdiff(2)
                real *8 dipvec(2,ns)
                complex *16 dipstr(ns)

                complex*16 expn(0:nterms)
            end subroutine
            subroutine h2dformmp( &
              ier, zk,  &
              rscale, source, &
                charge, &
              ns, center, nterms,expn)
                intent(in) rscale,sources,charge,ns,center,nterms
                intent(out) ier,expn

                implicit real *8 (a-h,o-z)
                complex *16 zk,charge(ns)
                dimension center(2),source(2,ns),zdiff(2)
                real *8 dipvec(2,ns)
                complex *16 dipstr(ns)

                complex*16 expn(-(nterms):nterms)
            end subroutine
            subroutine h2dformta( &
              ier, zk,  &
              rscale, source, &
                charge, &
              ns, center, nterms,expn)
                intent(in) rscale,sources,charge,ns,center,nterms
                intent(out) ier,expn

                implicit real *8 (a-h,o-z)
                complex *16 zk,charge(ns)
                dimension center(2),source(2,ns),zdiff(2)
                real *8 dipvec(2,ns)
                complex *16 dipstr(ns)

                complex*16 expn(-(nterms):nterms)
            end subroutine
            subroutine l3dformmp( &
              ier,  &
              rscale, source, &
                charge, &
              ns, center, nterms,expn)
                intent(in) rscale,sources,charge,ns,center,nterms
                intent(out) ier,expn

                implicit real *8 (a-h,o-z)
                complex *16 zk,charge(ns)
                dimension center(3),source(3,ns),zdiff(3)
                real *8 dipvec(3,ns)
                complex *16 dipstr(ns)

                complex*16 expn(0:nterms,-(nterms):nterms)
            end subroutine
            subroutine l3dformta( &
              ier,  &
              rscale, source, &
                charge, &
              ns, center, nterms,expn)
                intent(in) rscale,sources,charge,ns,center,nterms
                intent(out) ier,expn

                implicit real *8 (a-h,o-z)
                complex *16 zk,charge(ns)
                dimension center(3),source(3,ns),zdiff(3)
                real *8 dipvec(3,ns)
                complex *16 dipstr(ns)

                complex*16 expn(0:nterms,-(nterms):nterms)
            end subroutine
            subroutine h3dformmp( &
              ier, zk,  &
              rscale, source, &
                charge, &
              ns, center, nterms,expn)
                intent(in) rscale,sources,charge,ns,center,nterms
                intent(out) ier,expn

                implicit real *8 (a-h,o-z)
                complex *16 zk,charge(ns)
                dimension center(3),source(3,ns),zdiff(3)
                real *8 dipvec(3,ns)
                complex *16 dipstr(ns)

                complex*16 expn(0:nterms,-(nterms):nterms)
            end subroutine
            subroutine h3dformta( &
              ier, zk,  &
              rscale, source, &
                charge, &
              ns, center, nterms,expn)
                intent(in) rscale,sources,charge,ns,center,nterms
                intent(out) ier,expn

                implicit real *8 (a-h,o-z)
                complex *16 zk,charge(ns)
                dimension center(3),source(3,ns),zdiff(3)
                real *8 dipvec(3,ns)
                complex *16 dipstr(ns)

                complex*16 expn(0:nterms,-(nterms):nterms)
            end subroutine
            subroutine l2dformmp_dp( &
              ier,  &
              rscale, source, &
                charge, &
              ns, center, nterms,expn)
                intent(in) rscale,sources,charge,ns,center,nterms
                intent(out) ier,expn

                implicit real *8 (a-h,o-z)
                complex *16 zk,charge(ns)
                dimension center(2),source(2,ns),zdiff(2)
                real *8 dipvec(2,ns)
                complex *16 dipstr(ns)

                complex*16 expn(0:nterms)
            end subroutine
            subroutine l2dformta_dp( &
              ier,  &
              rscale, source, &
                charge, &
              ns, center, nterms,expn)
                intent(in) rscale,sources,charge,ns,center,nterms
                intent(out) ier,expn

                implicit real *8 (a-h,o-z)
                complex *16 zk,charge(ns)
                dimension center(2),source(2,ns),zdiff(2)
                real *8 dipvec(2,ns)
                complex *16 dipstr(ns)

                complex*16 expn(0:nterms)
            end subroutine
            subroutine h2dformmp_dp( &
              ier, zk,  &
              rscale, source, &
                dipstr,  dipvec, &
              ns, center, nterms,expn)
                intent(in) rscale,sources,charge,ns,center,nterms
                intent(out) ier,expn

                implicit real *8 (a-h,o-z)
                complex *16 zk,charge(ns)
                dimension center(2),source(2,ns),zdiff(2)
                real *8 dipvec(2,ns)
                complex *16 dipstr(ns)

                complex*16 expn(-(nterms):nterms)
            end subroutine
            subroutine h2dformta_dp( &
              ier, zk,  &
              rscale, source, &
                dipstr,  dipvec, &
              ns, center, nterms,expn)
                intent(in) rscale,sources,charge,ns,center,nterms
                intent(out) ier,expn

                implicit real *8 (a-h,o-z)
                complex *16 zk,charge(ns)
                dimension center(2),source(2,ns),zdiff(2)
                real *8 dipvec(2,ns)
                complex *16 dipstr(ns)

                complex*16 expn(-(nterms):nterms)
            end subroutine
            subroutine l3dformmp_dp( &
              ier,  &
              rscale, source, &
                dipstr,  dipvec, &
              ns, center, nterms,expn)
                intent(in) rscale,sources,charge,ns,center,nterms
                intent(out) ier,expn

                implicit real *8 (a-h,o-z)
                complex *16 zk,charge(ns)
                dimension center(3),source(3,ns),zdiff(3)
                real *8 dipvec(3,ns)
                complex *16 dipstr(ns)

                complex*16 expn(0:nterms,-(nterms):nterms)
            end subroutine
            subroutine l3dformta_dp( &
              ier,  &
              rscale, source, &
                dipstr,  dipvec, &
              ns, center, nterms,expn)
                intent(in) rscale,sources,charge,ns,center,nterms
                intent(out) ier,expn

                implicit real *8 (a-h,o-z)
                complex *16 zk,charge(ns)
                dimension center(3),source(3,ns),zdiff(3)
                real *8 dipvec(3,ns)
                complex *16 dipstr(ns)

                complex*16 expn(0:nterms,-(nterms):nterms)
            end subroutine
            subroutine h3dformmp_dp( &
              ier, zk,  &
              rscale, source, &
                dipstr,  dipvec, &
              ns, center, nterms,expn)
                intent(in) rscale,sources,charge,ns,center,nterms
                intent(out) ier,expn

                implicit real *8 (a-h,o-z)
                complex *16 zk,charge(ns)
                dimension center(3),source(3,ns),zdiff(3)
                real *8 dipvec(3,ns)
                complex *16 dipstr(ns)

                complex*16 expn(0:nterms,-(nterms):nterms)
            end subroutine
            subroutine h3dformta_dp( &
              ier, zk,  &
              rscale, source, &
                dipstr,  dipvec, &
              ns, center, nterms,expn)
                intent(in) rscale,sources,charge,ns,center,nterms
                intent(out) ier,expn

                implicit real *8 (a-h,o-z)
                complex *16 zk,charge(ns)
                dimension center(3),source(3,ns),zdiff(3)
                real *8 dipvec(3,ns)
                complex *16 dipstr(ns)

                complex*16 expn(0:nterms,-(nterms):nterms)
            end subroutine

    ! }}}

    ! {{{ fmm entrypoints


    


    


        

        subroutine lfmm2dparttarg( &
                ier, iprec,  &
                nsource, &
                    source, &
                ifcharge, charge, ifdipole, dipstr, &
                dipvec, &
                ifpot, pot, iffld, fld, &
                    ifhess, hess, &
                ntarget, target, &
                ifpottarg, pottarg, iffldtarg, fldtarg &
                    , ifhesstarg, hesstarg &
                )
            implicit none

            integer, intent(out) :: ier
            integer, intent(in) :: iprec

            

            integer, intent(in) :: nsource
            real*8, intent(in) :: source(2,nsource)

            integer, intent(in) :: ifcharge
            complex*16, intent(in) :: charge(nsource)

            integer, intent(in) :: ifdipole
            complex*16, intent(in) :: dipstr(nsource)
            real*8, intent(in) :: dipvec(2,nsource)

            integer, intent(in) :: ifpot
            complex*16, intent(out) :: pot(nsource)
            integer, intent(in) :: iffld
            complex*16, intent(out) :: fld(2,nsource)
                integer, intent(in) :: ifhess
                complex*16, intent(out) :: hess(3,nsource)

            integer, intent(in) :: ntarget

            integer, intent(in) :: ifpottarg, iffldtarg
            real*8, intent(in) :: target(2, ntarget)
            complex*16, intent(in,out) :: pottarg(ntarget)
            complex*16, intent(in,out) :: fldtarg(2,ntarget)

                integer, intent(in) :: ifhesstarg
                complex*16, intent(in,out) :: hesstarg(3,ntarget)


            required ntarget
            ! Dear f2py, we do our own checking of ntarget, thank you very much.
            check(1) ntarget

            check((!ifpottarg && !iffldtarg) || (shape(target,0)==2 && shape(target,1) == ntarget))  target
            check((!ifpottarg) || (shape(pottarg,0)==ntarget))  pottarg
            check((!iffldtarg) || (shape(fldtarg,0)==2 && shape(fldtarg,1) == ntarget))  fldtarg
            check((!ifhesstarg) || (shape(hesstarg,0)==3 && shape(hesstarg,1) == ntarget))  hesstarg

            check(!ifcharge || (shape(charge,0) == nsource))  charge
            depend(nsource)  charge
            check(!ifdipole || (shape(dipstr,0) == nsource))  dipstr
            depend(nsource)  dipstr

            ! F2PY workaround: pottarg, fldtarg must be input because f2py
            ! refuses to allocate zero-size output arrays.
            !
            ! This also means that these arrays might end up being 1 long
            ! even if ntarget == 0--but that is only allowed if the
            ! corresponding if*targ flag is off.

        end subroutine


    


    


        

        subroutine hfmm2dparttarg( &
                ier, iprec, zk,  &
                nsource, &
                    source, &
                ifcharge, charge, ifdipole, dipstr, &
                dipvec, &
                ifpot, pot, iffld, fld, &
                    ifhess, hess, &
                ntarget, target, &
                ifpottarg, pottarg, iffldtarg, fldtarg &
                    , ifhesstarg, hesstarg &
                )
            implicit none

            integer, intent(out) :: ier
            integer, intent(in) :: iprec

            
                complex*16, intent(in) :: zk
                

            integer, intent(in) :: nsource
            real*8, intent(in) :: source(2,nsource)

            integer, intent(in) :: ifcharge
            complex*16, intent(in) :: charge(nsource)

            integer, intent(in) :: ifdipole
            complex*16, intent(in) :: dipstr(nsource)
            real*8, intent(in) :: dipvec(2,nsource)

            integer, intent(in) :: ifpot
            complex*16, intent(out) :: pot(nsource)
            integer, intent(in) :: iffld
            complex*16, intent(out) :: fld(2,nsource)
                integer, intent(in) :: ifhess
                complex*16, intent(out) :: hess(3,nsource)

            integer, intent(in) :: ntarget

            integer, intent(in) :: ifpottarg, iffldtarg
            real*8, intent(in) :: target(2, ntarget)
            complex*16, intent(in,out) :: pottarg(ntarget)
            complex*16, intent(in,out) :: fldtarg(2,ntarget)

                integer, intent(in) :: ifhesstarg
                complex*16, intent(in,out) :: hesstarg(3,ntarget)


            required ntarget
            ! Dear f2py, we do our own checking of ntarget, thank you very much.
            check(1) ntarget

            check((!ifpottarg && !iffldtarg) || (shape(target,0)==2 && shape(target,1) == ntarget))  target
            check((!ifpottarg) || (shape(pottarg,0)==ntarget))  pottarg
            check((!iffldtarg) || (shape(fldtarg,0)==2 && shape(fldtarg,1) == ntarget))  fldtarg
            check((!ifhesstarg) || (shape(hesstarg,0)==3 && shape(hesstarg,1) == ntarget))  hesstarg

            check(!ifcharge || (shape(charge,0) == nsource))  charge
            depend(nsource)  charge
            check(!ifdipole || (shape(dipstr,0) == nsource))  dipstr
            depend(nsource)  dipstr

            ! F2PY workaround: pottarg, fldtarg must be input because f2py
            ! refuses to allocate zero-size output arrays.
            !
            ! This also means that these arrays might end up being 1 long
            ! even if ntarget == 0--but that is only allowed if the
            ! corresponding if*targ flag is off.

        end subroutine


    


    


        

        subroutine lfmm3dparttarg( &
                ier, iprec,  &
                nsource, &
                    source, &
                ifcharge, charge, ifdipole, dipstr, &
                dipvec, &
                ifpot, pot, iffld, fld, &
                ntarget, target, &
                ifpottarg, pottarg, iffldtarg, fldtarg &
                )
            implicit none

            integer, intent(out) :: ier
            integer, intent(in) :: iprec

            

            integer, intent(in) :: nsource
            real*8, intent(in) :: source(3,nsource)

            integer, intent(in) :: ifcharge
            complex*16, intent(in) :: charge(nsource)

            integer, intent(in) :: ifdipole
            complex*16, intent(in) :: dipstr(nsource)
            real*8, intent(in) :: dipvec(3,nsource)

            integer, intent(in) :: ifpot
            complex*16, intent(out) :: pot(nsource)
            integer, intent(in) :: iffld
            complex*16, intent(out) :: fld(3,nsource)

            integer, intent(in) :: ntarget

            integer, intent(in) :: ifpottarg, iffldtarg
            real*8, intent(in) :: target(3, ntarget)
            complex*16, intent(in,out) :: pottarg(ntarget)
            complex*16, intent(in,out) :: fldtarg(3,ntarget)



            required ntarget
            ! Dear f2py, we do our own checking of ntarget, thank you very much.
            check(1) ntarget

            check((!ifpottarg && !iffldtarg) || (shape(target,0)==3 && shape(target,1) == ntarget))  target
            check((!ifpottarg) || (shape(pottarg,0)==ntarget))  pottarg
            check((!iffldtarg) || (shape(fldtarg,0)==3 && shape(fldtarg,1) == ntarget))  fldtarg
            check((!ifhesstarg) || (shape(hesstarg,0)==6 && shape(hesstarg,1) == ntarget))  hesstarg

            check(!ifcharge || (shape(charge,0) == nsource))  charge
            depend(nsource)  charge
            check(!ifdipole || (shape(dipstr,0) == nsource))  dipstr
            depend(nsource)  dipstr

            ! F2PY workaround: pottarg, fldtarg must be input because f2py
            ! refuses to allocate zero-size output arrays.
            !
            ! This also means that these arrays might end up being 1 long
            ! even if ntarget == 0--but that is only allowed if the
            ! corresponding if*targ flag is off.

        end subroutine


    


    


        

        subroutine hfmm3dparttarg( &
                ier, iprec, zk,  &
                nsource, &
                    source, &
                ifcharge, charge, ifdipole, dipstr, &
                dipvec, &
                ifpot, pot, iffld, fld, &
                ntarget, target, &
                ifpottarg, pottarg, iffldtarg, fldtarg &
                )
            implicit none

            integer, intent(out) :: ier
            integer, intent(in) :: iprec

            
                complex*16, intent(in) :: zk
                

            integer, intent(in) :: nsource
            real*8, intent(in) :: source(3,nsource)

            integer, intent(in) :: ifcharge
            complex*16, intent(in) :: charge(nsource)

            integer, intent(in) :: ifdipole
            complex*16, intent(in) :: dipstr(nsource)
            real*8, intent(in) :: dipvec(3,nsource)

            integer, intent(in) :: ifpot
            complex*16, intent(out) :: pot(nsource)
            integer, intent(in) :: iffld
            complex*16, intent(out) :: fld(3,nsource)

            integer, intent(in) :: ntarget

            integer, intent(in) :: ifpottarg, iffldtarg
            real*8, intent(in) :: target(3, ntarget)
            complex*16, intent(in,out) :: pottarg(ntarget)
            complex*16, intent(in,out) :: fldtarg(3,ntarget)



            required ntarget
            ! Dear f2py, we do our own checking of ntarget, thank you very much.
            check(1) ntarget

            check((!ifpottarg && !iffldtarg) || (shape(target,0)==3 && shape(target,1) == ntarget))  target
            check((!ifpottarg) || (shape(pottarg,0)==ntarget))  pottarg
            check((!iffldtarg) || (shape(fldtarg,0)==3 && shape(fldtarg,1) == ntarget))  fldtarg
            check((!ifhesstarg) || (shape(hesstarg,0)==6 && shape(hesstarg,1) == ntarget))  hesstarg

            check(!ifcharge || (shape(charge,0) == nsource))  charge
            depend(nsource)  charge
            check(!ifdipole || (shape(dipstr,0) == nsource))  dipstr
            depend(nsource)  dipstr

            ! F2PY workaround: pottarg, fldtarg must be input because f2py
            ! refuses to allocate zero-size output arrays.
            !
            ! This also means that these arrays might end up being 1 long
            ! even if ntarget == 0--but that is only allowed if the
            ! corresponding if*targ flag is off.

        end subroutine


    ! }}}

    subroutine l3dtaevalhess(rscale,center,mpole,nterms,ztarg, &
                        pot,iffld,fld,ifhess,hess,ier)
        implicit none
        integer, intent(in) :: ier,nterms,iffld,ifhess
        real *8, intent(in) :: rscale, center(3),ztarg(3)
        complex *16, intent(in) :: mpole(0:nterms,-nterms:nterms)
        complex *16, intent(out) :: pot,fld(3),hess(6)
        integer, intent(out) :: ier
    end subroutine

    ! }}}

    ! {{{ generated vectorized wrappers

    subroutine triangle_norm_vec(triangles, trinorm, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  real*8, intent(in) :: triangles(3,3,nvcount)
  real*8, intent(out) :: trinorm(3,nvcount)

  !$omp parallel do
  do ivcount = 1, nvcount
    call triangle_norm( &
      triangles(1, 1, ivcount), trinorm(1, ivcount) &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine triangle_area_vec(triangles, triarea, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  real*8, intent(in) :: triangles(3,3,nvcount)
  real*8, intent(out) :: triarea(nvcount)

  !$omp parallel do
  do ivcount = 1, nvcount
    call triangle_area( &
      triangles(1, 1, ivcount), triarea(ivcount) &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine ylgndr_vec(nmax, x, y, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  integer, intent(in) :: nmax
  real *8, intent(in) :: x(nvcount)
  real *8, intent(out) :: y(0:nmax,0:nmax,nvcount)

  !$omp parallel do
  do ivcount = 1, nvcount
    call ylgndr( &
      nmax, x(ivcount), y(0, 0, ivcount) &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine hank103_vec(z, h0, h1, ifexpon, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  complex*16, intent(in) :: z(nvcount)
  complex*16, intent(out) :: h0(nvcount)
  complex*16, intent(out) :: h1(nvcount)
  integer, intent(in) :: ifexpon

  !$omp parallel do
  do ivcount = 1, nvcount
    call hank103( &
      z(ivcount), h0(ivcount), h1(ivcount), ifexpon &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine legefder_vec(x, val, der, pexp, n, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  real*8, intent(in) :: x(nvcount)
  real*8, intent(out) :: val(nvcount)
  real*8, intent(out) :: der(nvcount)
  real*8, intent(in) :: pexp(n+1)
  integer, intent(in) :: n

  !$omp parallel do
  do ivcount = 1, nvcount
    call legefder( &
      x(ivcount), val(ivcount), der(ivcount), pexp, n &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine lpotgrad2dall_vec(ifgrad, ifhess, sources, charge, nsources, targets, pot, grad, hess, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  integer, intent(in) :: ifgrad
  integer, intent(in) :: ifhess
  real *8, intent(in) :: sources(2,nsources)
  complex *16, intent(in) :: charge(nsources)
  integer, intent(in) :: nsources
  real *8, intent(in) :: targets(2,nvcount)
  complex *16, intent(out) :: pot(nvcount)
  complex *16, intent(out) :: grad(2,nvcount)
  complex *16, intent(out) :: hess(3,nvcount)

  !$omp parallel do
  do ivcount = 1, nvcount
    call lpotgrad2dall( &
      ifgrad, ifhess, sources, charge, nsources, targets(1, ivcount),  &
      pot(ivcount), grad(1, ivcount), hess(1, ivcount) &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine lpotfld3dall_vec(iffld, sources, charge, nsources, targets, pot, fld, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  integer, intent(in) :: iffld
  real *8, intent(in) :: sources(3,nsources)
  complex *16, intent(in) :: charge(nsources)
  integer, intent(in) :: nsources
  real *8, intent(in) :: targets(3,nvcount)
  complex *16, intent(out) :: pot(nvcount)
  complex *16, intent(out) :: fld(3,nvcount)

  !$omp parallel do
  do ivcount = 1, nvcount
    call lpotfld3dall( &
      iffld, sources, charge, nsources, targets(1, ivcount), pot(ivcount),  &
      fld(1, ivcount) &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine hpotgrad2dall_vec(ifgrad, ifhess, sources, charge, nsources, targets, zk, pot, grad, hess, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  integer, intent(in) :: ifgrad
  integer, intent(in) :: ifhess
  real *8, intent(in) :: sources(2,nsources)
  complex *16, intent(in) :: charge(nsources)
  integer, intent(in) :: nsources
  real *8, intent(in) :: targets(2,nvcount)
  complex *16, intent(in) :: zk
  complex *16, intent(out) :: pot(nvcount)
  complex *16, intent(out) :: grad(2,nvcount)
  complex *16, intent(out) :: hess(3,nvcount)

  !$omp parallel do
  do ivcount = 1, nvcount
    call hpotgrad2dall( &
      ifgrad, ifhess, sources, charge, nsources, targets(1, ivcount),  &
      zk, pot(ivcount), grad(1, ivcount), hess(1, ivcount) &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine hpotfld3dall_vec(iffld, sources, charge, nsources, targets, zk, pot, fld, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  integer, intent(in) :: iffld
  real *8, intent(in) :: sources(3,nsources)
  complex *16, intent(in) :: charge(nsources)
  integer, intent(in) :: nsources
  real *8, intent(in) :: targets(3,nvcount)
  complex *16, intent(in) :: zk
  complex *16, intent(out) :: pot(nvcount)
  complex *16, intent(out) :: fld(3,nvcount)

  !$omp parallel do
  do ivcount = 1, nvcount
    call hpotfld3dall( &
      iffld, sources, charge, nsources, targets(1, ivcount), zk, pot(ivcount),  &
      fld(1, ivcount) &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine lpotgrad2dall_dp_vec(ifgrad, ifhess, sources, dipstr, dipvec, nsources, targets, pot, grad, hess, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  integer, intent(in) :: ifgrad
  integer, intent(in) :: ifhess
  real *8, intent(in) :: sources(2,nsources)
  complex *16, intent(in) :: dipstr(nsources)
  real*8, intent(in) :: dipvec(2,nsources)
  integer, intent(in) :: nsources
  real *8, intent(in) :: targets(2,nvcount)
  complex *16, intent(out) :: pot(nvcount)
  complex *16, intent(out) :: grad(2,nvcount)
  complex *16, intent(out) :: hess(3,nvcount)

  !$omp parallel do
  do ivcount = 1, nvcount
    call lpotgrad2dall_dp( &
      ifgrad, ifhess, sources, dipstr, dipvec, nsources, targets(1, ivcount),  &
      pot(ivcount), grad(1, ivcount), hess(1, ivcount) &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine lpotfld3dall_dp_vec(iffld, sources, dipstr, dipvec, nsources, targets, pot, fld, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  integer, intent(in) :: iffld
  real *8, intent(in) :: sources(3,nsources)
  complex *16, intent(in) :: dipstr(nsources)
  real*8, intent(in) :: dipvec(3,nsources)
  integer, intent(in) :: nsources
  real *8, intent(in) :: targets(3,nvcount)
  complex *16, intent(out) :: pot(nvcount)
  complex *16, intent(out) :: fld(3,nvcount)

  !$omp parallel do
  do ivcount = 1, nvcount
    call lpotfld3dall_dp( &
      iffld, sources, dipstr, dipvec, nsources, targets(1, ivcount), pot(ivcount),  &
      fld(1, ivcount) &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine hpotgrad2dall_dp_vec(ifgrad, ifhess, sources, dipstr, dipvec, nsources, targets, zk, pot, grad, hess, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  integer, intent(in) :: ifgrad
  integer, intent(in) :: ifhess
  real *8, intent(in) :: sources(2,nsources)
  complex *16, intent(in) :: dipstr(nsources)
  real*8, intent(in) :: dipvec(2,nsources)
  integer, intent(in) :: nsources
  real *8, intent(in) :: targets(2,nvcount)
  complex *16, intent(in) :: zk
  complex *16, intent(out) :: pot(nvcount)
  complex *16, intent(out) :: grad(2,nvcount)
  complex *16, intent(out) :: hess(3,nvcount)

  !$omp parallel do
  do ivcount = 1, nvcount
    call hpotgrad2dall_dp( &
      ifgrad, ifhess, sources, dipstr, dipvec, nsources, targets(1, ivcount),  &
      zk, pot(ivcount), grad(1, ivcount), hess(1, ivcount) &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine hpotfld3dall_dp_vec(iffld, sources, dipstr, dipvec, nsources, targets, zk, pot, fld, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  integer, intent(in) :: iffld
  real *8, intent(in) :: sources(3,nsources)
  complex *16, intent(in) :: dipstr(nsources)
  real*8, intent(in) :: dipvec(3,nsources)
  integer, intent(in) :: nsources
  real *8, intent(in) :: targets(3,nvcount)
  complex *16, intent(in) :: zk
  complex *16, intent(out) :: pot(nvcount)
  complex *16, intent(out) :: fld(3,nvcount)

  !$omp parallel do
  do ivcount = 1, nvcount
    call hpotfld3dall_dp( &
      iffld, sources, dipstr, dipvec, nsources, targets(1, ivcount), zk,  &
      pot(ivcount), fld(1, ivcount) &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine h3dtaeval_vec(zk, rscale, center, locexp, nterms, ztarg, pot, iffld, fld, ier, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  complex*16, intent(in) :: zk
  real*8, intent(in) :: rscale
  real*8, intent(in) :: center(3)
  complex*16, intent(in) :: locexp(0:nterms,-nterms:nterms)
  integer, intent(in) :: nterms
  real*8, intent(in) :: ztarg(3,nvcount)
  complex*16, intent(out) :: pot(nvcount)
  integer, intent(in) :: iffld
  complex*16, intent(out) :: fld(3,nvcount)
  integer, intent(out) :: ier(nvcount)

  !$omp parallel do
  do ivcount = 1, nvcount
    call h3dtaeval( &
      zk, rscale, center, locexp, nterms, ztarg(1, ivcount), pot(ivcount),  &
      iffld, fld(1, ivcount), ier(ivcount) &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine l2dtaeval_vec(rscale, center, mpole, nterms, ztarg, pot, ifgrad, grad, ifhess, hess, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  real*8, intent(in) :: rscale
  real*8, intent(in) :: center(2)
  complex*16, intent(in) :: mpole(-nterms:nterms)
  integer, intent(in) :: nterms
  real*8, intent(in) :: ztarg(2,nvcount)
  complex*16, intent(out) :: pot(nvcount)
  integer, intent(in) :: ifgrad
  complex*16, intent(out) :: grad(2,nvcount)
  integer, intent(in) :: ifhess
  complex*16, intent(out) :: hess(3,nvcount)

  !$omp parallel do
  do ivcount = 1, nvcount
    call l2dtaeval( &
      rscale, center, mpole, nterms, ztarg(1, ivcount), pot(ivcount),  &
      ifgrad, grad(1, ivcount), ifhess, hess(1, ivcount) &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine l2dmpeval_vec(rscale, center, mpole, nterms, ztarg, pot, ifgrad, grad, ifhess, hess, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  real*8, intent(in) :: rscale
  real*8, intent(in) :: center(2)
  complex*16, intent(in) :: mpole(-nterms:nterms)
  integer, intent(in) :: nterms
  real*8, intent(in) :: ztarg(2,nvcount)
  complex*16, intent(out) :: pot(nvcount)
  integer, intent(in) :: ifgrad
  complex*16, intent(out) :: grad(2,nvcount)
  integer, intent(in) :: ifhess
  complex*16, intent(out) :: hess(3,nvcount)

  !$omp parallel do
  do ivcount = 1, nvcount
    call l2dmpeval( &
      rscale, center, mpole, nterms, ztarg(1, ivcount), pot(ivcount),  &
      ifgrad, grad(1, ivcount), ifhess, hess(1, ivcount) &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine l3dtaevalhess_1tgtperexp(rscale, center, mpole, nterms, ztarg, pot, ifgrad, grad, ifhess, hess, ier, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  real*8, intent(in) :: rscale(nvcount)
  real*8, intent(in) :: center(3,nvcount)
  complex *16, intent(in) :: mpole(0:nterms,-nterms:nterms,nvcount)
  integer, intent(in) :: nterms
  real*8, intent(in) :: ztarg(3,nvcount)
  complex*16, intent(out) :: pot(nvcount)
  integer, intent(in) :: ifgrad
  complex*16, intent(out) :: grad(3,nvcount)
  integer, intent(in) :: ifhess
  complex*16, intent(out) :: hess(6,nvcount)
  integer, intent(out) :: ier

  !$omp parallel do
  do ivcount = 1, nvcount
    call l3dtaevalhess( &
      rscale(ivcount), center(1, ivcount), mpole(0, -nterms, ivcount),  &
      nterms, ztarg(1, ivcount), pot(ivcount), ifgrad, grad(1, ivcount),  &
      ifhess, hess(1, ivcount), ier &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine h2dtaeval_vec(zk, rscale, center, mpole, nterms, ztarg, pot, ifgrad, grad, ifhess, hess, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  complex*16, intent(in) :: zk
  real*8, intent(in) :: rscale
  real*8, intent(in) :: center(2)
  complex*16, intent(in) :: mpole(-nterms:nterms)
  integer, intent(in) :: nterms
  real*8, intent(in) :: ztarg(2,nvcount)
  complex*16, intent(out) :: pot(nvcount)
  integer, intent(in) :: ifgrad
  complex*16, intent(out) :: grad(2,nvcount)
  integer, intent(in) :: ifhess
  complex*16, intent(out) :: hess(3,nvcount)

  !$omp parallel do
  do ivcount = 1, nvcount
    call h2dtaeval( &
      zk, rscale, center, mpole, nterms, ztarg(1, ivcount), pot(ivcount),  &
      ifgrad, grad(1, ivcount), ifhess, hess(1, ivcount) &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine h2dmpeval_vec(zk, rscale, center, mpole, nterms, ztarg, pot, ifgrad, grad, ifhess, hess, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  complex*16, intent(in) :: zk
  real*8, intent(in) :: rscale
  real*8, intent(in) :: center(2)
  complex*16, intent(in) :: mpole(-nterms:nterms)
  integer, intent(in) :: nterms
  real*8, intent(in) :: ztarg(2,nvcount)
  complex*16, intent(out) :: pot(nvcount)
  integer, intent(in) :: ifgrad
  complex*16, intent(out) :: grad(2,nvcount)
  integer, intent(in) :: ifhess
  complex*16, intent(out) :: hess(3,nvcount)

  !$omp parallel do
  do ivcount = 1, nvcount
    call h2dmpeval( &
      zk, rscale, center, mpole, nterms, ztarg(1, ivcount), pot(ivcount),  &
      ifgrad, grad(1, ivcount), ifhess, hess(1, ivcount) &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine h3dtaeval_1tgtperexp(zk, rscale, center, mpole, nterms, ztarg, pot, ifgrad, grad, ier, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  complex*16, intent(in) :: zk
  real*8, intent(in) :: rscale(nvcount)
  real*8, intent(in) :: center(3,nvcount)
  complex *16, intent(in) :: mpole(0:nterms,-nterms:nterms,nvcount)
  integer, intent(in) :: nterms
  real*8, intent(in) :: ztarg(3,nvcount)
  complex*16, intent(out) :: pot(nvcount)
  integer, intent(in) :: ifgrad
  complex*16, intent(out) :: grad(3,nvcount)
  integer, intent(out) :: ier

  !$omp parallel do
  do ivcount = 1, nvcount
    call h3dtaeval( &
      zk, rscale(ivcount), center(1, ivcount), mpole(0, -nterms, ivcount),  &
      nterms, ztarg(1, ivcount), pot(ivcount), ifgrad, grad(1, ivcount),  &
      ier &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine l2dmpmp_vec(rscale1, center1, expn1, nterms1, rscale2, center2, expn2, nterms2, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  real*8, intent(in) :: rscale1(nvcount)
  real*8, intent(in) :: center1(2,nvcount)
  complex*16, intent(in) :: expn1(0:nterms1,nvcount)
  integer, intent(in) :: nterms1
  real*8, intent(in) :: rscale2(nvcount)
  real*8, intent(in) :: center2(2,nvcount)
  complex*16, intent(out) :: expn2(0:nterms2,nvcount)
  integer, intent(in) :: nterms2

  !$omp parallel do
  do ivcount = 1, nvcount
    call l2dmpmp( &
      rscale1(ivcount), center1(1, ivcount), expn1(0, ivcount), nterms1,  &
      rscale2(ivcount), center2(1, ivcount), expn2(0, ivcount), nterms2 &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine l2dmploc_vec(rscale1, center1, expn1, nterms1, rscale2, center2, expn2, nterms2, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  real*8, intent(in) :: rscale1(nvcount)
  real*8, intent(in) :: center1(2,nvcount)
  complex*16, intent(in) :: expn1(0:nterms1,nvcount)
  integer, intent(in) :: nterms1
  real*8, intent(in) :: rscale2(nvcount)
  real*8, intent(in) :: center2(2,nvcount)
  complex*16, intent(out) :: expn2(0:nterms2,nvcount)
  integer, intent(in) :: nterms2

  !$omp parallel do
  do ivcount = 1, nvcount
    call l2dmploc( &
      rscale1(ivcount), center1(1, ivcount), expn1(0, ivcount), nterms1,  &
      rscale2(ivcount), center2(1, ivcount), expn2(0, ivcount), nterms2 &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine l2dlocloc_vec(rscale1, center1, expn1, nterms1, rscale2, center2, expn2, nterms2, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  real*8, intent(in) :: rscale1(nvcount)
  real*8, intent(in) :: center1(2,nvcount)
  complex*16, intent(in) :: expn1(0:nterms1,nvcount)
  integer, intent(in) :: nterms1
  real*8, intent(in) :: rscale2(nvcount)
  real*8, intent(in) :: center2(2,nvcount)
  complex*16, intent(out) :: expn2(0:nterms2,nvcount)
  integer, intent(in) :: nterms2

  !$omp parallel do
  do ivcount = 1, nvcount
    call l2dlocloc( &
      rscale1(ivcount), center1(1, ivcount), expn1(0, ivcount), nterms1,  &
      rscale2(ivcount), center2(1, ivcount), expn2(0, ivcount), nterms2 &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine h2dmpmp_vec(zk, rscale1, center1, expn1, nterms1, rscale2, center2, expn2, nterms2, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  complex*16, intent(in) :: zk
  real*8, intent(in) :: rscale1(nvcount)
  real*8, intent(in) :: center1(2,nvcount)
  complex*16, intent(in) :: expn1(-(nterms1):nterms1,nvcount)
  integer, intent(in) :: nterms1
  real*8, intent(in) :: rscale2(nvcount)
  real*8, intent(in) :: center2(2,nvcount)
  complex*16, intent(out) :: expn2(-(nterms2):nterms2,nvcount)
  integer, intent(in) :: nterms2

  !$omp parallel do
  do ivcount = 1, nvcount
    call h2dmpmp( &
      zk, rscale1(ivcount), center1(1, ivcount), expn1(-(nterms1), ivcount),  &
      nterms1, rscale2(ivcount), center2(1, ivcount), expn2(-(nterms2), ivcount),  &
      nterms2 &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine h2dmploc_vec(zk, rscale1, center1, expn1, nterms1, rscale2, center2, expn2, nterms2, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  complex*16, intent(in) :: zk
  real*8, intent(in) :: rscale1(nvcount)
  real*8, intent(in) :: center1(2,nvcount)
  complex*16, intent(in) :: expn1(-(nterms1):nterms1,nvcount)
  integer, intent(in) :: nterms1
  real*8, intent(in) :: rscale2(nvcount)
  real*8, intent(in) :: center2(2,nvcount)
  complex*16, intent(out) :: expn2(-(nterms2):nterms2,nvcount)
  integer, intent(in) :: nterms2

  !$omp parallel do
  do ivcount = 1, nvcount
    call h2dmploc( &
      zk, rscale1(ivcount), center1(1, ivcount), expn1(-(nterms1), ivcount),  &
      nterms1, rscale2(ivcount), center2(1, ivcount), expn2(-(nterms2), ivcount),  &
      nterms2 &
      )
  enddo
  !$omp end parallel do

  return
end

subroutine h2dlocloc_vec(zk, rscale1, center1, expn1, nterms1, rscale2, center2, expn2, nterms2, nvcount)
  implicit none
  integer, intent(in) :: nvcount
  integer ivcount
  complex*16, intent(in) :: zk
  real*8, intent(in) :: rscale1(nvcount)
  real*8, intent(in) :: center1(2,nvcount)
  complex*16, intent(in) :: expn1(-(nterms1):nterms1,nvcount)
  integer, intent(in) :: nterms1
  real*8, intent(in) :: rscale2(nvcount)
  real*8, intent(in) :: center2(2,nvcount)
  complex*16, intent(out) :: expn2(-(nterms2):nterms2,nvcount)
  integer, intent(in) :: nterms2

  !$omp parallel do
  do ivcount = 1, nvcount
    call h2dlocloc( &
      zk, rscale1(ivcount), center1(1, ivcount), expn1(-(nterms1), ivcount),  &
      nterms1, rscale2(ivcount), center2(1, ivcount), expn2(-(nterms2), ivcount),  &
      nterms2 &
      )
  enddo
  !$omp end parallel do

  return
end


    ! }}}

  end interface
end python module

! vim: filetype=fortran:foldmethod=marker
