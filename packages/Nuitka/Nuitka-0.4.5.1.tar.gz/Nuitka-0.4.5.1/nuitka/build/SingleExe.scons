# -*- python -*-
#     Copyright 2013, Kay Hayen, mailto:kay.hayen@gmail.com
#
#     Part of "Nuitka", an optimizing Python compiler that is compatible and
#     integrates with CPython, but also works on its own.
#
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#

# The Nuitka scons file. If you have Scons or platform knowledge, please feel
# free and contribute improvements, to do it the proper way.
#
# This file is used to build an executable or shared library. Nuitka needs no
# build process for itself, although it can be compiled using the same method.

import os, subprocess, sys, re

# The directory containing the C++ files generated by Nuitka to be built using
# scons. They are referred to as sources from here on.
source_name = ARGUMENTS[ "name" ]
source_dir = ARGUMENTS.get( "source_dir", source_name + ".build" )

# The directory containing Nuitka provided C++ files to be built.
nuitka_src = os.path.join( os.environ.get( "NUITKA_SCONS" ), "static_src" )
static_src = os.path.join( source_dir, "static" )

# We tell Scons that it is a variant to be built, so object files don't end up
# inside that directory which need not be writable.
VariantDir( static_src, nuitka_src, 0 )

# The name of what we should produce. By default it's the same as what we
# started with, but you (or Nuitka) could override it.
result_file = ARGUMENTS.get( "result_file", source_name )

def getBoolOption( option_name, default ):
    """ Small helper for boolean mode flags."""
    value = ARGUMENTS.get( option_name, "True" if default else "False" )

    return value.lower() in ( "yes", "true", "1" )


# Module mode: Create a Python extension module, create an executable otherwise.
module_mode = getBoolOption( "module_mode", False )

# Debug mode: Less optimizations, debug information in the resulting binary.
debug_mode = getBoolOption( "debug_mode", False )

# Optimization mode: Optimize as much as currently possible.
optimize_mode = getBoolOption( "optimize_mode", True )

# Full compatibility, even where it's stupid, i.e. do not provide information,
# even if available, in order to assert maximum compatbility. Intended to
# control level of compatability to absurd.
full_compat_mode = getBoolOption( "full_compat", False )

# Experimental mode. Do things that are not yet safe to do.
experimental_mode = getBoolOption( "experimental", False )

# LTO mode: Use link time optimizations of g++ compiler if available and known
# good with the compiler in question. The 4.5 one didn't have good enough
# support, the compiled result would not run correctly.
lto_mode = getBoolOption( "lto_mode", False )

# Windows target mode: Cross compile for Windows or compiling on windows.
win_target = getBoolOption( "win_target", os.name == "nt" )

# Windows subsystem mode: Disable console for windows builds.
win_disable_console = getBoolOption( "win_disable_console", False )

# ARM target mode: Compile for ARM which has bad ucontext status, we need
# to provide our own implementation.
arm_linux_target = getBoolOption( "arm_linux_target", "linux" in sys.platform and "arm" in os.uname()[4] )

# x64 target mode: Compile for x64 which swapcontext that does syscall that is
# not necessary. We choose to provide our own implementation.
x64_linux_target = getBoolOption( "x64_linux_target", "linux" in sys.platform and "x86_64" == os.uname()[4] and not win_target )

# Unstriped mode: Do not remove debug symbols.
unstriped_mode = getBoolOption( "unstriped_mode", False )

# Clang compiler mode, default on MacOS X and FreeBSD, optional on Linux.
clang_mode = getBoolOption( "clang_mode", False )
if sys.platform == "darwin" or "freebsd" in sys.platform:
    clang_mode = True

# Portable mode
portable_mode = getBoolOption( "portable_mode", False )

# Home of Python to be compiled against
python_prefix = ARGUMENTS.get( "python_prefix", None )

def createEnvironment( compiler_tools ):
    return Environment(
        # We want the outside environment to be passed through.
        ENV = os.environ,

        # Extra tools configuration for scons.
        tools = compiler_tools,

        # The shared libraries should not be named "lib...", because CPython
        # requires the filename "module_name.so" to load it.
        SHLIBPREFIX = "",
    )

def isExecutable( filename ):
    # Variable substitution from environment.
    if filename.startswith( "$" ):
        filename = env[ filename[1:] ]

    # Append exe suffix if not already present.
    if os.name == "nt" and not filename.lower().endswith( ".exe" ):
        filename += ".exe"

    # Search in PATH environment variable for a file named like it.
    path_elements = os.environ[ "PATH" ].split(
        ";" if os.name == "nt" else ":"
    )

    for path_element in path_elements:
        full = os.path.join( path_element, filename )

        if os.path.exists( full ):
            return True
    else:
        return False


# Create Scons environment, the main control tool. Don't include "mingw" on
# Windows immediately, we will default to MSVC if available.
env = createEnvironment(
    compiler_tools = None if os.name == "nt" or not win_target else [ "mingw" ]
)

if clang_mode:
    # If requested by the user, use the clang compiler.
    env[ "CXX" ] = "clang"
elif "CXX" in os.environ:
    # If the environment variable CXX is set, use that.
    env[ "CXX" ] = os.environ[ "CXX" ]
elif win_target and not isExecutable( env[ "CXX" ] ):
    # The MingW compiler is attemted if no C++ compiler was found, in which case
    # env[ "CXX" ] is still set, but not valid.
    env = createEnvironment(
        compiler_tools = [ "mingw" ]
    )


# To work around Windows not supporting command lines of greater than 10K by
# default:
def setupSpawn( env ):
    def spawn( sh, escape, cmd, args, env ):
        newargs = ' '.join(args[1:])
        cmdline = cmd + " " + newargs
        startupinfo = subprocess.STARTUPINFO()

        # CPython2.6 compatibility
        try:
            from subprocess import STARTF_USESHOWWINDOW
        except ImportError:
            from _subprocess import STARTF_USESHOWWINDOW

        startupinfo.dwFlags |= STARTF_USESHOWWINDOW

        proc = subprocess.Popen(
            cmdline,
            stdin       = subprocess.PIPE,
            stdout      = subprocess.PIPE,
            stderr      = subprocess.PIPE,
            startupinfo = startupinfo,
            shell       = False,
            env         = env
        )

        data, err = proc.communicate()
        rv = proc.wait()

        if cmd == "cl":
            data = data[ data.find( "\r\n" ) + 2 : ]
        elif cmd == "rc":
            data = data[ data.find( "reserved.\r" ) + 13 : ]

            data = "\n".join(
                line
                for line in
                data.split( "\n")
                if not "identifier truncated to"
            )
        elif cmd == "link" and module_mode:
            data = "\r\n".join(
                line
                for line in
                data.split( "\r\n" )
                if "   Creating library" not in line
            )

        if data.rstrip():
            print cmdline
            print data,

        if rv:
            raise RuntimeError( err )

        return rv

    env[ "SPAWN" ] = spawn

def getGccVersion():
    # Update CXXVERSION in env, after we changed it.
    import SCons

    pipe = SCons.Action._subproc(
        env, [ env[ "CXX" ], '--version' ],
        stdin  = 'devnull',
        stderr = 'devnull',
        stdout = subprocess.PIPE
    )

    line = pipe.stdout.readline()

    match = re.search( r'[0-9]+(\.[0-9]+){2}', line )

    if match:
        return match.group(0)
    else:
        return None

def getClangVersion():
    import SCons

    pipe = SCons.Action._subproc(
        env, [ env[ "CXX" ], '--version' ],
        stdin  = 'devnull',
        stderr = 'devnull',
        stdout = subprocess.PIPE
    )

    line = pipe.stdout.readline()

    match = re.search( r'LLVM ([0-9]+(\.[0-9]+){1})', line )

    if match:
        return match.group(1)

    match = re.search( r'([0-9]+(\.[0-9]+){1})', line )

    if match:
        return match.group(1)
    else:
        return None


# To support cross-compiling under Linux for a windows target, a cross compiler
# linked or installed to /opt/mingw will win over a system installed one.
if win_target and "linux" in sys.platform:
    if os.path.exists( "/opt/mingw/usr/bin/i686-pc-mingw32-g++" ):
        env[ "CXX" ] = "/opt/mingw/usr/bin/i686-pc-mingw32-g++"
        env[ "RC" ] = "/opt/mingw/usr/bin/i686-pc-mingw32-windres"
    else:
        env[ "CXX" ] = "i586-mingw32msvc-g++"
        env[ "RC" ] = "i586-mingw32msvc-windres"

    # Update CXXVERSION in env, after we changed it.
    env[ "CXXVERSION" ] = getGccVersion()

orig_cxx = env[ "CXX" ]
orig_cxx_version = env.get( "CXXVERSION", None )

# Remove "g++" as the compiler, if it's not really existing or not good enough.
if "g++" in env[ "CXX" ]:
    gpp_version = getGccVersion()

    if gpp_version is None or int( getGccVersion().replace( ".", "" ) ) < 440:
        del env[ "CXX" ]

# Detect compiler to be used from supported ones, if there is no usable g++
# link.
if os.name != "nt" and "CXX" not in env:
    for candidate in ( "g++-4.7", "g++-4.6", "g++-4.5", "g++-4.4", "clang" ):
        if os.path.exists( os.path.join( "/usr/bin", candidate ) ):
            env[ "CXX" ] = candidate

            if "clang" not in candidate:
                # Update CXXVERSION in env, after we changed it.
                env[ "CXXVERSION" ] = getGccVersion()

            break
    else:
        sys.exit( """\
The g++ compiler '%s' (version %s) doesn't have the sufficient \
version (>= 4.4).""" % ( orig_cxx, orig_cxx_version ) )

if "CXX" not in env:
    if os.name == "nt":
        sys.exit( """\
Error, cannot locate suitable C++ compiler. Install MinGW to 'C:\\MinGW'
exactly or execute from 'Visual Studio Command Prompt' so MSVC can be found.""" )
    else:
        sys.exit( "Error, cannot locate suitable C++ compiler." )

gcc_mode = "g++" in env[ "CXX" ] or "clang" in env[ "CXX" ]
msvc_mode = win_target and not gcc_mode

if os.name == "nt":
    setupSpawn( env )

env[ "BUILD_DIR" ] = source_dir

# Store the file signatures database with the rest of the source files
sconsign_dir = os.path.abspath( os.path.join( source_dir, '.sconsign' ) )

if not os.path.exists( sconsign_dir ):
    os.makedirs( sconsign_dir )

env.SConsignFile( sconsign_dir )

# Support for clang.
if "clang" in env[ "CXX" ]:
    env.Append( CCFLAGS = [ "-w" ] )
    env.Append( CPPDEFINES = [ "_XOPEN_SOURCE" ] )
    env.Append( LINKFLAGS = [ "-lstdc++" ])

    # Don't export anything by default, this should create smaller executables.
    env.Append( CCFLAGS = [
        "-fvisibility=hidden",
        "-fvisibility-inlines-hidden"
        ]
    )

    if debug_mode:
        env.Append( CCFLAGS = [ "-Wunused-but-set-variable" ] )

    clang_version = getClangVersion()
    clang_version = int( clang_version.replace( ".", "" ) + "0" )

# Support for g++.
if "g++" in env[ "CXX" ]:
    # Don't export anything by default, this should create smaller executables.
    if not win_target:
        env.Append( CCFLAGS = [
            "-fvisibility=hidden",
            "-fvisibility-inlines-hidden"
            ]
        )

    env[ "CXXVERSION" ] = getGccVersion()

    # Version dependent options.
    gpp_version = int( env[ "CXXVERSION" ].replace( ".", "" ) )

    # Enforce the minimum version, selecting a potentially existing g++-4.5
    # binary if it's not high enough. This is esp. useful under Debian which
    # allows all compiler to exist next to each other and where g++ might not be
    # good enough, but g++-4.5 would be.
    if gpp_version < 440:
        sys.exit( """\
The g++ compiler %s (version %s) doesn't have the sufficient \
version (>= 4.5).""" % ( env[ "CXX" ], env[ "CXXVERSION" ] ) )

    # Older g++ complains about aliasing with Py_True and Py_False, but we don't
    # care.
    if gpp_version < 450:
        env.Append( CCFLAGS = [ "-fno-strict-aliasing" ] )

    # For LTO mode, the version requirement is even higher, so try that too.
    if lto_mode and gpp_version < 460 and not win_target and \
       os.path.exists( "/usr/bin/g++-4.6" ):
        env[ "CXX" ] = "g++-4.6"
        gpp_version = 460

    # For g++ 4.6 there are some new interesting functions.
    if gpp_version >= 460:
        env.Append( CCFLAGS = [ "-fpartial-inlining" ] )

        if debug_mode:
            env.Append( CCFLAGS = [ "-Wunused-but-set-variable" ] )

    # Use link time optimizations so that gcc can help with optimization across
    # files, but unfortunately at this time it seriously slows down the compiled
    # code. This may be because it needs -O3 option to be effective.

    if gpp_version >= 460 and lto_mode:
        env.Append( CCFLAGS = [ "-flto" ] )
        env.Append( LINKFLAGS = [ "-flto=%d" % GetOption( "num_jobs" ) ] )

        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=noreturn" ] )
        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=pure" ] )
        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=const" ] )
        # env.Append( CCFLAGS = [ "-Wnoexcept" ] )

        if debug_mode:
            env.Append( LINKFLAGS = [ "-O2" ] )

        if optimize_mode:
            env.Append( LINKFLAGS = [
                "-O3",
                "-fpartial-inlining",
                "-freorder-functions",
            ]
        )

    # Give a warning if LTO mode was specified, but won't be used.
    if lto_mode and gpp_version < 460:
        print >> sys.stderr, "Warning, LTO mode specified, but not available."

    # The var-tracking does not scale, disable it. Should we really need it, we
    # can enable it.
    env.Append( CCFLAGS = [ "-fno-var-tracking" ] )

if msvc_mode:
    env.Append( CCFLAGS = [ "/EHsc", "/J", "/Gd" ] )
    env.Append( LINKFLAGS = [ "/INCREMENTAL:NO" ] )

if debug_mode:

    if gcc_mode:
        # Allow g++/clang to point out all kinds of inconsistency to us by
        # raising an error.
        env.Append( CCFLAGS = [ "-Wall", "-Werror" ] )

        if os.name == "nt":
           env.Append( CCFLAGS = [ "-Wno-error=format", "-Wno-format" ] )
    elif msvc_mode:
        # Disable warnings that system headers already show.
        env.Append( CCFLAGS = [
            "/W4", "/wd4505", "/wd4127", "/wd4100", "/wd4702", "/wd4189",
            "/wd4211"
            ]
        )


    # As for sequence points, we are abusing it, so we have to allow it.
    if "g++" in env[ "CXX" ]:
        env.Append( CCFLAGS = [ "-Wno-sequence-point" ] )

    # Benefit from clang checking memory accesses.
    if "clang" in env[ "CXX" ] and clang_version >= 330:
        env.Append( CCFLAGS = [ "-fsanatize=address,bounds,return" ] )

if full_compat_mode:
    env.Append( CPPDEFINES = [ "_NUITKA_FULL_COMPAT" ] )

if experimental_mode:
    env.Append( CPPDEFINES = [ "_NUITKA_EXPERIMENTAL" ] )

if portable_mode:
    env.Append( CPPDEFINES = [ "_NUITKA_PORTABLE" ] )

# Python version, use the scons one if not given.
python_version = ARGUMENTS.get( "python_version", None )

if python_version is None:
    python_version = "%d.%d" % ( sys.version_info[0], sys.version_info[1] )

if win_target:
    # On Windows, the installation layout is relatively fixed.
    env.Append( LIBPATH = [ os.path.join( python_prefix, "libs" ) ] )

    # For MinGW and cross compilation, we need to tell the subsystem
    # to target as well as to automatically import everything used.
    if gcc_mode:
        env.Append( LINKFLAGS = [ "-Wl,--enable-auto-import" ] )

        if win_disable_console:
            env.Append( LINKFLAGS = [ "-Wl,--subsystem,windows" ] )

    python_header_path = os.path.join( python_prefix, "include" )

else:
    # The python header path is a combination of python version and debug
    # indication, make sure the headers are found by adding it to the C++
    # include path.

    python_header_path = os.path.join(
        python_prefix,
        "include",
        "python" + python_version
    )

if not os.path.exists( os.path.join( python_header_path, "Python.h" ) ):
    sys.exit( """\
Error, no 'Python.h' development headers can be found, dependency \
not satisfied!""" )

env.Append( CPPPATH  = [ python_header_path ] )

# The Python library path is not in the standard path for FreeBSD and
# NetBSD, add it manually.
if "freebsd" in sys.platform or "netbsd" in sys.platform:
    python_lib_path = os.path.join( python_prefix, "lib" )

    env.Append( LIBPATH = [ python_lib_path ] )

# For NetBSD the rpath is required, on FreeBSD it's warned as unused.
if "netbsd" in sys.platform:
    env.Append( LINKFLAGS = [ "-rpath=" + python_lib_path ] )

def detectHostMultiarch():
    import commands

    for line in commands.getoutput( "dpkg-architecture" ).split("\n"):
        if line.startswith( "DEB_HOST_MULTIARCH=" ):
            return line.split( "=", 1 )[1]
    else:
        return None

if gcc_mode and "linux" in sys.platform:
    if python_version.startswith( "3.3" ):
        host_multiarch = detectHostMultiarch()

        if host_multiarch is not None:
            env.Append( CCFLAGS = [
                "-I/usr/include/" + host_multiarch + "/python" + python_version
                ]
            )

if win_target:
    env.Append( LIBS = [ "python" + python_version.replace( ".", "" ) ] )
else:
    env.Append( LIBS = [ "python" + python_version ] )

nuitka_include = os.path.join( os.environ[ "NUITKA_SCONS" ], "include" )
env.Append( CPPPATH = [ source_dir, nuitka_include ] )

if debug_mode or unstriped_mode:
    # On crosscompile, use debug format that wine understands, so we get good
    # tracebacks from it.
    if gcc_mode:
        if win_target and "linux" in sys.platform:
            env.Append( CCFLAGS = [ "-gstabs" ] )
            env.Append( ASFLAGS = [ "-gstabs" ] )
        else:
            env.Append( CCFLAGS = [ "-g" ] )
            env.Append( ASFLAGS = [ "-g" ] )

            if "g++" in env[ "CXX" ]:
                env.Append( CCFLAGS = [ "-feliminate-unused-debug-types" ] )
    elif msvc_mode:
        env.Append( CCFLAGS = [ "/Zi" ] )
        env.Append( LINKFLAGS = [ "/DEBUG" ] )

# When debugging, optimize less than when optimizing, when not remove
# assertions.
if debug_mode:
    if not optimize_mode:
        if gcc_mode or msvc_mode:
            env.Append( CCFLAGS = [ "-O2" ] )
else:
    env.Append( CPPDEFINES = [ "__NUITKA_NO_ASSERT__" ] )

if optimize_mode:
    if gcc_mode:
        env.Append( CCFLAGS = [ "-O3" ] )
    elif msvc_mode:
        env.Append( CCFLAGS = [ "/Ox" ] )


# Set load libpython from binary directory default
if portable_mode and gcc_mode:
    env.Append( LINKFLAGS = [ "-Wl,-R,'$$ORIGIN'" ] )

# Tell compiler to create a shared library or program.
if module_mode:
    if "g++" in env[ "CXX" ]:
        env.Append( CCFLAGS = [ "-shared" ] )
    elif "clang" in env[ "CXX" ]:
        pass
    elif msvc_mode:
        env.Append( CCFLAGS = [ "/LD" ] )
    else:
        assert False
else:
    if msvc_mode:
        env.Append( CCFLAGS = [ "/MT" ])

if module_mode:
    env.Append( CPPDEFINES = [ "_NUITKA_MODULE" ] )
else:
    env.Append( CPPDEFINES = [ "_NUITKA_EXE" ] )

def discoverSourceFiles():
    result = []

    def getStatic( sub_path):
       return os.path.join( static_src, sub_path.replace( "/", os.path.sep ) )

    result.append( getStatic( "CompiledFunctionType.cpp" ) )
    result.append( getStatic( "CompiledGeneratorType.cpp" ) )
    result.append( getStatic( "CompiledMethodType.cpp" ) )
    result.append( getStatic( "CompiledFrameType.cpp" ) )
    result.append( getStatic( "CompiledCodeHelpers.cpp" ) )
    result.append( getStatic( "InspectPatcher.cpp" ) )

    if win_target:
        result.append( getStatic( "win32_ucontext_src/fibers_win32.cpp" ) )
    elif x64_linux_target:
        result.append( getStatic( "x64_ucontext_src/fibers_x64.cpp" ) )
        result.append( getStatic( "x64_ucontext_src/swapfiber.S" ) )
    elif arm_linux_target:
        result.append( getStatic( "arm_ucontext_src/fibers_arm.cpp" ) )
        result.append( getStatic( "arm_ucontext_src/ucontext.cpp" ) )
        result.append( getStatic( "arm_ucontext_src/getcontext.asm"  ) )
    else:
        # Variant based on getcontext/setcontext/swapcontext/makecontext
        result.append( getStatic(  "gen_ucontext_src/fibers_gen.cpp" ) )

    module_count = 0

    for filename in os.listdir( source_dir ):
        if filename.endswith( ".cpp" ):
            result.append( os.path.join( source_dir, filename ) )

            if filename.startswith( "module." ):
                module_count += 1

    # If more than one module is included, we need the unfreezer.
    if module_count > 1:
        result.append( os.path.join( static_src, "ModuleUnfreezer.cpp" ) )

    # Add the resource file for the manifest to be included in the executable.
    if msvc_mode and not module_mode:
        result.append(
            env.RES( os.path.join( source_dir, "resources.rc" ) )
        )

    return result

# Prepare the use of a custom specs file for windows targets. We change the used
# specs for linking to avoid the use of the wrong (for CPython) run time
# library.
if msvc_mode and not module_mode:
    manifest_file = open(
        os.path.join( source_dir, "resources.manifest" ),
        "w"
    )
    manifest_file.write( r"""
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="asInvoker" uiAccess="false"></requestedExecutionLevel>
      </requestedPrivileges>
    </security>
  </trustInfo>
  <dependency>
    <dependentAssembly>
      <assemblyIdentity
         type="win32"
         name="Microsoft.VC90.CRT"
         version="9.0.21022.8"
         processorArchitecture="x86"
         publicKeyToken="1fc8b3b9a1e18e3b">
      </assemblyIdentity>
    </dependentAssembly>
  </dependency>
</assembly>
"""
    )
    manifest_file.close()

    rc_file = open( os.path.join( source_dir, "resources.rc" ), "w" )
    rc_file.write( r"""
#include "winuser.h"
1 RT_MANIFEST resources.manifest
"""
    )
    rc_file.close()

if module_mode:
    if win_target:
        module_suffix = ".pyd"
    else:
        module_suffix = ".so"

    env[ "SHLIBSUFFIX" ] = module_suffix

    target = env.SharedLibrary( result_file, discoverSourceFiles() )
else:
    # Avoid dependency on MinGW libraries.
    if win_target and gcc_mode:
        env.Append( LINKFLAGS = [ "-static-libgcc",  "-static-libstdc++" ] )

    target = env.Program( result_file + ".exe", discoverSourceFiles() )

if "CCFLAGS" in os.environ:
    env.Append( CCFLAGS = os.environ[ "CCFLAGS" ].split() )

if "LDFLAGS" in os.environ:
    env.Append( LINKFLAGS = os.environ[ "LDFLAGS" ].split() )

# Remove the target file to avoid cases where it falsely didn't get rebuilt.
if os.path.exists( target[0].abspath ):
    os.unlink( target[0].abspath )

Default( target )
