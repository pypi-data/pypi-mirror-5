<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Parsley Tutorial Part III: Parsing Network Data &mdash; Parsley 1.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Parsley 1.1 documentation" href="index.html" />
    <link rel="next" title="Extending Grammars and Inheritance" href="extending.html" />
    <link rel="prev" title="Parsley Tutorial Part II: Parsing Structured Data" href="tutorial2.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="extending.html" title="Extending Grammars and Inheritance"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial2.html" title="Parsley Tutorial Part II: Parsing Structured Data"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Parsley 1.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="parsley-tutorial-part-iii-parsing-network-data">
<span id="protocol-parsing"></span><h1>Parsley Tutorial Part III: Parsing Network Data<a class="headerlink" href="#parsley-tutorial-part-iii-parsing-network-data" title="Permalink to this headline">¶</a></h1>
<p>This tutorial assumes basic knowledge of writing <a class="reference external" href="http://twistedmatrix.com/trac/">Twisted</a> <a class="reference external" href="http://twistedmatrix.com/documents/current/core/howto/clients.html">TCP clients</a> or
<a class="reference external" href="http://twistedmatrix.com/documents/current/core/howto/servers.html">servers</a>.</p>
<div class="section" id="basic-parsing">
<h2>Basic parsing<a class="headerlink" href="#basic-parsing" title="Permalink to this headline">¶</a></h2>
<p>Parsing data that comes in over the network can be difficult due to that there
is no guarantee of receiving whole messages. Buffering is often complicated by
protocols switching between using fixed-width messages and delimiters for
framing. Fortunately, Parsley can remove all of this tedium.</p>
<p>With <a class="reference internal" href="reference.html#parsley.makeProtocol" title="parsley.makeProtocol"><tt class="xref py py-func docutils literal"><span class="pre">parsley.makeProtocol()</span></tt></a>, Parsley can generate a <a class="reference external" href="http://twistedmatrix.com/trac/">Twisted</a>
<a class="reference external" href="http://twistedmatrix.com/documents/current/api/twisted.internet.interfaces.IProtocol.html">IProtocol</a>-implementing class which will match incoming network data using
Parsley grammar rules. Before getting started with <a class="reference internal" href="reference.html#parsley.makeProtocol" title="parsley.makeProtocol"><tt class="xref py py-func docutils literal"><span class="pre">makeProtocol()</span></tt></a>, let&#8217;s
build a grammar for <a class="reference external" href="http://cr.yp.to/proto/netstrings.txt">netstrings</a>. The netstrings protocol is very simple:</p>
<div class="highlight-python"><pre>4:spam,4:eggs,</pre>
</div>
<p>This stream contains two netstrings: <tt class="docutils literal"><span class="pre">spam</span></tt>, and <tt class="docutils literal"><span class="pre">eggs</span></tt>. The data is
prefixed with one or more ASCII digits followed by a <tt class="docutils literal"><span class="pre">:</span></tt>, and suffixed with a
<tt class="docutils literal"><span class="pre">,</span></tt>. So, a Parsley grammar to match a netstring would look like:</p>
<div class="highlight-python"><pre>nonzeroDigit = digit:x ?(x != '0')
digits = &lt;'0' | nonzeroDigit digit*&gt;:i -&gt; int(i)

netstring = digits:length ':' &lt;anything{length}&gt;:string ',' -&gt; string
</pre>
</div>
<p><a class="reference internal" href="reference.html#parsley.makeProtocol" title="parsley.makeProtocol"><tt class="xref py py-func docutils literal"><span class="pre">makeProtocol()</span></tt></a> takes, in addition to a grammar, a factory for a &#8220;sender&#8221;
and a factory for a &#8220;receiver&#8221;. In the system of objects managed by the
<a class="reference internal" href="reference.html#ometa.protocol.ParserProtocol" title="ometa.protocol.ParserProtocol"><tt class="xref py py-class docutils literal"><span class="pre">ParserProtocol</span></tt></a>, the sender is in charge of writing data to the wire,
and the receiver has methods called on it by the Parsley rules. To demonstrate
it, here is the final piece needed in the Parsley grammar for netstrings:</p>
<div class="highlight-python"><pre>receiveNetstring = netstring:string -&gt; receiver.netstringReceived(string)
</pre>
</div>
<p>The receiver is always available in Parsley rules with the name <tt class="docutils literal"><span class="pre">receiver</span></tt>,
allowing Parsley rules to call methods on it.</p>
<p>When data is received over the wire, the <a class="reference internal" href="reference.html#ometa.protocol.ParserProtocol" title="ometa.protocol.ParserProtocol"><tt class="xref py py-class docutils literal"><span class="pre">ParserProtocol</span></tt></a> tries to
match the received data against the current rule. If the current rule requires
more data to finish matching, the <a class="reference internal" href="reference.html#ometa.protocol.ParserProtocol" title="ometa.protocol.ParserProtocol"><tt class="xref py py-class docutils literal"><span class="pre">ParserProtocol</span></tt></a> stops and waits
until more data comes in, then tries to continue matching. This repeats until
the current rule is completely matched, and then the <a class="reference internal" href="reference.html#ometa.protocol.ParserProtocol" title="ometa.protocol.ParserProtocol"><tt class="xref py py-class docutils literal"><span class="pre">ParserProtocol</span></tt></a>
starts matching any leftover data against the current rule again.</p>
<p>One specifies the current rule by setting a <a class="reference internal" href="reference.html#ometa.protocol.Receiver.currentRule" title="ometa.protocol.Receiver.currentRule"><tt class="xref py py-attr docutils literal"><span class="pre">currentRule</span></tt></a> attribute on
the receiver, which the <a class="reference internal" href="reference.html#ometa.protocol.ParserProtocol" title="ometa.protocol.ParserProtocol"><tt class="xref py py-class docutils literal"><span class="pre">ParserProtocol</span></tt></a> looks at before doing any
parsing. Changing the current rule is addressed in the <a class="reference internal" href="#switching-rules"><em>Switching rules</em></a> section.</p>
<p>Since the <a class="reference internal" href="reference.html#ometa.protocol.ParserProtocol" title="ometa.protocol.ParserProtocol"><tt class="xref py py-class docutils literal"><span class="pre">ParserProtocol</span></tt></a> will never modify the <a class="reference internal" href="reference.html#ometa.protocol.Receiver.currentRule" title="ometa.protocol.Receiver.currentRule"><tt class="xref py py-attr docutils literal"><span class="pre">currentRule</span></tt></a>
attribute itself, the default behavior is to keep using the same rule. Parsing
netstrings doesn&#8217;t require any rule changing, so, the default behavior of
continuing to use the same rule is fine.</p>
<p>Both the sender factory and receiver factory are constructed when the
<a class="reference internal" href="reference.html#ometa.protocol.ParserProtocol" title="ometa.protocol.ParserProtocol"><tt class="xref py py-class docutils literal"><span class="pre">ParserProtocol</span></tt></a>&#8216;s connection is established. The sender factory is a
one-argument callable which will be passed the <a class="reference internal" href="reference.html#ometa.protocol.ParserProtocol" title="ometa.protocol.ParserProtocol"><tt class="xref py py-class docutils literal"><span class="pre">ParserProtocol</span></tt></a>&#8216;s
<a class="reference external" href="http://twistedmatrix.com/documents/current/api/twisted.internet.interfaces.ITransport.html">Transport</a>. This allows the sender to send data over the transport. For
example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">NetstringSender</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span>

    <span class="k">def</span> <span class="nf">sendNetstring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%d</span><span class="s">:</span><span class="si">%s</span><span class="s">,&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">),</span> <span class="n">string</span><span class="p">))</span>
</pre></div>
</div>
<p>The receiver factory is another one-argument callable which is passed the
constructed sender. The returned object must at least have
<a class="reference internal" href="reference.html#ometa.protocol.Receiver.prepareParsing" title="ometa.protocol.Receiver.prepareParsing"><tt class="xref py py-meth docutils literal"><span class="pre">prepareParsing()</span></tt></a> and <a class="reference internal" href="reference.html#ometa.protocol.Receiver.finishParsing" title="ometa.protocol.Receiver.finishParsing"><tt class="xref py py-meth docutils literal"><span class="pre">finishParsing()</span></tt></a> methods.
<a class="reference internal" href="reference.html#ometa.protocol.Receiver.prepareParsing" title="ometa.protocol.Receiver.prepareParsing"><tt class="xref py py-meth docutils literal"><span class="pre">prepareParsing()</span></tt></a> is called with the <a class="reference internal" href="reference.html#ometa.protocol.ParserProtocol" title="ometa.protocol.ParserProtocol"><tt class="xref py py-class docutils literal"><span class="pre">ParserProtocol</span></tt></a> instance
when a connection is established (i.e. in the <tt class="docutils literal"><span class="pre">connectionMade</span></tt> of the
<a class="reference internal" href="reference.html#ometa.protocol.ParserProtocol" title="ometa.protocol.ParserProtocol"><tt class="xref py py-class docutils literal"><span class="pre">ParserProtocol</span></tt></a>) and <a class="reference internal" href="reference.html#ometa.protocol.Receiver.finishParsing" title="ometa.protocol.Receiver.finishParsing"><tt class="xref py py-meth docutils literal"><span class="pre">finishParsing()</span></tt></a> is called when a
connection is closed (i.e. in the <tt class="docutils literal"><span class="pre">connectionLost</span></tt> of the
<a class="reference internal" href="reference.html#ometa.protocol.ParserProtocol" title="ometa.protocol.ParserProtocol"><tt class="xref py py-class docutils literal"><span class="pre">ParserProtocol</span></tt></a>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Both the receiver factory and its returned object&#8217;s <a class="reference internal" href="reference.html#ometa.protocol.Receiver.prepareParsing" title="ometa.protocol.Receiver.prepareParsing"><tt class="xref py py-meth docutils literal"><span class="pre">prepareParsing()</span></tt></a>
are called at in the <a class="reference internal" href="reference.html#ometa.protocol.ParserProtocol" title="ometa.protocol.ParserProtocol"><tt class="xref py py-class docutils literal"><span class="pre">ParserProtocol</span></tt></a>&#8216;s <tt class="docutils literal"><span class="pre">connectionMade</span></tt> method;
this separation is for ease of testing receivers.</p>
</div>
<p>To demonstrate a receiver, here is a simple receiver that receives netstrings
and echos the same netstrings back:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">NetstringReceiver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">currentRule</span> <span class="o">=</span> <span class="s">&#39;receiveNetstring&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sender</span> <span class="o">=</span> <span class="n">sender</span>

    <span class="k">def</span> <span class="nf">prepareParsing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">finishParsing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reason</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">netstringReceived</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sender</span><span class="o">.</span><span class="n">sendNetstring</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p>Putting it all together, the Protocol is constructed using the grammar, sender
factory, and receiver factory:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">NetstringProtocol</span> <span class="o">=</span> <span class="n">makeProtocol</span><span class="p">(</span>
    <span class="n">grammar</span><span class="p">,</span> <span class="n">NetstringSender</span><span class="p">,</span> <span class="n">NetstringReceiver</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference download internal" href="_downloads/tutorial3-netstrings.py"><tt class="xref download docutils literal"><span class="pre">The</span> <span class="pre">complete</span> <span class="pre">script</span> <span class="pre">is</span> <span class="pre">also</span> <span class="pre">available</span> <span class="pre">for</span> <span class="pre">download.</span></tt></a></p>
</div>
<div class="section" id="intermezzo-error-reporting">
<h2>Intermezzo: error reporting<a class="headerlink" href="#intermezzo-error-reporting" title="Permalink to this headline">¶</a></h2>
<p>If an exception is raised from within Parsley during parsing, whether it&#8217;s due
to input not matching the current rule or an exception being raised from code
the grammar calls, the connection will be immediately closed. The traceback
will be captured as a <a class="reference external" href="http://twistedmatrix.com/documents/current/api/twisted.python.failure.Failure.html">Failure</a> and passed to the <a class="reference internal" href="reference.html#ometa.protocol.Receiver.finishParsing" title="ometa.protocol.Receiver.finishParsing"><tt class="xref py py-meth docutils literal"><span class="pre">finishParsing()</span></tt></a>
method of the receiver.</p>
<p>At present, there is no way to recover from failure.</p>
</div>
<div class="section" id="composing-senders-and-receivers">
<h2>Composing senders and receivers<a class="headerlink" href="#composing-senders-and-receivers" title="Permalink to this headline">¶</a></h2>
<p>The design of senders and receivers is intentional to make composition easy: no
subclassing is required. While the composition is easy enough to do on your
own, Parsley provides a function: <a class="reference internal" href="reference.html#parsley.stack" title="parsley.stack"><tt class="xref py py-func docutils literal"><span class="pre">stack()</span></tt></a>. It takes a base factory
followed by zero or more wrappers.</p>
<p>Its use is extremely simple: <tt class="docutils literal"><span class="pre">stack(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></tt> will return a callable suitable
either as a sender or receiver factory which will, when called with an
argument, return <tt class="docutils literal"><span class="pre">x(y(z(argument)))</span></tt>.</p>
<p>An example of wrapping a sender factory:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">NetstringReversalWrapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">wrapped</span>

    <span class="k">def</span> <span class="nf">sendNetstring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">sendNetstring</span><span class="p">(</span><span class="n">string</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>And then, constructing the Protocol:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">NetstringProtocol</span> <span class="o">=</span> <span class="n">makeProtocol</span><span class="p">(</span>
    <span class="n">grammar</span><span class="p">,</span>
    <span class="n">stack</span><span class="p">(</span><span class="n">NetstringReversalWrapper</span><span class="p">,</span> <span class="n">NetstringSender</span><span class="p">),</span>
    <span class="n">NetstringReceiver</span><span class="p">)</span>
</pre></div>
</div>
<p>A wrapper doesn&#8217;t need to call the same methods on the thing it&#8217;s wrapping.
Also note that in most cases, it&#8217;s important to forward unknown methods on to
the wrapped object. An example of wrapping a receiver:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">NetstringSplittingWrapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">wrapped</span>

    <span class="k">def</span> <span class="nf">netstringReceived</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
        <span class="n">splitpoint</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">netstringFirstHalfReceived</span><span class="p">(</span><span class="n">string</span><span class="p">[:</span><span class="n">splitpoint</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">netstringSecondHalfReceived</span><span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="n">splitpoint</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
</pre></div>
</div>
<p>The corresponding receiver and again, constructing the Protocol:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">SplitNetstringReceiver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">currentRule</span> <span class="o">=</span> <span class="s">&#39;receiveNetstring&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sender</span> <span class="o">=</span> <span class="n">sender</span>

    <span class="k">def</span> <span class="nf">prepareParsing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">finishParsing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reason</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">netstringFirstHalfReceived</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sender</span><span class="o">.</span><span class="n">sendNetstring</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">netstringSecondHalfReceived</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<div class="highlight-python"><pre>NetstringProtocol = makeProtocol(
    grammar,
    stack(NetstringReversalWrapper, NetstringSender),
</pre>
</div>
<p><a class="reference download internal" href="_downloads/tutorial3-netstring-reversal.py"><tt class="xref download docutils literal"><span class="pre">The</span> <span class="pre">complete</span> <span class="pre">script</span> <span class="pre">is</span> <span class="pre">also</span> <span class="pre">available</span> <span class="pre">for</span> <span class="pre">download.</span></tt></a></p>
</div>
<div class="section" id="switching-rules">
<span id="id1"></span><h2>Switching rules<a class="headerlink" href="#switching-rules" title="Permalink to this headline">¶</a></h2>
<p>As mentioned before, it&#8217;s possible to change the current rule. Imagine a
&#8220;netstrings2&#8221; protocol that looks like this:</p>
<div class="highlight-python"><pre>3:foo,3;bar,4:spam,4;eggs,</pre>
</div>
<p>That is, the protocol alternates between using <tt class="docutils literal"><span class="pre">:</span></tt> and using <tt class="docutils literal"><span class="pre">;</span></tt> delimiting
data length and the data. The amended grammar would look something like this:</p>
<div class="highlight-python"><pre>nonzeroDigit = digit:x ?(x != '0')
digits = &lt;'0' | nonzeroDigit digit*&gt;:i -&gt; int(i)
netstring :delimiter = digits:length delimiter &lt;anything{length}&gt;:string ',' -&gt; string

colon = digits:length ':' &lt;anything{length}&gt;:string ',' -&gt; receiver.netstringReceived(':', string)
semicolon = digits:length ';' &lt;anything{length}&gt;:string ',' -&gt; receiver.netstringReceived(';', string)
</pre>
</div>
<p>Changing the current rule is as simple as changing the <a class="reference internal" href="reference.html#ometa.protocol.Receiver.currentRule" title="ometa.protocol.Receiver.currentRule"><tt class="xref py py-attr docutils literal"><span class="pre">currentRule</span></tt></a>
attribute on the receiver. So, the <tt class="docutils literal"><span class="pre">netstringReceived</span></tt> method could look like
this:</p>
<div class="highlight-python"><div class="highlight"><pre>    <span class="k">def</span> <span class="nf">netstringReceived</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sender</span><span class="o">.</span><span class="n">sendNetstring</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">delimiter</span> <span class="o">==</span> <span class="s">&#39;:&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">currentRule</span> <span class="o">=</span> <span class="s">&#39;semicolon&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">currentRule</span> <span class="o">=</span> <span class="s">&#39;colon&#39;</span>
</pre></div>
</div>
<p>While changing the <a class="reference internal" href="reference.html#ometa.protocol.Receiver.currentRule" title="ometa.protocol.Receiver.currentRule"><tt class="xref py py-attr docutils literal"><span class="pre">currentRule</span></tt></a> attribute can be done at any time, the
<a class="reference internal" href="reference.html#ometa.protocol.ParserProtocol" title="ometa.protocol.ParserProtocol"><tt class="xref py py-class docutils literal"><span class="pre">ParserProtocol</span></tt></a> only examines the <a class="reference internal" href="reference.html#ometa.protocol.Receiver.currentRule" title="ometa.protocol.Receiver.currentRule"><tt class="xref py py-attr docutils literal"><span class="pre">currentRule</span></tt></a> at the
beginning of parsing and after a rule has finished matching. As a result, if
the <a class="reference internal" href="reference.html#ometa.protocol.Receiver.currentRule" title="ometa.protocol.Receiver.currentRule"><tt class="xref py py-attr docutils literal"><span class="pre">currentRule</span></tt></a> changes, the <a class="reference internal" href="reference.html#ometa.protocol.ParserProtocol" title="ometa.protocol.ParserProtocol"><tt class="xref py py-class docutils literal"><span class="pre">ParserProtocol</span></tt></a> will wait until
the current rule is completely matched before switching rules.</p>
<p><a class="reference download internal" href="_downloads/tutorial3-netstrings2.py"><tt class="xref download docutils literal"><span class="pre">The</span> <span class="pre">complete</span> <span class="pre">script</span> <span class="pre">is</span> <span class="pre">also</span> <span class="pre">available</span> <span class="pre">for</span> <span class="pre">download.</span></tt></a></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Parsley Tutorial Part III: Parsing Network Data</a><ul>
<li><a class="reference internal" href="#basic-parsing">Basic parsing</a></li>
<li><a class="reference internal" href="#intermezzo-error-reporting">Intermezzo: error reporting</a></li>
<li><a class="reference internal" href="#composing-senders-and-receivers">Composing senders and receivers</a></li>
<li><a class="reference internal" href="#switching-rules">Switching rules</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tutorial2.html"
                        title="previous chapter">Parsley Tutorial Part II: Parsing Structured Data</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="extending.html"
                        title="next chapter">Extending Grammars and Inheritance</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/tutorial3.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="extending.html" title="Extending Grammars and Inheritance"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial2.html" title="Parsley Tutorial Part II: Parsing Structured Data"
             >previous</a> |</li>
        <li><a href="index.html">Parsley 1.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Allen Short.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>